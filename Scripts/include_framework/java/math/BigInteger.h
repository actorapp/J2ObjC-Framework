//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/math/src/main/java/java/math/BigInteger.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaMathBigInteger")
#ifdef RESTRICT_JavaMathBigInteger
#define INCLUDE_ALL_JavaMathBigInteger 0
#else
#define INCLUDE_ALL_JavaMathBigInteger 1
#endif
#undef RESTRICT_JavaMathBigInteger

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaMathBigInteger_) && (INCLUDE_ALL_JavaMathBigInteger || defined(INCLUDE_JavaMathBigInteger))
#define JavaMathBigInteger_

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "../../java/lang/Comparable.h"

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "../../java/io/Serializable.h"

@class IOSByteArray;
@class IOSIntArray;
@class IOSObjectArray;
@class JavaUtilRandom;

/*!
 @brief This class represents immutable integer numbers of arbitrary length.
 Large
 numbers are typically used in security applications and therefore BigIntegers
 offer dedicated functionality like the generation of large prime numbers or
 the computation of modular inverse.
 <p>
 Since the class was modeled to offer all the functionality as the <code>Integer</code>
 class does, it provides even methods that operate bitwise on a two's
 complement representation of large integers. Note however that the
 implementations favors an internal representation where magnitude and sign
 are treated separately. Hence such operations are inefficient and should be
 discouraged. In simple words: Do NOT implement any bit fields based on
 BigInteger.
 */
@interface JavaMathBigInteger : NSNumber < JavaLangComparable, JavaIoSerializable > {
 @public
  /*!
   @brief The magnitude of this big integer.
   This array holds unsigned little
 endian digits. For example:
 <code>13</code> is represented as [ 13 ]
 <code>-13</code> is represented as [ 13 ]
 <code>2^32 + 13</code> is represented as [ 13, 1 ]
 <code>2^64 + 13</code> is represented as [ 13, 0, 1 ]
 <code>2^31</code> is represented as [ Integer.MIN_VALUE ]
 The magnitude array may be longer than strictly necessary, which results
 in additional trailing zeros.
   */
  IOSIntArray *digits_;
  /*!
   @brief The length of this in measured in ints.
   Can be less than digits.length(). 
   */
  jint numberLength_;
  /*!
   @brief The sign of this.
   */
  jint sign_;
}

+ (JavaMathBigInteger *)ZERO;

+ (JavaMathBigInteger *)ONE;

+ (JavaMathBigInteger *)TEN;

+ (JavaMathBigInteger *)MINUS_ONE;

+ (jint)EQUALS;

+ (jint)GREATER;

+ (jint)LESS;

+ (IOSObjectArray *)SMALL_VALUES;

+ (IOSObjectArray *)TWO_POWS;

#pragma mark Public

/*!
 @brief Constructs a new <code>BigInteger</code> from the given two's complement
 representation.
 The most significant byte is the entry at index 0. The
 most significant bit of this entry determines the sign of the new <code>BigInteger</code>
  instance. The given array must not be empty.
 @param val
 two's complement representation of the new <code>BigInteger</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 @throws NumberFormatException
 if the length of <code>val</code> is zero.
 */
- (instancetype)initWithByteArray:(IOSByteArray *)val;

/*!
 @brief Constructs a new <code>BigInteger</code> instance with the given sign and the
 given magnitude.
 The sign is given as an integer (-1 for negative, 0 for
 zero, 1 for positive). The magnitude is specified as a byte array. The
 most significant byte is the entry at index 0.
 @param signum
 sign of the new <code>BigInteger</code> (-1 for negative, 0 for
 zero, 1 for positive).
 @param magnitude
 magnitude of the new <code>BigInteger</code> with the most
 significant byte first.
 @throws NullPointerException
 if <code>magnitude == null</code>.
 @throws NumberFormatException
 if the sign is not one of -1, 0, 1 or if the sign is zero and
 the magnitude contains non-zero entries.
 */
- (instancetype)initWithInt:(jint)signum
              withByteArray:(IOSByteArray *)magnitude;

/*!
 @brief Constructs a random <code>BigInteger</code> instance in the range [0,
 2^(bitLength)-1] which is probably prime.
 The probability that the
 returned <code>BigInteger</code> is prime is beyond (1-1/2^certainty).
 @param bitLength
 length of the new <code>BigInteger</code> in bits.
 @param certainty
 tolerated primality uncertainty.
 @param rnd
 is an optional random generator to be used.
 @throws ArithmeticException
 if <code>bitLength</code> < 2.
 */
- (instancetype)initWithInt:(jint)bitLength
                    withInt:(jint)certainty
         withJavaUtilRandom:(JavaUtilRandom *)rnd;

/*!
 @brief Constructs a random non-negative <code>BigInteger</code> instance in the range
 [0, 2^(numBits)-1].
 @param numBits
 maximum length of the new <code>BigInteger</code> in bits.
 @param rnd
 is an optional random generator to be used.
 @throws IllegalArgumentException
 if <code>numBits</code> < 0.
 */
- (instancetype)initWithInt:(jint)numBits
         withJavaUtilRandom:(JavaUtilRandom *)rnd;

/*!
 @brief Constructs a new <code>BigInteger</code> instance from the string
 representation.
 The string representation consists of an optional minus
 sign followed by a non-empty sequence of decimal digits.
 @param val
 string representation of the new <code>BigInteger</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 @throws NumberFormatException
 if <code>val</code> is not a valid representation of a <code>BigInteger</code>
 .
 */
- (instancetype)initWithNSString:(NSString *)val;

/*!
 @brief Constructs a new <code>BigInteger</code> instance from the string
 representation.
 The string representation consists of an optional minus
 sign followed by a non-empty sequence of digits in the specified radix.
 For the conversion the method <code>Character.digit(char, radix)</code> is
 used.
 @param val
 string representation of the new <code>BigInteger</code>.
 @param radix
 the base to be used for the conversion.
 @throws NullPointerException
 if <code>val == null</code>.
 @throws NumberFormatException
 if <code>val</code> is not a valid representation of a <code>BigInteger</code>
  or if <code>radix < Character.MIN_RADIX</code> or
 <code>radix > Character.MAX_RADIX</code>.
 */
- (instancetype)initWithNSString:(NSString *)val
                         withInt:(jint)radix;

/*!
 @brief Returns a (new) <code>BigInteger</code> whose value is the absolute value of
 <code>this</code>.
 @return <code>abs(this)</code>.
 */
- (JavaMathBigInteger *)abs;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this + val</code>.
 @param val
 value to be added to <code>this</code>.
 @return <code>this + val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigInteger *)addWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this & val</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @param val
 value to be and'ed with <code>this</code>.
 @return <code>this & val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigInteger *)and__WithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this & ~val</code>.
 Evaluating <code>x.andNot(val)</code> returns the same result as <code>x.and(val.not())</code>
 .
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @param val
 value to be not'ed and then and'ed with <code>this</code>.
 @return <code>this & ~val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigInteger *)andNotWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Use <code>bitLength(0)</code> if you want to know the length of the binary
 value in bits.
 <p>
 Returns the number of bits in the binary representation of <code>this</code>
 which differ from the sign bit. If <code>this</code> is positive the result is
 equivalent to the number of bits set in the binary representation of
 <code>this</code>. If <code>this</code> is negative the result is equivalent to the
 number of bits set in the binary representation of <code>-this-1</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @return number of bits in the binary representation of <code>this</code> which
 differ from the sign bit
 */
- (jint)bitCount;

/*!
 @brief Returns the length of the value's two's complement representation without
 leading zeros for positive numbers / without leading ones for negative
 values.
 <p>
 The two's complement representation of <code>this</code> will be at least
 <code>bitLength() + 1</code> bits long.
 <p>
 The value will fit into an <code>int</code> if <code>bitLength() < 32</code> or
 into a <code>long</code> if <code>bitLength() < 64</code>.
 @return the length of the minimal two's complement representation for
 <code>this</code> without the sign bit.
 */
- (jint)bitLength;

/*!
 @brief Returns a new <code>BigInteger</code> which has the same binary representation
 as <code>this</code> but with the bit at position n cleared.
 The result is
 equivalent to <code>this & ~(2^n)</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @param n
 position where the bit in <code>this</code> has to be cleared.
 @return <code>this & ~(2^n)</code>.
 @throws ArithmeticException
 if <code>n < 0</code>.
 */
- (JavaMathBigInteger *)clearBitWithInt:(jint)n;

/*!
 @brief Compares this <code>BigInteger</code> with <code>val</code>.
 Returns one of the
 three values 1, 0, or -1.
 @param val
 value to be compared with <code>this</code>.
 @return <code>1</code> if <code>this > val</code>, <code>-1</code> if <code>this < val</code>
 , <code>0</code> if <code>this == val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (jint)compareToWithId:(JavaMathBigInteger *)val;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this / divisor</code>.
 @param divisor
 value by which <code>this</code> is divided.
 @return <code>this / divisor</code>.
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 */
- (JavaMathBigInteger *)divideWithJavaMathBigInteger:(JavaMathBigInteger *)divisor;

/*!
 @brief Returns a <code>BigInteger</code> array which contains <code>this / divisor</code>
 at index 0 and <code>this % divisor</code> at index 1.
 @param divisor
 value by which <code>this</code> is divided.
 @return <code>[this / divisor, this % divisor]</code>.
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 - seealso: #divide
 - seealso: #remainder
 */
- (IOSObjectArray *)divideAndRemainderWithJavaMathBigInteger:(JavaMathBigInteger *)divisor;

/*!
 @brief Returns this <code>BigInteger</code> as an double value.
 If <code>this</code> is
 too big to be represented as an double, then <code>Double.POSITIVE_INFINITY</code>
  or <code>Double.NEGATIVE_INFINITY</code> is
 returned. Note, that not all integers x in the range [-Double.MAX_VALUE,
 Double.MAX_VALUE] can be represented as a double. The double
 representation has a mantissa of length 53. For example, 2^53+1 =
 9007199254740993 is returned as double 9007199254740992.0.
 @return this <code>BigInteger</code> as a double value
 */
- (jdouble)doubleValue;

/*!
 @brief Returns <code>true</code> if <code>x</code> is a BigInteger instance and if this
 instance is equal to this <code>BigInteger</code>.
 @param x
 object to be compared with <code>this</code>.
 @return true if <code>x</code> is a BigInteger and <code>this == x</code>,
 <code>false</code> otherwise.
 */
- (jboolean)isEqual:(id)x;

/*!
 @brief Returns a new <code>BigInteger</code> which has the same binary representation
 as <code>this</code> but with the bit at position n flipped.
 The result is
 equivalent to <code>this ^ 2^n</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @param n
 position where the bit in <code>this</code> has to be flipped.
 @return <code>this ^ 2^n</code>.
 @throws ArithmeticException
 if <code>n < 0</code>.
 */
- (JavaMathBigInteger *)flipBitWithInt:(jint)n;

/*!
 @brief Returns this <code>BigInteger</code> as an float value.
 If <code>this</code> is too
 big to be represented as an float, then <code>Float.POSITIVE_INFINITY</code>
 or <code>Float.NEGATIVE_INFINITY</code> is returned. Note, that not all
 integers x in the range [-Float.MAX_VALUE, Float.MAX_VALUE] can be
 represented as a float. The float representation has a mantissa of length
 24. For example, 2^24+1 = 16777217 is returned as float 16777216.0.
 @return this <code>BigInteger</code> as a float value.
 */
- (jfloat)floatValue;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is greatest common divisor
 of <code>this</code> and <code>val</code>.
 If <code>this==0</code> and <code>val==0</code>
 then zero is returned, otherwise the result is positive.
 @param val
 value with which the greatest common divisor is computed.
 @return <code>gcd(this, val)</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigInteger *)gcdWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns the position of the lowest set bit in the two's complement
 representation of this <code>BigInteger</code>.
 If all bits are zero (this=0)
 then -1 is returned as result.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @return position of lowest bit if <code>this != 0</code>, <code>-1</code> otherwise
 */
- (jint)getLowestSetBit;

/*!
 @brief Returns a hash code for this <code>BigInteger</code>.
 @return hash code for <code>this</code>.
 */
- (NSUInteger)hash;

/*!
 @brief Returns this <code>BigInteger</code> as an int value.
 If <code>this</code> is too
 big to be represented as an int, then <code>this</code> % 2^32 is returned.
 @return this <code>BigInteger</code> as an int value.
 */
- (jint)intValue;

/*!
 @brief Tests whether this <code>BigInteger</code> is probably prime.
 If <code>true</code>
 is returned, then this is prime with a probability beyond
 (1-1/2^certainty). If <code>false</code> is returned, then this is definitely
 composite. If the argument <code>certainty</code> <= 0, then this method
 returns true.
 @param certainty
 tolerated primality uncertainty.
 @return <code>true</code>, if <code>this</code> is probably prime, <code>false</code>
 otherwise.
 */
- (jboolean)isProbablePrimeWithInt:(jint)certainty;

/*!
 @brief Returns this <code>BigInteger</code> as an long value.
 If <code>this</code> is too
 big to be represented as an long, then <code>this</code> % 2^64 is returned.
 @return this <code>BigInteger</code> as a long value.
 */
- (jlong)longLongValue;

/*!
 @brief Returns the maximum of this <code>BigInteger</code> and <code>val</code>.
 @param val
 value to be used to compute the maximum with <code>this</code>
 @return <code>max(this, val)</code>
 @throws NullPointerException
 if <code>val == null</code>
 */
- (JavaMathBigInteger *)maxWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns the minimum of this <code>BigInteger</code> and <code>val</code>.
 @param val
 value to be used to compute the minimum with <code>this</code>.
 @return <code>min(this, val)</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigInteger *)minWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this mod m</code>.
 The
 modulus <code>m</code> must be positive. The result is guaranteed to be in the
 interval <code>[0, m)</code> (0 inclusive, m exclusive). The behavior of this
 function is not equivalent to the behavior of the % operator defined for
 the built-in <code>int</code>'s.
 @param m
 the modulus.
 @return <code>this mod m</code>.
 @throws NullPointerException
 if <code>m == null</code>.
 @throws ArithmeticException
 if <code>m < 0</code>.
 */
- (JavaMathBigInteger *)modWithJavaMathBigInteger:(JavaMathBigInteger *)m;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>1/this mod m</code>.
 The
 modulus <code>m</code> must be positive. The result is guaranteed to be in the
 interval <code>[0, m)</code> (0 inclusive, m exclusive). If <code>this</code> is
 not relatively prime to m, then an exception is thrown.
 @param m
 the modulus.
 @return <code>1/this mod m</code>.
 @throws NullPointerException
 if <code>m == null</code>
 @throws ArithmeticException
 if <code>m < 0 or</code> if <code>this</code> is not relatively prime
 to <code>m</code>
 */
- (JavaMathBigInteger *)modInverseWithJavaMathBigInteger:(JavaMathBigInteger *)m;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this^exponent mod
 m</code>
 .
 The modulus <code>m</code> must be positive. The result is guaranteed to
 be in the interval <code>[0, m)</code> (0 inclusive, m exclusive). If the
 exponent is negative, then <code>this.modInverse(m)^(-exponent) mod m)</code>
 is computed. The inverse of this only exists if <code>this</code> is
 relatively prime to m, otherwise an exception is thrown.
 @param exponent
 the exponent.
 @param m
 the modulus.
 @return <code>this^exponent mod val</code>.
 @throws NullPointerException
 if <code>m == null</code> or <code>exponent == null</code>.
 @throws ArithmeticException
 if <code>m < 0</code> or if <code>exponent<0</code> and this is not
 relatively prime to <code>m</code>.
 */
- (JavaMathBigInteger *)modPowWithJavaMathBigInteger:(JavaMathBigInteger *)exponent
                              withJavaMathBigInteger:(JavaMathBigInteger *)m;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this * val</code>.
 @param val
 value to be multiplied with <code>this</code>.
 @return <code>this * val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigInteger *)multiplyWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is the <code>-this</code>.
 @return <code>-this</code>.
 */
- (JavaMathBigInteger *)negate;

/*!
 @brief Returns the smallest integer x > <code>this</code> which is probably prime as
 a <code>BigInteger</code> instance.
 The probability that the returned <code>BigInteger</code>
  is prime is beyond (1-1/2^80).
 @return smallest integer > <code>this</code> which is robably prime.
 @throws ArithmeticException
 if <code>this < 0</code>.
 */
- (JavaMathBigInteger *)nextProbablePrime;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>~this</code>.
 The result
 of this operation is <code>-this-1</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @return <code>~this</code>.
 */
- (JavaMathBigInteger *)not__;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this | val</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @param val
 value to be or'ed with <code>this</code>.
 @return <code>this | val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigInteger *)or__WithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this ^ exp</code>.
 @param exp
 exponent to which <code>this</code> is raised.
 @return <code>this ^ exp</code>.
 @throws ArithmeticException
 if <code>exp < 0</code>.
 */
- (JavaMathBigInteger *)powWithInt:(jint)exp;

/*!
 @brief Returns a random positive <code>BigInteger</code> instance in the range [0,
 2^(bitLength)-1] which is probably prime.
 The probability that the
 returned <code>BigInteger</code> is prime is beyond (1-1/2^80).
 <p>
 <b>Implementation Note:</b> Currently <code>rnd</code> is ignored.
 @param bitLength
 length of the new <code>BigInteger</code> in bits.
 @param rnd
 random generator used to generate the new <code>BigInteger</code>.
 @return probably prime random <code>BigInteger</code> instance.
 @throws IllegalArgumentException
 if <code>bitLength < 2</code>.
 */
+ (JavaMathBigInteger *)probablePrimeWithInt:(jint)bitLength
                          withJavaUtilRandom:(JavaUtilRandom *)rnd;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this % divisor</code>.
 Regarding signs this methods has the same behavior as the % operator on
 int's, i.e. the sign of the remainder is the same as the sign of this.
 @param divisor
 value by which <code>this</code> is divided.
 @return <code>this % divisor</code>.
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 */
- (JavaMathBigInteger *)remainderWithJavaMathBigInteger:(JavaMathBigInteger *)divisor;

/*!
 @brief Returns a new <code>BigInteger</code> which has the same binary representation
 as <code>this</code> but with the bit at position n set.
 The result is
 equivalent to <code>this | 2^n</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @param n
 position where the bit in <code>this</code> has to be set.
 @return <code>this | 2^n</code>.
 @throws ArithmeticException
 if <code>n < 0</code>.
 */
- (JavaMathBigInteger *)setBitWithInt:(jint)n;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this << n</code>.
 The
 result is equivalent to <code>this * 2^n</code> if n >= 0. The shift distance
 may be negative which means that <code>this</code> is shifted right. The
 result then corresponds to <code>floor(this / 2^(-n))</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method on negative values is
 not recommended as the current implementation is not efficient.
 @param n
 shift distance.
 @return <code>this << n</code> if <code>n >= 0</code>; <code>this >> (-n)</code>.
 otherwise
 */
- (JavaMathBigInteger *)shiftLeftWithInt:(jint)n;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this >> n</code>.
 For
 negative arguments, the result is also negative. The shift distance may
 be negative which means that <code>this</code> is shifted left.
 <p>
 <b>Implementation Note:</b> Usage of this method on negative values is
 not recommended as the current implementation is not efficient.
 @param n
 shift distance
 @return <code>this >> n</code> if <code>n >= 0</code>; <code>this << (-n)</code>
 otherwise
 */
- (JavaMathBigInteger *)shiftRightWithInt:(jint)n;

/*!
 @brief Returns the sign of this <code>BigInteger</code>.
 @return <code>-1</code> if <code>this < 0</code>,
 <code>0</code> if <code>this == 0</code>,
 <code>1</code> if <code>this > 0</code>.
 */
- (jint)signum;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this - val</code>.
 @param val
 value to be subtracted from <code>this</code>.
 @return <code>this - val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigInteger *)subtractWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Tests whether the bit at position n in <code>this</code> is set.
 The result is
 equivalent to <code>this & (2^n) != 0</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @param n
 position where the bit in <code>this</code> has to be inspected.
 @return <code>this & (2^n) != 0</code>.
 @throws ArithmeticException
 if <code>n < 0</code>.
 */
- (jboolean)testBitWithInt:(jint)n;

/*!
 @brief Returns the two's complement representation of this BigInteger in a byte
 array.
 @return two's complement representation of <code>this</code>.
 */
- (IOSByteArray *)toByteArray;

/*!
 @brief Returns a string representation of this <code>BigInteger</code> in decimal
 form.
 @return a string representation of <code>this</code> in decimal form.
 */
- (NSString *)description;

/*!
 @brief Returns a string containing a string representation of this <code>BigInteger</code>
  with base radix.
 If <code>radix < Character.MIN_RADIX</code> or
 <code>radix > Character.MAX_RADIX</code> then a decimal representation is
 returned. The characters of the string representation are generated with
 method <code>Character.forDigit</code>.
 @param radix
 base to be used for the string representation.
 @return a string representation of this with radix 10.
 */
- (NSString *)toStringWithInt:(jint)radix;

+ (JavaMathBigInteger *)valueOfWithLong:(jlong)val;

/*!
 @brief Returns a new <code>BigInteger</code> whose value is <code>this ^ val</code>.
 <p>
 <b>Implementation Note:</b> Usage of this method is not recommended as
 the current implementation is not efficient.
 @param val
 value to be xor'ed with <code>this</code>
 @return <code>this ^ val</code>
 @throws NullPointerException
 if <code>val == null</code>
 */
- (JavaMathBigInteger *)xor__WithJavaMathBigInteger:(JavaMathBigInteger *)val;

#pragma mark Package-Private

/*!
 @brief Constructs a number which array is of size 1.
 @param sign
 the sign of the number
 @param value
 the only one digit of array
 */
- (instancetype)initWithInt:(jint)sign
                    withInt:(jint)value;

/*!
 @brief Constructs a number without to create new space.
 This construct should be
 used only if the three fields of representation are known.
 @param sign
 the sign of the number
 @param numberLength
 the length of the internal array
 @param digits
 a reference of some array created before
 */
- (instancetype)initWithInt:(jint)sign
                    withInt:(jint)numberLength
               withIntArray:(IOSIntArray *)digits;

/*!
 @brief Creates a new <code>BigInteger</code> with the given sign and magnitude.
 This
 constructor does not create a copy, so any changes to the reference will
 affect the new number.
 @param signum
 The sign of the number represented by <code>digits</code>
 @param digits
 The magnitude of the number
 */
- (instancetype)initWithInt:(jint)signum
               withIntArray:(IOSIntArray *)digits;

/*!
 @brief Creates a new <code>BigInteger</code> whose value is equal to the specified
 <code>long</code>.
 @param sign
 the sign of the number
 @param val
 the value of the new <code>BigInteger</code>.
 */
- (instancetype)initWithInt:(jint)sign
                   withLong:(jlong)val;

- (JavaMathBigInteger *)copy__ OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Decreases <code>numberLength</code> if there are zero high elements.
 */
- (void)cutOffLeadingZeroes;

- (jboolean)equalsArraysWithIntArray:(IOSIntArray *)b;

- (jint)getFirstNonzeroDigit;

+ (JavaMathBigInteger *)getPowerOfTwoWithInt:(jint)exp;

/*!
 @brief Tests if <code>this.abs()</code> is equals to <code>ONE</code>
 */
- (jboolean)isOne;

- (JavaMathBigInteger *)shiftLeftOneBit;

- (void)unCache;

@end

J2OBJC_STATIC_INIT(JavaMathBigInteger)

J2OBJC_FIELD_SETTER(JavaMathBigInteger, digits_, IOSIntArray *)

/*!
 @brief The <code>BigInteger</code> constant 0.
 */
inline JavaMathBigInteger *JavaMathBigInteger_get_ZERO();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_ZERO;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigInteger, ZERO, JavaMathBigInteger *)

/*!
 @brief The <code>BigInteger</code> constant 1.
 */
inline JavaMathBigInteger *JavaMathBigInteger_get_ONE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_ONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigInteger, ONE, JavaMathBigInteger *)

/*!
 @brief The <code>BigInteger</code> constant 10.
 */
inline JavaMathBigInteger *JavaMathBigInteger_get_TEN();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_TEN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigInteger, TEN, JavaMathBigInteger *)

/*!
 @brief The <code>BigInteger</code> constant -1.
 */
inline JavaMathBigInteger *JavaMathBigInteger_get_MINUS_ONE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_MINUS_ONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigInteger, MINUS_ONE, JavaMathBigInteger *)

/*!
 @brief The <code>BigInteger</code> constant 0 used for comparison.
 */
inline jint JavaMathBigInteger_get_EQUALS();
#define JavaMathBigInteger_EQUALS 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigInteger, EQUALS, jint)

/*!
 @brief The <code>BigInteger</code> constant 1 used for comparison.
 */
inline jint JavaMathBigInteger_get_GREATER();
#define JavaMathBigInteger_GREATER 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigInteger, GREATER, jint)

/*!
 @brief The <code>BigInteger</code> constant -1 used for comparison.
 */
inline jint JavaMathBigInteger_get_LESS();
#define JavaMathBigInteger_LESS -1
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigInteger, LESS, jint)

/*!
 @brief All the <code>BigInteger</code> numbers in the range [0,10] are cached.
 */
inline IOSObjectArray *JavaMathBigInteger_get_SMALL_VALUES();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *JavaMathBigInteger_SMALL_VALUES;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigInteger, SMALL_VALUES, IOSObjectArray *)

inline IOSObjectArray *JavaMathBigInteger_get_TWO_POWS();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSObjectArray *JavaMathBigInteger_TWO_POWS;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigInteger, TWO_POWS, IOSObjectArray *)

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withJavaUtilRandom_(JavaMathBigInteger *self, jint numBits, JavaUtilRandom *rnd);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withJavaUtilRandom_(jint numBits, JavaUtilRandom *rnd) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withJavaUtilRandom_(jint numBits, JavaUtilRandom *rnd);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withInt_withJavaUtilRandom_(JavaMathBigInteger *self, jint bitLength, jint certainty, JavaUtilRandom *rnd);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withInt_withJavaUtilRandom_(jint bitLength, jint certainty, JavaUtilRandom *rnd) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withInt_withJavaUtilRandom_(jint bitLength, jint certainty, JavaUtilRandom *rnd);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithNSString_(JavaMathBigInteger *self, NSString *val);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithNSString_(NSString *val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithNSString_(NSString *val);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithNSString_withInt_(JavaMathBigInteger *self, NSString *val, jint radix);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithNSString_withInt_(NSString *val, jint radix) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithNSString_withInt_(NSString *val, jint radix);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withByteArray_(JavaMathBigInteger *self, jint signum, IOSByteArray *magnitude);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withByteArray_(jint signum, IOSByteArray *magnitude) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withByteArray_(jint signum, IOSByteArray *magnitude);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithByteArray_(JavaMathBigInteger *self, IOSByteArray *val);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithByteArray_(IOSByteArray *val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithByteArray_(IOSByteArray *val);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withInt_(JavaMathBigInteger *self, jint sign, jint value);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withInt_(jint sign, jint value) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withInt_(jint sign, jint value);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withInt_withIntArray_(JavaMathBigInteger *self, jint sign, jint numberLength, IOSIntArray *digits);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withInt_withIntArray_(jint sign, jint numberLength, IOSIntArray *digits) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withInt_withIntArray_(jint sign, jint numberLength, IOSIntArray *digits);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withLong_(JavaMathBigInteger *self, jint sign, jlong val);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withLong_(jint sign, jlong val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withLong_(jint sign, jlong val);

FOUNDATION_EXPORT void JavaMathBigInteger_initWithInt_withIntArray_(JavaMathBigInteger *self, jint signum, IOSIntArray *digits);

FOUNDATION_EXPORT JavaMathBigInteger *new_JavaMathBigInteger_initWithInt_withIntArray_(jint signum, IOSIntArray *digits) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigInteger *create_JavaMathBigInteger_initWithInt_withIntArray_(jint signum, IOSIntArray *digits);

FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_valueOfWithLong_(jlong val);

FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_probablePrimeWithInt_withJavaUtilRandom_(jint bitLength, JavaUtilRandom *rnd);

FOUNDATION_EXPORT JavaMathBigInteger *JavaMathBigInteger_getPowerOfTwoWithInt_(jint exp);

J2OBJC_TYPE_LITERAL_HEADER(JavaMathBigInteger)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaMathBigInteger")

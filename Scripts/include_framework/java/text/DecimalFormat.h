//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/text/DecimalFormat.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTextDecimalFormat")
#ifdef RESTRICT_JavaTextDecimalFormat
#define INCLUDE_ALL_JavaTextDecimalFormat 0
#else
#define INCLUDE_ALL_JavaTextDecimalFormat 1
#endif
#undef RESTRICT_JavaTextDecimalFormat

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaTextDecimalFormat_) && (INCLUDE_ALL_JavaTextDecimalFormat || defined(INCLUDE_JavaTextDecimalFormat))
#define JavaTextDecimalFormat_

#define RESTRICT_JavaTextNumberFormat 1
#define INCLUDE_JavaTextNumberFormat 1
#include "../../java/text/NumberFormat.h"

@class JavaLangStringBuffer;
@class JavaMathRoundingMode;
@class JavaTextDecimalFormatSymbols;
@class JavaTextFieldPosition;
@class JavaTextParsePosition;
@class JavaUtilCurrency;
@class JavaUtilLocale;
@protocol JavaTextAttributedCharacterIterator;

/*!
 @brief A concrete subclass of <code>NumberFormat</code> that formats decimal numbers.
 It
 has a variety of features designed to make it possible to parse and format
 numbers in any locale, including support for Western, Arabic, or Indic
 digits. It also supports different flavors of numbers, including integers
 ("123"), fixed-point numbers ("123.4"), scientific notation ("1.23E4"),
 percentages ("12%"), and currency amounts ("$123"). All of these flavors can
 be easily localized.
 <p>
 <strong>This is an enhanced version of <code>DecimalFormat</code> that is based on
 the standard version in the RI. New or changed functionality is labeled
 <strong><font color="red">NEW</font></strong>.</strong>
 <p>
 To obtain a <code>NumberFormat</code> for a specific locale (including the default
 locale), call one of <code>NumberFormat</code>'s factory methods such as
 <code>NumberFormat.getInstance</code>. Do not call the <code>DecimalFormat</code>
 constructors directly, unless you know what you are doing, since the
 <code>NumberFormat</code> factory methods may return subclasses other than
 <code>DecimalFormat</code>. If you need to customize the format object, do
 something like this: <blockquote>
 @code

  NumberFormat f = NumberFormat.getInstance(loc);
  if (f instanceof DecimalFormat) {
     ((DecimalFormat)f).setDecimalSeparatorAlwaysShown(true);
  }
  
@endcode
 </blockquote>
 <h4>Patterns</h4>
 <p>
 A <code>DecimalFormat</code> consists of a <em>pattern</em> and a set of
 <em>symbols</em>. The pattern may be set directly using
 <code>applyPattern(String)</code>, or indirectly using other API methods which
 manipulate aspects of the pattern, such as the minimum number of integer
 digits. The symbols are stored in a <code>DecimalFormatSymbols</code> object. When
 using the <code>NumberFormat</code> factory methods, the pattern and symbols are
 read from ICU's locale data.
 <h4>Special Pattern Characters</h4>
 <p>
 Many characters in a pattern are taken literally; they are matched during
 parsing and are written out unchanged during formatting. On the other hand,
 special characters stand for other characters, strings, or classes of
 characters. For example, the '#' character is replaced by a localized digit.
 Often the replacement character is the same as the pattern character; in the
 U.S. locale, the ',' grouping character is replaced by ','. However, the
 replacement is still happening, and if the symbols are modified, the grouping
 character changes. Some special characters affect the behavior of the
 formatter by their presence; for example, if the percent character is seen,
 then the value is multiplied by 100 before being displayed.
 <p>
 To insert a special character in a pattern as a literal, that is, without any
 special meaning, the character must be quoted. There are some exceptions to
 this which are noted below.
 <p>
 The characters listed here are used in non-localized patterns. Localized
 patterns use the corresponding characters taken from this formatter's
 <code>DecimalFormatSymbols</code> object instead, and these characters lose their
 special status. Two exceptions are the currency sign and quote, which are not
 localized.
 <blockquote> <table border="0" cellspacing="3" cellpadding="0" summary="Chart
 showing symbol, location, localized, and meaning.">
 <tr bgcolor="#ccccff">
 <th align="left">Symbol</th>
 <th align="left">Location</th>
 <th align="left">Localized?</th>
 <th align="left">Meaning</th>
 </tr>
 <tr valign="top">
 <td><code>0</code></td>
 <td>Number</td>
 <td>Yes</td>
 <td>Digit.</td>
 </tr>
 <tr valign="top">
 <td><code>@@</code></td>
 <td>Number</td>
 <td>No</td>
 <td><strong><font color="red">NEW</font>&nbsp;</strong> Significant
 digit.</td>
 </tr>
 <tr valign="top" bgcolor="#eeeeff">
 <td><code>#</code></td>
 <td>Number</td>
 <td>Yes</td>
 <td>Digit, leading zeroes are not shown.</td>
 </tr>
 <tr valign="top">
 <td><code>.</code></td>
 <td>Number</td>
 <td>Yes</td>
 <td>Decimal separator or monetary decimal separator.</td>
 </tr>
 <tr valign="top" bgcolor="#eeeeff">
 <td><code>-</code></td>
 <td>Number</td>
 <td>Yes</td>
 <td>Minus sign.</td>
 </tr>
 <tr valign="top">
 <td><code>,</code></td>
 <td>Number</td>
 <td>Yes</td>
 <td>Grouping separator.</td>
 </tr>
 <tr valign="top" bgcolor="#eeeeff">
 <td><code>E</code></td>
 <td>Number</td>
 <td>Yes</td>
 <td>Separates mantissa and exponent in scientific notation.
 <em>Does not need to be quoted in prefix or suffix.</em></td>
 </tr>
 <tr valign="top">
 <td><code>+</code></td>
 <td>Exponent</td>
 <td>Yes</td>
 <td><strong><font color="red">NEW</font>&nbsp;</strong> Prefix
 positive exponents with localized plus sign.
 <em>Does not need to be quoted in prefix or suffix.</em></td>
 </tr>
 <tr valign="top" bgcolor="#eeeeff">
 <td><code>;</code></td>
 <td>Subpattern boundary</td>
 <td>Yes</td>
 <td>Separates positive and negative subpatterns.</td>
 </tr>
 <tr valign="top">
 <td><code>%</code></td>
 <td>Prefix or suffix</td>
 <td>Yes</td>
 <td>Multiply by 100 and show as percentage.</td>
 </tr>
 <tr valign="top" bgcolor="#eeeeff">
 <td><code>\u2030</code> (<code>\u005Cu2030</code>)</td>
 <td>Prefix or suffix</td>
 <td>Yes</td>
 <td>Multiply by 1000 and show as per mille.</td>
 </tr>
 <tr valign="top">
 <td><code>\u00A4</code> (<code>\u005Cu00A4</code>)</td>
 <td>Prefix or suffix</td>
 <td>No</td>
 <td>Currency sign, replaced by currency symbol. If doubled, replaced by
 international currency symbol. If present in a pattern, the monetary decimal
 separator is used instead of the decimal separator.</td>
 </tr>
 <tr valign="top" bgcolor="#eeeeff">
 <td><code>'</code></td>
 <td>Prefix or suffix</td>
 <td>No</td>
 <td>Used to quote special characters in a prefix or suffix, for example,
 <code>"'#'#"</code> formats 123 to <code>"#123"</code>. To create a single quote
 itself, use two in a row: <code>"# o''clock"</code>.</td>
 </tr>
 <tr valign="top">
 <td><code>*</code></td>
 <td>Prefix or suffix boundary</td>
 <td>Yes</td>
 <td><strong><font color="red">NEW</font>&nbsp;</strong> Pad escape,
 precedes pad character. </td>
 </tr>
 </table> </blockquote>
 <p>
 A <code>DecimalFormat</code> pattern contains a positive and negative subpattern,
 for example, "#,##0.00;(#,##0.00)". Each subpattern has a prefix, a numeric
 part and a suffix. If there is no explicit negative subpattern, the negative
 subpattern is the localized minus sign prefixed to the positive subpattern.
 That is, "0.00" alone is equivalent to "0.00;-0.00". If there is an explicit
 negative subpattern, it serves only to specify the negative prefix and
 suffix; the number of digits, minimal digits, and other characteristics are
 ignored in the negative subpattern. This means that "#,##0.0#;(#)" produces
 precisely the same result as "#,##0.0#;(#,##0.0#)".
 <p>
 The prefixes, suffixes, and various symbols used for infinity, digits,
 thousands separators, decimal separators, etc. may be set to arbitrary
 values, and they will appear properly during formatting. However, care must
 be taken that the symbols and strings do not conflict, or parsing will be
 unreliable. For example, either the positive and negative prefixes or the
 suffixes must be distinct for <code>parse</code> to be able to distinguish
 positive from negative values. Another example is that the decimal separator
 and thousands separator should be distinct characters, or parsing will be
 impossible.
 <p>
 The <em>grouping separator</em> is a character that separates clusters of
 integer digits to make large numbers more legible. It is commonly used for
 thousands, but in some locales it separates ten-thousands. The <em>grouping
 size</em>
 is the number of digits between the grouping separators, such as 3 for
 "100,000,000" or 4 for "1 0000 0000". There are actually two different
 grouping sizes: One used for the least significant integer digits, the
 <em>primary grouping size</em>, and one used for all others, the
 <em>secondary grouping size</em>. In most locales these are the same, but
 sometimes they are different. For example, if the primary grouping interval
 is 3, and the secondary is 2, then this corresponds to the pattern
 "#,##,##0", and the number 123456789 is formatted as "12,34,56,789". If a
 pattern contains multiple grouping separators, the interval between the last
 one and the end of the integer defines the primary grouping size, and the
 interval between the last two defines the secondary grouping size. All others
 are ignored, so "#,##,###,####", "###,###,####" and "##,#,###,####" produce
 the same result.
 <p>
 Illegal patterns, such as "#.#.#" or "#.###,###", will cause
 <code>DecimalFormat</code> to throw an <code>IllegalArgumentException</code> with a
 message that describes the problem.
 <h4>Pattern BNF</h4>
 @code

  pattern    := subpattern (';' subpattern)?
  subpattern := prefix? number exponent? suffix?
  number     := (integer ('.' fraction)?) | sigDigits
  prefix     := '\\u0000'..'\\uFFFD' - specialCharacters
  suffix     := '\\u0000'..'\\uFFFD' - specialCharacters
  integer    := '#'* '0'* '0'
  fraction   := '0'* '#'
  sigDigits  := '#'* '@@' '@@'* '#'
  exponent   := 'E' '+'? '0'* '0'
  padSpec    := '*' padChar
  padChar    := '\\u0000'..'\\uFFFD' - quote
  Notation:
   X*       0 or more instances of X
   X?       0 or 1 instances of X
   X|Y      either X or Y
   C..D     any character from C up to D, inclusive
   S-T      characters in S, except those in T
  
@endcode
 The first subpattern is for positive numbers. The second (optional)
 subpattern is for negative numbers.
 <p>
 Not indicated in the BNF syntax above:
 <ul>
 <li>The grouping separator ',' can occur inside the integer and sigDigits
 elements, between any two pattern characters of that element, as long as the
 integer or sigDigits element is not followed by the exponent element.
 <li><font color="red"><strong>NEW</strong>&nbsp;</font> Two
 grouping intervals are recognized: The one between the decimal point and the
 first grouping symbol and the one between the first and second grouping
 symbols. These intervals are identical in most locales, but in some locales
 they differ. For example, the pattern &quot;#,##,###&quot; formats the number
 123456789 as &quot;12,34,56,789&quot;.</li>
 <li> <strong><font color="red">NEW</font>&nbsp;</strong> The pad
 specifier <code>padSpec</code> may appear before the prefix, after the prefix,
 before the suffix, after the suffix or not at all.
 </ul>
 <h4>Parsing</h4>
 <p>
 <code>DecimalFormat</code> parses all Unicode characters that represent decimal
 digits, as defined by <code>Character.digit(int,int)</code>. In addition,
 <code>DecimalFormat</code> also recognizes as digits the ten consecutive
 characters starting with the localized zero digit defined in the
 <code>DecimalFormatSymbols</code> object. During formatting, the
 <code>DecimalFormatSymbols</code>-based digits are written out.
 <p>
 During parsing, grouping separators are ignored.
 <p>
 If <code>parse(String,ParsePosition)</code> fails to parse a string, it returns
 <code>null</code> and leaves the parse position unchanged.
 <h4>Formatting</h4>
 <p>
 Formatting is guided by several parameters, all of which can be specified
 either using a pattern or using the API. The following description applies to
 formats that do not use <a href="#sci">scientific notation</a> or <a
 href="#sigdig">significant digits</a>.
 <ul>
 <li>If the number of actual integer digits exceeds the
 <em>maximum integer digits</em>, then only the least significant digits
 are shown. For example, 1997 is formatted as "97" if maximum integer digits
 is set to 2.
 <li>If the number of actual integer digits is less than the
 <em>minimum integer digits</em>, then leading zeros are added. For
 example, 1997 is formatted as "01997" if minimum integer digits is set to 5.
 <li>If the number of actual fraction digits exceeds the <em>maximum
 fraction digits</em>,
 then half-even rounding is performed to the maximum fraction digits. For
 example, 0.125 is formatted as "0.12" if the maximum fraction digits is 2.
 <li>If the number of actual fraction digits is less than the
 <em>minimum fraction digits</em>, then trailing zeros are added. For
 example, 0.125 is formatted as "0.1250" if the minimum fraction digits is set
 to 4.
 <li>Trailing fractional zeros are not displayed if they occur <em>j</em>
 positions after the decimal, where <em>j</em> is less than the maximum
 fraction digits. For example, 0.10004 is formatted as "0.1" if the maximum
 fraction digits is four or less.
 </ul>
 <p>
 <strong>Special Values</strong>
 <p>
 <code>NaN</code> is represented as a single character, typically
 <code>\u005cuFFFD</code>. This character is determined by the
 <code>DecimalFormatSymbols</code> object. This is the only value for which the
 prefixes and suffixes are not used.
 <p>
 Infinity is represented as a single character, typically <code>\u005cu221E</code>,
 with the positive or negative prefixes and suffixes applied. The infinity
 character is determined by the <code>DecimalFormatSymbols</code> object. <a
 name="sci">
 <h4>Scientific Notation</h4>
 </a>
 <p>
 Numbers in scientific notation are expressed as the product of a mantissa and
 a power of ten, for example, 1234 can be expressed as 1.234 x 10<sup>3</sup>.
 The mantissa is typically in the half-open interval [1.0, 10.0) or sometimes
 [0.0, 1.0), but it does not need to be. <code>DecimalFormat</code> supports
 arbitrary mantissas. <code>DecimalFormat</code> can be instructed to use
 scientific notation through the API or through the pattern. In a pattern, the
 exponent character immediately followed by one or more digit characters
 indicates scientific notation. Example: "0.###E0" formats the number 1234 as
 "1.234E3".
 <ul>
 <li>The number of digit characters after the exponent character gives the
 minimum exponent digit count. There is no maximum. Negative exponents are
 formatted using the localized minus sign, <em>not</em> the prefix and
 suffix from the pattern. This allows patterns such as "0.###E0 m/s". To
 prefix positive exponents with a localized plus sign, specify '+' between the
 exponent and the digits: "0.###E+0" will produce formats "1E+1", "1E+0",
 "1E-1", etc. (In localized patterns, use the localized plus sign rather than
 '+'.)
 <li>The minimum number of integer digits is achieved by adjusting the
 exponent. Example: 0.00123 formatted with "00.###E0" yields "12.3E-4". This
 only happens if there is no maximum number of integer digits. If there is a
 maximum, then the minimum number of integer digits is fixed at one.
 <li>The maximum number of integer digits, if present, specifies the exponent
 grouping. The most common use of this is to generate <em>engineering
 notation</em>,
 in which the exponent is a multiple of three, e.g., "##0.###E0". The number
 12345 is formatted using "##0.###E0" as "12.345E3".
 <li>When using scientific notation, the formatter controls the digit counts
 using significant digits logic. The maximum number of significant digits
 limits the total number of integer and fraction digits that will be shown in
 the mantissa; it does not affect parsing. For example, 12345 formatted with
 "##0.##E0" is "12.3E3". See the section on significant digits for more
 details.
 <li>The number of significant digits shown is determined as follows: If no
 significant digits are used in the pattern then the minimum number of
 significant digits shown is one, the maximum number of significant digits
 shown is the sum of the <em>minimum integer</em> and
 <em>maximum fraction</em> digits, and it is unaffected by the maximum
 integer digits. If this sum is zero, then all significant digits are shown.
 If significant digits are used in the pattern then the number of integer
 digits is fixed at one and there is no exponent grouping.
 <li>Exponential patterns may not contain grouping separators.
 </ul>
 <a name="sigdig">
 <h4> <strong><font color="red">NEW</font>&nbsp;</strong> Significant
 Digits</h4>
 <p>
 </a> <code>DecimalFormat</code> has two ways of controlling how many digits are
 shown: (a) significant digit counts or (b) integer and fraction digit counts.
 Integer and fraction digit counts are described above. When a formatter uses
 significant digits counts, the number of integer and fraction digits is not
 specified directly, and the formatter settings for these counts are ignored.
 Instead, the formatter uses as many integer and fraction digits as required
 to display the specified number of significant digits.
 <h5>Examples:</h5>
 <blockquote> <table border=0 cellspacing=3 cellpadding=0>
 <tr bgcolor="#ccccff">
 <th align="left">Pattern</th>
 <th align="left">Minimum significant digits</th>
 <th align="left">Maximum significant digits</th>
 <th align="left">Number</th>
 <th align="left">Output of format()</th>
 </tr>
 <tr valign="top">
 <td><code>@@@@@@</code>
 <td>3</td>
 <td>3</td>
 <td>12345</td>
 <td><code>12300</code></td>
 </tr>
 <tr valign="top" bgcolor="#eeeeff">
 <td><code>@@@@@@</code></td>
 <td>3</td>
 <td>3</td>
 <td>0.12345</td>
 <td><code>0.123</code></td>
 </tr>
 <tr valign="top">
 <td><code>@@@@##</code></td>
 <td>2</td>
 <td>4</td>
 <td>3.14159</td>
 <td><code>3.142</code></td>
 </tr>
 <tr valign="top" bgcolor="#eeeeff">
 <td><code>@@@@##</code></td>
 <td>2</td>
 <td>4</td>
 <td>1.23004</td>
 <td><code>1.23</code></td>
 </tr>
 </table> </blockquote>
 <ul>
 <li>Significant digit counts may be expressed using patterns that specify a
 minimum and maximum number of significant digits. These are indicated by the
 <code>'@@'</code> and <code>'#'</code> characters. The minimum number of significant
 digits is the number of <code>'@@'</code> characters. The maximum number of
 significant digits is the number of <code>'@@'</code> characters plus the number of
 <code>'#'</code> characters following on the right. For example, the pattern
 <code>"@@@@@@"</code> indicates exactly 3 significant digits. The pattern
 <code>"@@##"</code> indicates from 1 to 3 significant digits. Trailing zero digits
 to the right of the decimal separator are suppressed after the minimum number
 of significant digits have been shown. For example, the pattern <code>"@@##"</code>
 formats the number 0.1203 as <code>"0.12"</code>.
 <li>If a pattern uses significant digits, it may not contain a decimal
 separator, nor the <code>'0'</code> pattern character. Patterns such as
 <code>"@@00"</code> or <code>"@@.###"</code> are disallowed.
 <li>Any number of <code>'#'</code> characters may be prepended to the left of the
 leftmost <code>'@@'</code> character. These have no effect on the minimum and
 maximum significant digit counts, but may be used to position grouping
 separators. For example, <code>"#,#@@#"</code> indicates a minimum of one
 significant digit, a maximum of two significant digits, and a grouping size
 of three.
 <li>In order to enable significant digits formatting, use a pattern
 containing the <code>'@@'</code> pattern character.
 <li>In order to disable significant digits formatting, use a pattern that
 does not contain the <code>'@@'</code> pattern character.
 <li>The number of significant digits has no effect on parsing.
 <li>Significant digits may be used together with exponential notation. Such
 patterns are equivalent to a normal exponential pattern with a minimum and
 maximum integer digit count of one, a minimum fraction digit count of the
 number of '@@' characters in the pattern - 1, and a maximum fraction digit
 count of the number of '@@' and '#' characters in the pattern - 1. For
 example, the pattern <code>"@@@@###E0"</code> is equivalent to <code>"0.0###E0"</code>.
 <li>If significant digits are in use then the integer and fraction digit
 counts, as set via the API, are ignored.
 </ul>
 <h4> <strong><font color="red">NEW</font>&nbsp;</strong> Padding</h4>
 <p>
 <code>DecimalFormat</code> supports padding the result of <code>format</code> to a
 specific width. Padding may be specified either through the API or through
 the pattern syntax. In a pattern, the pad escape character followed by a
 single pad character causes padding to be parsed and formatted. The pad
 escape character is '*' in unlocalized patterns. For example,
 <code>"$*x#,##0.00"</code> formats 123 to <code>"$xx123.00"</code>, and 1234 to
 <code>"$1,234.00"</code>.
 <ul>
 <li>When padding is in effect, the width of the positive subpattern,
 including prefix and suffix, determines the format width. For example, in the
 pattern <code>"* #0 o''clock"</code>, the format width is 10.</li>
 <li>The width is counted in 16-bit code units (Java <code>char</code>s).</li>
 <li>Some parameters which usually do not matter have meaning when padding is
 used, because the pattern width is significant with padding. In the pattern "
 ##,##,#,##0.##", the format width is 14. The initial characters "##,##," do
 not affect the grouping size or maximum integer digits, but they do affect
 the format width.</li>
 <li>Padding may be inserted at one of four locations: before the prefix,
 after the prefix, before the suffix or after the suffix. If padding is
 specified in any other location, <code>applyPattern</code> throws an <code>IllegalArgumentException</code>
 . If there is no prefix, before the prefix and after
 the prefix are equivalent, likewise for the suffix.</li>
 <li>When specified in a pattern, the 16-bit <code>char</code> immediately
 following the pad escape is the pad character. This may be any character,
 including a special pattern character. That is, the pad escape
 <em>escapes</em> the following character. If there is no character after
 the pad escape, then the pattern is illegal.</li>
 </ul>
 <h4>Synchronization</h4>
 <p>
 <code>DecimalFormat</code> objects are not synchronized. Multiple threads should
 not access one formatter concurrently.
 - seealso: Format
 - seealso: NumberFormat
 */
@interface JavaTextDecimalFormat : JavaTextNumberFormat

#pragma mark Public

/*!
 @brief Constructs a new <code>DecimalFormat</code> for formatting and parsing numbers
 for the user's default locale.
 See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
 */
- (instancetype)init;

/*!
 @brief Constructs a new <code>DecimalFormat</code> using the specified non-localized
 pattern and the <code>DecimalFormatSymbols</code> for the user's default Locale.
 See "<a href="../util/Locale.html#default_locale">Be wary of the default locale</a>".
 @param pattern
 the non-localized pattern.
 @throws IllegalArgumentException
 if the pattern cannot be parsed.
 */
- (instancetype)initWithNSString:(NSString *)pattern;

/*!
 @brief Constructs a new <code>DecimalFormat</code> using the specified non-localized
 pattern and <code>DecimalFormatSymbols</code>.
 @param pattern
 the non-localized pattern.
 @param value
 the DecimalFormatSymbols.
 @throws IllegalArgumentException
 if the pattern cannot be parsed.
 */
- (instancetype)initWithNSString:(NSString *)pattern
withJavaTextDecimalFormatSymbols:(JavaTextDecimalFormatSymbols *)value;

/*!
 @brief Changes the pattern of this decimal format to the specified pattern which
 uses localized pattern characters.
 @param pattern
 the localized pattern.
 @throws IllegalArgumentException
 if the pattern cannot be parsed.
 */
- (void)applyLocalizedPatternWithNSString:(NSString *)pattern;

/*!
 @brief Changes the pattern of this decimal format to the specified pattern which
 uses non-localized pattern characters.
 @param pattern
 the non-localized pattern.
 @throws IllegalArgumentException
 if the pattern cannot be parsed.
 */
- (void)applyPatternWithNSString:(NSString *)pattern;

/*!
 @brief Returns a new instance of <code>DecimalFormat</code> with the same pattern and
 properties.
 */
- (id)clone;

/*!
 @brief Compares the specified object to this decimal format and indicates if
 they are equal.
 In order to be equal, <code>object</code> must be an instance
 of <code>DecimalFormat</code> with the same pattern and properties.
 @param object
 the object to compare with this object.
 @return <code>true</code> if the specified object is equal to this decimal
 format; <code>false</code> otherwise.
 - seealso: #hashCode
 */
- (jboolean)isEqual:(id)object;

- (JavaLangStringBuffer *)formatWithDouble:(jdouble)value
                  withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                 withJavaTextFieldPosition:(JavaTextFieldPosition *)position;

- (JavaLangStringBuffer *)formatWithLong:(jlong)value
                withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
               withJavaTextFieldPosition:(JavaTextFieldPosition *)position;

- (JavaLangStringBuffer *)formatWithId:(id)number
              withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
             withJavaTextFieldPosition:(JavaTextFieldPosition *)position;

/*!
 @brief Formats the specified object using the rules of this decimal format and
 returns an <code>AttributedCharacterIterator</code> with the formatted number
 and attributes.
 @param object
 the object to format.
 @return an AttributedCharacterIterator with the formatted number and
 attributes.
 @throws IllegalArgumentException
 if <code>object</code> cannot be formatted by this format.
 @throws NullPointerException
 if <code>object</code> is <code>null</code>.
 */
- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)object;

/*!
 @brief Returns the currency used by this decimal format.
 @return the currency used by this decimal format.
 - seealso: DecimalFormatSymbols#getCurrency()
 */
- (JavaUtilCurrency *)getCurrency;

/*!
 @brief Returns the <code>DecimalFormatSymbols</code> used by this decimal format.
 @return a copy of the <code>DecimalFormatSymbols</code> used by this decimal
 format.
 */
- (JavaTextDecimalFormatSymbols *)getDecimalFormatSymbols;

/*!
 @brief Returns the number of digits grouped together by the grouping separator.
 This only allows to get the primary grouping size. There is no API to get
 the secondary grouping size.
 @return the number of digits grouped together.
 */
- (jint)getGroupingSize;

/*!
 @brief Returns the multiplier which is applied to the number before formatting
 or after parsing.
 @return the multiplier.
 */
- (jint)getMultiplier;

/*!
 @brief Returns the prefix which is formatted or parsed before a negative number.
 @return the negative prefix.
 */
- (NSString *)getNegativePrefix;

/*!
 @brief Returns the suffix which is formatted or parsed after a negative number.
 @return the negative suffix.
 */
- (NSString *)getNegativeSuffix;

/*!
 @brief Returns the prefix which is formatted or parsed before a positive number.
 @return the positive prefix.
 */
- (NSString *)getPositivePrefix;

/*!
 @brief Returns the suffix which is formatted or parsed after a positive number.
 @return the positive suffix.
 */
- (NSString *)getPositiveSuffix;

/*!
 @brief Returns the <code>RoundingMode</code> used by this <code>NumberFormat</code>.
 @since 1.6
 */
- (JavaMathRoundingMode *)getRoundingMode;

- (NSUInteger)hash;

/*!
 @brief Indicates whether the decimal separator is shown when there are no
 fractional digits.
 @return <code>true</code> if the decimal separator should always be formatted;
 <code>false</code> otherwise.
 */
- (jboolean)isDecimalSeparatorAlwaysShown;

/*!
 @brief Indicates whether grouping will be used in this format.
 @return <code>true</code> if grouping is used; <code>false</code> otherwise.
 */
- (jboolean)isGroupingUsed;

/*!
 @brief This value indicates whether the return object of the parse operation is
 of type <code>BigDecimal</code>.
 This value defaults to <code>false</code>.
 @return <code>true</code> if parse always returns <code>BigDecimals</code>,
 <code>false</code> if the type of the result is <code>Long</code> or
 <code>Double</code>.
 */
- (jboolean)isParseBigDecimal;

/*!
 @brief Indicates whether parsing with this decimal format will only
 return numbers of type <code>java.lang.Integer</code>.
 @return <code>true</code> if this <code>DecimalFormat</code>'s parse method only
 returns <code>java.lang.Integer</code>; <code>false</code> otherwise.
 */
- (jboolean)isParseIntegerOnly;

/*!
 @brief Parses a <code>Long</code> or <code>Double</code> from the specified string
 starting at the index specified by <code>position</code>.
 If the string is
 successfully parsed then the index of the <code>ParsePosition</code> is
 updated to the index following the parsed text. On error, the index is
 unchanged and the error index of <code>ParsePosition</code> is set to the
 index where the error occurred.
 @param string
 the string to parse.
 @param position
 input/output parameter, specifies the start index in
 <code>string</code> from where to start parsing. If parsing is
 successful, it is updated with the index following the parsed
 text; on error, the index is unchanged and the error index is
 set to the index where the error occurred.
 @return a <code>Long</code> or <code>Double</code> resulting from the parse or
 <code>null</code> if there is an error. The result will be a
 <code>Long</code> if the parsed number is an integer in the range of a
 long, otherwise the result is a <code>Double</code>. If
 <code>isParseBigDecimal</code> is <code>true</code> then it returns the
 result as a <code>BigDecimal</code>.
 */
- (NSNumber *)parseWithNSString:(NSString *)string
      withJavaTextParsePosition:(JavaTextParsePosition *)position;

/*!
 @brief Sets the currency used by this decimal format.
 The min and max fraction
 digits remain the same.
 @param currency
 the currency this <code>DecimalFormat</code> should use.
 - seealso: DecimalFormatSymbols#setCurrency(Currency)
 */
- (void)setCurrencyWithJavaUtilCurrency:(JavaUtilCurrency *)currency;

/*!
 @brief Sets the <code>DecimalFormatSymbols</code> used by this decimal format.
 @param value
 the <code>DecimalFormatSymbols</code> to set.
 */
- (void)setDecimalFormatSymbolsWithJavaTextDecimalFormatSymbols:(JavaTextDecimalFormatSymbols *)value;

/*!
 @brief Sets whether the decimal separator is shown when there are no fractional
 digits.
 @param value
 <code>true</code> if the decimal separator should always be
 formatted; <code>false</code> otherwise.
 */
- (void)setDecimalSeparatorAlwaysShownWithBoolean:(jboolean)value;

/*!
 @brief Sets the number of digits grouped together by the grouping separator.
 This only allows to set the primary grouping size; the secondary grouping
 size can only be set with a pattern.
 @param value
 the number of digits grouped together.
 */
- (void)setGroupingSizeWithInt:(jint)value;

/*!
 @brief Sets whether or not grouping will be used in this format.
 Grouping
 affects both parsing and formatting.
 @param value
 <code>true</code> if grouping is used; <code>false</code> otherwise.
 */
- (void)setGroupingUsedWithBoolean:(jboolean)value;

/*!
 @brief Sets the maximum number of digits after the decimal point.
 If the value passed is negative then it is replaced by 0.
 Regardless of this setting, no more than 340 digits will be used.
 @param value the maximum number of fraction digits.
 */
- (void)setMaximumFractionDigitsWithInt:(jint)value;

/*!
 @brief Sets the maximum number of digits before the decimal point.
 If the value passed is negative then it is replaced by 0.
 Regardless of this setting, no more than 309 digits will be used.
 @param value the maximum number of integer digits.
 */
- (void)setMaximumIntegerDigitsWithInt:(jint)value;

/*!
 @brief Sets the minimum number of digits after the decimal point.
 If the value passed is negative then it is replaced by 0.
 Regardless of this setting, no more than 340 digits will be used.
 @param value the minimum number of fraction digits.
 */
- (void)setMinimumFractionDigitsWithInt:(jint)value;

/*!
 @brief Sets the minimum number of digits before the decimal point.
 If the value passed is negative then it is replaced by 0.
 Regardless of this setting, no more than 309 digits will be used.
 @param value the minimum number of integer digits.
 */
- (void)setMinimumIntegerDigitsWithInt:(jint)value;

/*!
 @brief Sets the multiplier which is applied to the number before formatting or
 after parsing.
 @param value
 the multiplier.
 */
- (void)setMultiplierWithInt:(jint)value;

/*!
 @brief Sets the prefix which is formatted or parsed before a negative number.
 @param value
 the negative prefix.
 */
- (void)setNegativePrefixWithNSString:(NSString *)value;

/*!
 @brief Sets the suffix which is formatted or parsed after a negative number.
 @param value
 the negative suffix.
 */
- (void)setNegativeSuffixWithNSString:(NSString *)value;

/*!
 @brief Sets the behavior of the parse method.
 If set to <code>true</code> then all
 the returned objects will be of type <code>BigDecimal</code>.
 @param newValue
 <code>true</code> if all the returned objects should be of type
 <code>BigDecimal</code>; <code>false</code> otherwise.
 */
- (void)setParseBigDecimalWithBoolean:(jboolean)newValue;

/*!
 @brief Sets the flag that indicates whether numbers will be parsed as integers.
 When this decimal format is used for parsing and this value is set to
 <code>true</code>, then the resulting numbers will be of type
 <code>java.lang.Integer</code>. Special cases are NaN, positive and negative
 infinity, which are still returned as <code>java.lang.Double</code>.
 @param value
 <code>true</code> that the resulting numbers of parse operations
 will be of type <code>java.lang.Integer</code> except for the
 special cases described above.
 */
- (void)setParseIntegerOnlyWithBoolean:(jboolean)value;

/*!
 @brief Sets the prefix which is formatted or parsed before a positive number.
 @param value
 the positive prefix.
 */
- (void)setPositivePrefixWithNSString:(NSString *)value;

/*!
 @brief Sets the suffix which is formatted or parsed after a positive number.
 @param value
 the positive suffix.
 */
- (void)setPositiveSuffixWithNSString:(NSString *)value;

/*!
 @brief Sets the <code>RoundingMode</code> used by this <code>NumberFormat</code>.
 @since 1.6
 */
- (void)setRoundingModeWithJavaMathRoundingMode:(JavaMathRoundingMode *)roundingMode;

/*!
 @brief Returns the pattern of this decimal format using localized pattern
 characters.
 @return the localized pattern.
 */
- (NSString *)toLocalizedPattern;

/*!
 @brief Returns the pattern of this decimal format using non-localized pattern
 characters.
 @return the non-localized pattern.
 */
- (NSString *)toPattern;

#pragma mark Package-Private

- (instancetype)initWithNSString:(NSString *)pattern
              withJavaUtilLocale:(JavaUtilLocale *)locale;

@end

J2OBJC_STATIC_INIT(JavaTextDecimalFormat)

FOUNDATION_EXPORT void JavaTextDecimalFormat_init(JavaTextDecimalFormat *self);

FOUNDATION_EXPORT JavaTextDecimalFormat *new_JavaTextDecimalFormat_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextDecimalFormat *create_JavaTextDecimalFormat_init();

FOUNDATION_EXPORT void JavaTextDecimalFormat_initWithNSString_(JavaTextDecimalFormat *self, NSString *pattern);

FOUNDATION_EXPORT JavaTextDecimalFormat *new_JavaTextDecimalFormat_initWithNSString_(NSString *pattern) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextDecimalFormat *create_JavaTextDecimalFormat_initWithNSString_(NSString *pattern);

FOUNDATION_EXPORT void JavaTextDecimalFormat_initWithNSString_withJavaTextDecimalFormatSymbols_(JavaTextDecimalFormat *self, NSString *pattern, JavaTextDecimalFormatSymbols *value);

FOUNDATION_EXPORT JavaTextDecimalFormat *new_JavaTextDecimalFormat_initWithNSString_withJavaTextDecimalFormatSymbols_(NSString *pattern, JavaTextDecimalFormatSymbols *value) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextDecimalFormat *create_JavaTextDecimalFormat_initWithNSString_withJavaTextDecimalFormatSymbols_(NSString *pattern, JavaTextDecimalFormatSymbols *value);

FOUNDATION_EXPORT void JavaTextDecimalFormat_initWithNSString_withJavaUtilLocale_(JavaTextDecimalFormat *self, NSString *pattern, JavaUtilLocale *locale);

FOUNDATION_EXPORT JavaTextDecimalFormat *new_JavaTextDecimalFormat_initWithNSString_withJavaUtilLocale_(NSString *pattern, JavaUtilLocale *locale) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextDecimalFormat *create_JavaTextDecimalFormat_initWithNSString_withJavaUtilLocale_(NSString *pattern, JavaUtilLocale *locale);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextDecimalFormat)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaTextDecimalFormat")

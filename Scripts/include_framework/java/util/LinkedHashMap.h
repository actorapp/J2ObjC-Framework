//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/objc/java/java/util/LinkedHashMap.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilLinkedHashMap")
#ifdef RESTRICT_JavaUtilLinkedHashMap
#define INCLUDE_ALL_JavaUtilLinkedHashMap 0
#else
#define INCLUDE_ALL_JavaUtilLinkedHashMap 1
#endif
#undef RESTRICT_JavaUtilLinkedHashMap

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilLinkedHashMap_) && (INCLUDE_ALL_JavaUtilLinkedHashMap || defined(INCLUDE_JavaUtilLinkedHashMap))
#define JavaUtilLinkedHashMap_

#define RESTRICT_JavaUtilHashMap 1
#define INCLUDE_JavaUtilHashMap 1
#include "../../java/util/HashMap.h"

#define RESTRICT_JavaUtilMap 1
#define INCLUDE_JavaUtilMap 1
#include "../../java/util/Map.h"

@class IOSObjectArray;
@protocol JavaUtilFunctionBiConsumer;
@protocol JavaUtilFunctionBiFunction;
@protocol JavaUtilIterator;
@protocol JavaUtilMap_Entry;

/*!
 @brief <p>Hash table and linked list implementation of the <tt>Map</tt> interface,
 with predictable iteration order.
 This implementation differs from
 <tt>HashMap</tt> in that it maintains a doubly-linked list running through
 all of its entries.  This linked list defines the iteration ordering,
 which is normally the order in which keys were inserted into the map
 (<i>insertion-order</i>).  Note that insertion order is not affected
 if a key is <i>re-inserted</i> into the map.  (A key <tt>k</tt> is
 reinserted into a map <tt>m</tt> if <tt>m.put(k, v)</tt> is invoked when
 <tt>m.containsKey(k)</tt> would return <tt>true</tt> immediately prior to
 the invocation.)
 <p>This implementation spares its clients from the unspecified, generally
 chaotic ordering provided by <code>HashMap</code> (and <code>Hashtable</code>),
 without incurring the increased cost associated with <code>TreeMap</code>.  It
 can be used to produce a copy of a map that has the same order as the
 original, regardless of the original map's implementation:
 @code

     void foo(Map m) {
         Map copy = new LinkedHashMap(m);
         ...
     }
  
@endcode
 This technique is particularly useful if a module takes a map on input,
 copies it, and later returns results whose order is determined by that of
 the copy.  (Clients generally appreciate having things returned in the same
 order they were presented.)
 <p>A special <code>constructor</code> is
 provided to create a linked hash map whose order of iteration is the order
 in which its entries were last accessed, from least-recently accessed to
 most-recently (<i>access-order</i>).  This kind of map is well-suited to
 building LRU caches.  Invoking the <code>put</code>, <code>putIfAbsent</code>,
 <code>get</code>, <code>getOrDefault</code>, <code>compute</code>, <code>computeIfAbsent</code>,
 <code>computeIfPresent</code>, or <code>merge</code> methods results
 in an access to the corresponding entry (assuming it exists after the
 invocation completes). The <code>replace</code> methods only result in an access
 of the entry if the value is replaced.  The <code>putAll</code> method generates one
 entry access for each mapping in the specified map, in the order that
 key-value mappings are provided by the specified map's entry set iterator.
 <i>No other methods generate entry accesses.</i>  In particular, operations
 on collection-views do <i>not</i> affect the order of iteration of the
 backing map. 
 <p>The <code>removeEldestEntry(Map.Entry)</code> method may be overridden to
 impose a policy for removing stale mappings automatically when new mappings
 are added to the map.
 <p>This class provides all of the optional <tt>Map</tt> operations, and
 permits null elements.  Like <tt>HashMap</tt>, it provides constant-time
 performance for the basic operations (<tt>add</tt>, <tt>contains</tt> and
 <tt>remove</tt>), assuming the hash function disperses elements
 properly among the buckets.  Performance is likely to be just slightly
 below that of <tt>HashMap</tt>, due to the added expense of maintaining the
 linked list, with one exception: Iteration over the collection-views
 of a <tt>LinkedHashMap</tt> requires time proportional to the <i>size</i>
 of the map, regardless of its capacity.  Iteration over a <tt>HashMap</tt>
 is likely to be more expensive, requiring time proportional to its
 <i>capacity</i>.
 <p>A linked hash map has two parameters that affect its performance:
 <i>initial capacity</i> and <i>load factor</i>.  They are defined precisely
 as for <tt>HashMap</tt>.  Note, however, that the penalty for choosing an
 excessively high value for initial capacity is less severe for this class
 than for <tt>HashMap</tt>, as iteration times for this class are unaffected
 by capacity.
 <p><strong>Note that this implementation is not synchronized.</strong>
 If multiple threads access a linked hash map concurrently, and at least
 one of the threads modifies the map structurally, it <em>must</em> be
 synchronized externally.  This is typically accomplished by
 synchronizing on some object that naturally encapsulates the map.
 If no such object exists, the map should be "wrapped" using the
 <code>Collections.synchronizedMap</code>
 method.  This is best done at creation time, to prevent accidental
 unsynchronized access to the map:
@code

   
@endcode
 A structural modification is any operation that adds or deletes one or more
 mappings or, in the case of access-ordered linked hash maps, affects
 iteration order.  In insertion-ordered linked hash maps, merely changing
 the value associated with a key that is already contained in the map is not
 a structural modification.  <strong>In access-ordered linked hash maps,
 merely querying the map with <tt>get</tt> is a structural
 modification.</strong>)
 <p>The iterators returned by the <tt>iterator</tt> method of the collections
 returned by all of this class's collection view methods are
 <em>fail-fast</em>: if the map is structurally modified at any time after
 the iterator is created, in any way except through the iterator's own
 <tt>remove</tt> method, the iterator will throw a <code>ConcurrentModificationException</code>
 .  Thus, in the face of concurrent
 modification, the iterator fails quickly and cleanly, rather than risking
 arbitrary, non-deterministic behavior at an undetermined time in the future.
 <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
 as it is, generally speaking, impossible to make any hard guarantees in the
 presence of unsynchronized concurrent modification.  Fail-fast iterators
 throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
 Therefore, it would be wrong to write a program that depended on this
 exception for its correctness:   <i>the fail-fast behavior of iterators
 should be used only to detect bugs.</i>
 <p>The spliterators returned by the spliterator method of the collections
 returned by all of this class's collection view methods are
 <em><a href="Spliterator.html#binding">late-binding</a></em>,
 <em>fail-fast</em>, and additionally report <code>Spliterator.ORDERED</code>.
 <p>This class is a member of the
 <a href="/../technotes/guides/collections/index.html">
 Java Collections Framework</a>.
 The spliterators returned by the spliterator method of the collections
 returned by all of this class's collection view methods are created from
 the iterators of the corresponding collections.
 @author Josh Bloch
 - seealso: Object#hashCode()
 - seealso: Collection
 - seealso: Map
 - seealso: HashMap
 - seealso: TreeMap
 - seealso: Hashtable
 @since 1.4
 */
@interface JavaUtilLinkedHashMap : JavaUtilHashMap < JavaUtilMap >

#pragma mark Public

/*!
 @brief Constructs an empty insertion-ordered <tt>LinkedHashMap</tt> instance
 with the default initial capacity (16) and load factor (0.75).
 */
- (instancetype)init;

/*!
 @brief Constructs an empty insertion-ordered <tt>LinkedHashMap</tt> instance
 with the specified initial capacity and a default load factor (0.75).
 @param initialCapacity the initial capacity
 @throws IllegalArgumentException if the initial capacity is negative
 */
- (instancetype)initWithInt:(jint)initialCapacity;

/*!
 @brief Constructs an empty insertion-ordered <tt>LinkedHashMap</tt> instance
 with the specified initial capacity and load factor.
 @param initialCapacity the initial capacity
 @param loadFactor      the load factor
 @throws IllegalArgumentException if the initial capacity is negative
 or the load factor is nonpositive
 */
- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor;

/*!
 @brief Constructs an empty <tt>LinkedHashMap</tt> instance with the
 specified initial capacity, load factor and ordering mode.
 @param initialCapacity the initial capacity
 @param loadFactor      the load factor
 @param accessOrder     the ordering mode - <tt>true</tt> for
 access-order, <tt>false</tt> for insertion-order
 @throws IllegalArgumentException if the initial capacity is negative
 or the load factor is nonpositive
 */
- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor
                withBoolean:(jboolean)accessOrder;

/*!
 @brief Constructs an insertion-ordered <tt>LinkedHashMap</tt> instance with
 the same mappings as the specified map.
 The <tt>LinkedHashMap</tt>
 instance is created with a default load factor (0.75) and an initial
 capacity sufficient to hold the mappings in the specified map.
 @param m the map whose mappings are to be placed in this map
 @throws NullPointerException if the specified map is null
 */
- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 @brief Removes all of the mappings from this map.
 The map will be empty after this call returns.
 */
- (void)clear;

/*!
 @brief Returns <tt>true</tt> if this map maps one or more keys to the
 specified value.
 @param value value whose presence in this map is to be tested
 @return <tt>true</tt> if this map maps one or more keys to the
 specified value
 */
- (jboolean)containsValueWithId:(id)value;

/*!
 @brief Returns the eldest entry in the map, or <code>null</code> if the map is empty.
 Android-added.
 */
- (id<JavaUtilMap_Entry>)eldest;

- (void)forEachWithJavaUtilFunctionBiConsumer:(id<JavaUtilFunctionBiConsumer>)action;

/*!
 @brief Returns the value to which the specified key is mapped,
 or <code>null</code> if this map contains no mapping for the key.
 <p>More formally, if this map contains a mapping from a key
 <code>k</code> to a value <code>v</code> such that <code>(key==null ? k==null :
 key.equals(k))</code>
 , then this method returns <code>v</code>; otherwise
 it returns <code>null</code>.  (There can be at most one such mapping.)
 <p>A return value of <code>null</code> does not <i>necessarily</i>
 indicate that the map contains no mapping for the key; it's also
 possible that the map explicitly maps the key to <code>null</code>.
 The <code>containsKey</code> operation may be used to
 distinguish these two cases.
 */
- (id)getWithId:(id)key;

- (void)replaceAllWithJavaUtilFunctionBiFunction:(id<JavaUtilFunctionBiFunction>)function;

#pragma mark Protected

- (jboolean)removeEldestEntryWithJavaUtilMap_Entry:(id<JavaUtilMap_Entry>)eldest;

#pragma mark Package-Private

/*!
 @brief This override alters behavior of superclass put method.
 It causes newly
 allocated entry to get inserted at the end of the linked list and
 removes the eldest entry if appropriate.
 */
- (void)addEntryWithInt:(jint)hash_
                 withId:(id)key
                 withId:(id)value
                withInt:(jint)bucketIndex;

/*!
 @brief This override differs from addEntry in that it doesn't resize the
 table or remove the eldest entry.
 */
- (void)createEntryWithInt:(jint)hash_
                    withId:(id)key
                    withId:(id)value
                   withInt:(jint)bucketIndex;

/*!
 @brief Called by superclass constructors and pseudoconstructors (clone,
 readObject) before any entries are inserted into the map.
 Initializes
 the chain.
 */
- (void)init__ OBJC_METHOD_FAMILY_NONE;

- (id<JavaUtilIterator>)newEntryIterator OBJC_METHOD_FAMILY_NONE;

- (id<JavaUtilIterator>)newKeyIterator OBJC_METHOD_FAMILY_NONE;

- (id<JavaUtilIterator>)newValueIterator OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Transfers all entries to new table array.
 This method is called
 by superclass resize.  It is overridden for performance, as it is
 faster to iterate using our linked list.
 */
- (void)transferWithJavaUtilHashMap_HashMapEntryArray:(IOSObjectArray *)newTable;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilLinkedHashMap)

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_initWithInt_withFloat_(JavaUtilLinkedHashMap *self, jint initialCapacity, jfloat loadFactor);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_initWithInt_withFloat_(jint initialCapacity, jfloat loadFactor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLinkedHashMap *create_JavaUtilLinkedHashMap_initWithInt_withFloat_(jint initialCapacity, jfloat loadFactor);

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_initWithInt_(JavaUtilLinkedHashMap *self, jint initialCapacity);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_initWithInt_(jint initialCapacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLinkedHashMap *create_JavaUtilLinkedHashMap_initWithInt_(jint initialCapacity);

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_init(JavaUtilLinkedHashMap *self);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLinkedHashMap *create_JavaUtilLinkedHashMap_init();

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_initWithJavaUtilMap_(JavaUtilLinkedHashMap *self, id<JavaUtilMap> m);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_initWithJavaUtilMap_(id<JavaUtilMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLinkedHashMap *create_JavaUtilLinkedHashMap_initWithJavaUtilMap_(id<JavaUtilMap> m);

FOUNDATION_EXPORT void JavaUtilLinkedHashMap_initWithInt_withFloat_withBoolean_(JavaUtilLinkedHashMap *self, jint initialCapacity, jfloat loadFactor, jboolean accessOrder);

FOUNDATION_EXPORT JavaUtilLinkedHashMap *new_JavaUtilLinkedHashMap_initWithInt_withFloat_withBoolean_(jint initialCapacity, jfloat loadFactor, jboolean accessOrder) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLinkedHashMap *create_JavaUtilLinkedHashMap_initWithInt_withFloat_withBoolean_(jint initialCapacity, jfloat loadFactor, jboolean accessOrder);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLinkedHashMap)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilLinkedHashMap")

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/ConcurrentModificationException.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentModificationException")
#ifdef RESTRICT_JavaUtilConcurrentModificationException
#define INCLUDE_ALL_JavaUtilConcurrentModificationException 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentModificationException 1
#endif
#undef RESTRICT_JavaUtilConcurrentModificationException

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilConcurrentModificationException_) && (INCLUDE_ALL_JavaUtilConcurrentModificationException || defined(INCLUDE_JavaUtilConcurrentModificationException))
#define JavaUtilConcurrentModificationException_

#define RESTRICT_JavaLangRuntimeException 1
#define INCLUDE_JavaLangRuntimeException 1
#include "../../java/lang/RuntimeException.h"

/*!
 @brief This exception may be thrown by methods that have detected concurrent
 modification of an object when such modification is not permissible.
 <p>
 For example, it is not generally permissible for one thread to modify a Collection
 while another thread is iterating over it.  In general, the results of the
 iteration are undefined under these circumstances.  Some Iterator
 implementations (including those of all the general purpose collection implementations
 provided by the JRE) may choose to throw this exception if this behavior is
 detected.  Iterators that do this are known as <i>fail-fast</i> iterators,
 as they fail quickly and cleanly, rather that risking arbitrary,
 non-deterministic behavior at an undetermined time in the future.
 <p>
 Note that this exception does not always indicate that an object has
 been concurrently modified by a <i>different</i> thread.  If a single
 thread issues a sequence of method invocations that violates the
 contract of an object, the object may throw this exception.  For
 example, if a thread modifies a collection directly while it is
 iterating over the collection with a fail-fast iterator, the iterator
 will throw this exception.
 <p>Note that fail-fast behavior cannot be guaranteed as it is, generally
 speaking, impossible to make any hard guarantees in the presence of
 unsynchronized concurrent modification.  Fail-fast operations
 throw <code>ConcurrentModificationException</code> on a best-effort basis.
 Therefore, it would be wrong to write a program that depended on this
 exception for its correctness: <i><code>ConcurrentModificationException</code>
 should be used only to detect bugs.</i>
 @author Josh Bloch
 - seealso: Collection
 - seealso: Iterator
 - seealso: Spliterator
 - seealso: ListIterator
 - seealso: Vector
 - seealso: LinkedList
 - seealso: HashSet
 - seealso: Hashtable
 - seealso: TreeMap
 - seealso: AbstractList
 @since 1.2
 */
@interface JavaUtilConcurrentModificationException : JavaLangRuntimeException

#pragma mark Public

/*!
 @brief Constructs a ConcurrentModificationException with no
 detail message.
 */
- (instancetype)init;

/*!
 @brief Constructs a <code>ConcurrentModificationException</code> with the
 specified detail message.
 @param message the detail message pertaining to this exception.
 */
- (instancetype)initWithNSString:(NSString *)message;

/*!
 @brief Constructs a new exception with the specified detail message and
 cause.
 <p>Note that the detail message associated with <code>cause</code> is
 <i>not</i> automatically incorporated in this exception's detail
 message.
 @param message the detail message (which is saved for later retrieval
 by the <code>Throwable.getMessage()</code> method).
 @param cause the cause (which is saved for later retrieval by the
 <code>Throwable.getCause()</code> method).  (A <code>null</code> value
 is permitted, and indicates that the cause is nonexistent or
 unknown.)
 @since 1.7
 */
- (instancetype)initWithNSString:(NSString *)message
                 withNSException:(NSException *)cause;

/*!
 @brief Constructs a new exception with the specified cause and a detail
 message of <code>(cause==null ?
 null : cause.toString())</code> (which
 typically contains the class and detail message of <code>cause</code>.
 @param cause the cause (which is saved for later retrieval by the
 <code>Throwable.getCause()</code> method).  (A <code>null</code> value is
 permitted, and indicates that the cause is nonexistent or
 unknown.)
 @since 1.7
 */
- (instancetype)initWithNSException:(NSException *)cause;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentModificationException)

FOUNDATION_EXPORT void JavaUtilConcurrentModificationException_init(JavaUtilConcurrentModificationException *self);

FOUNDATION_EXPORT JavaUtilConcurrentModificationException *new_JavaUtilConcurrentModificationException_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentModificationException *create_JavaUtilConcurrentModificationException_init();

FOUNDATION_EXPORT void JavaUtilConcurrentModificationException_initWithNSString_(JavaUtilConcurrentModificationException *self, NSString *message);

FOUNDATION_EXPORT JavaUtilConcurrentModificationException *new_JavaUtilConcurrentModificationException_initWithNSString_(NSString *message) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentModificationException *create_JavaUtilConcurrentModificationException_initWithNSString_(NSString *message);

FOUNDATION_EXPORT void JavaUtilConcurrentModificationException_initWithNSException_(JavaUtilConcurrentModificationException *self, NSException *cause);

FOUNDATION_EXPORT JavaUtilConcurrentModificationException *new_JavaUtilConcurrentModificationException_initWithNSException_(NSException *cause) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentModificationException *create_JavaUtilConcurrentModificationException_initWithNSException_(NSException *cause);

FOUNDATION_EXPORT void JavaUtilConcurrentModificationException_initWithNSString_withNSException_(JavaUtilConcurrentModificationException *self, NSString *message, NSException *cause);

FOUNDATION_EXPORT JavaUtilConcurrentModificationException *new_JavaUtilConcurrentModificationException_initWithNSString_withNSException_(NSString *message, NSException *cause) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentModificationException *create_JavaUtilConcurrentModificationException_initWithNSString_withNSException_(NSString *message, NSException *cause);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentModificationException)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentModificationException")

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/org/apache/harmony/security/asn1/ASN1Choice.java
//

#ifndef _OrgApacheHarmonySecurityAsn1ASN1Choice_H_
#define _OrgApacheHarmonySecurityAsn1ASN1Choice_H_

#include "../../../../../J2ObjC_header.h"
#include "../../../../../org/apache/harmony/security/asn1/ASN1Type.h"

@class IOSObjectArray;
@class OrgApacheHarmonySecurityAsn1BerInputStream;
@class OrgApacheHarmonySecurityAsn1BerOutputStream;

/*!
 @author Vladimir N. Molotkov, Stepan M. Mishura
 @version $Revision$
 */

/*!
 @brief This abstract class represents ASN.1 Choice type.
 To implement custom ASN.1 choice type an application class
 must provide implementation for the following methods:
 getIndex()
 getObjectToEncode()
 There are two ways to implement custom ASN.1 choice type:
 with application class that represents ASN.1 custom choice type or without.
 The key point is how a value of choice type is stored by application classes.
 For example, let's consider the following ASN.1 notations
 (see http://www.ietf.org/rfc/rfc3280.txt)
 Time ::= CHOICE {
 utcTime        UTCTime,
 generalTime    GeneralizedTime
 }
 Validity ::= SEQUENCE {
 notBefore      Time,
 notAfter       Time
 }
 1)First approach:
 No application class to represent ASN.1 Time notation
 The Time notation is a choice of different time formats: UTC and Generalized.
 Both of them are mapped to java.util.Date object, so an application
 class that represents ASN.1 Validity notation may keep values
 as Date objects.
 So a custom ASN.1 Time choice type should map its notation to Date object.
 class Time {
 // custom ASN.1 choice class: maps Time to is notation
 public static final ASN1Choice asn1 = new ASN1Choice(new ASN1Type[] {
 ASN1GeneralizedTime.asn1, ASN1UTCTime.asn1 }) {
 public int getIndex(java.lang.Object object) {
 return 0; // always encode as ASN1GeneralizedTime
 }
 public Object getObjectToEncode(Object object) {
 // A value to be encoded value is a Date object
 // pass it to custom time class
 return object;
 }
 };
 }
 class Validity {
 private Date notBefore;    // choice as Date
 private Date notAfter;     // choice as Date
 ... // constructors and other methods go here
 // custom ASN.1 sequence class: maps Validity class to is notation
 public static final ASN1Sequence ASN1
 = new ASN1Sequence(new ASN1Type[] {Time.asn1, Time.asn1 }) {
 protected Object getObject(Object[] values) {
 // ASN.1 Time choice passed Data object - use it
 return new Validity((Date) values[0], (Date) values[1]);
 }
 protected void getValues(Object object, Object[] values) {
 Validity validity = (Validity) object;
 // pass Date objects to ASN.1 Time choice
 values[0] = validity.notBefore;
 values[1] = validity.notAfter;
 }
 }
 }
 2)Second approach:
 There is an application class to represent ASN.1 Time notation
 If it is a matter what time format should be used to decode/encode
 Date objects a class to represent ASN.1 Time notation must be created.
 For example,
 class Time {
 private Date utcTime;
 private Date gTime;
 ... // constructors and other methods go here
 // custom ASN.1 choice class: maps Time to is notation
 public static final ASN1Choice asn1 = new ASN1Choice(new ASN1Type[] {
 ASN1GeneralizedTime.asn1, ASN1UTCTime.asn1 }) {
 public Object getDecodedObject(BerInputStream in) {
 // create Time object to pass as decoded value
 Time time = new Time();
 if (in.choiceIndex==0) {
 // we decoded GeneralizedTime
 // store decoded Date value in corresponding field
 time.gTime = in.content;
 // return it
 return time;
 } else {
 // we decoded UTCTime
 // store decoded Date value in corresponding field
 time.utcTime = in.content;
 // return it
 return time;
 }
 }
 public int getIndex(java.lang.Object object) {
 Time time = (Time)object;
 if(time.utcTime!=null){
 // encode Date as UTCTime
 return 1;
 } else {
 // otherwise encode Date as GeneralizedTime
 return 0;
 }
 }
 public Object getObjectToEncode(Object object) {
 Time time = (Time)object;
 if(time.utcTime!=null){
 // encode Date as UTCTime
 return 1;
 } else {
 // otherwise encode Date as GeneralizedTime
 return 0;
 }
 }
 };
 }
 So now Validity class must keep all values in Time object
 and its custom ASN.1 sequence class must handle this class of objects
 class Validity {
 private Time notBefore;    // now it is a Time!!!
 private Time notAfter;     // now it is a Time!!!
 ... // constructors and other methods go here
 // custom ASN.1 sequence class: maps Validity class to is notation
 public static final ASN1Sequence ASN1
 = new ASN1Sequence(new ASN1Type[] {Time.asn1, Time.asn1 }) {
 protected Object getObject(Object[] values) {
 // We've gotten Time objects here !!!
 return new Validity((Time) values[0], (Time) values[1]);
 }
 protected void getValues(Object object, Object[] values) {
 Validity validity = (Validity) object;
 // pass Time objects to ASN.1 Time choice
 values[0] = validity.notBefore;
 values[1] = validity.notAfter;
 }
 }
 }
 */
@interface OrgApacheHarmonySecurityAsn1ASN1Choice : OrgApacheHarmonySecurityAsn1ASN1Type {
 @public
  IOSObjectArray *type_;
}

#pragma mark Public

/*!
 @brief Constructs ASN.1 choice type.
 @param type -
 an array of one or more ASN.1 type alternatives.
 @throws IllegalArgumentException -
 type parameter is invalid
 */
- (instancetype)initWithOrgApacheHarmonySecurityAsn1ASN1TypeArray:(IOSObjectArray *)type;

/*!
 @brief Tests whether one of choice alternatives has the same identifier or not.
 @param identifier -
 ASN.1 identifier to be verified
 @return - true if one of choice alternatives has the same identifier,
 otherwise false;
 */
- (jboolean)checkTagWithInt:(jint)identifier;

- (id)decodeWithOrgApacheHarmonySecurityAsn1BerInputStream:(OrgApacheHarmonySecurityAsn1BerInputStream *)inArg;

- (void)encodeASNWithOrgApacheHarmonySecurityAsn1BerOutputStream:(OrgApacheHarmonySecurityAsn1BerOutputStream *)outArg;

- (void)encodeContentWithOrgApacheHarmonySecurityAsn1BerOutputStream:(OrgApacheHarmonySecurityAsn1BerOutputStream *)outArg;

- (jint)getIndexWithId:(id)object;

- (id)getObjectToEncodeWithId:(id)object;

- (void)setEncodingContentWithOrgApacheHarmonySecurityAsn1BerOutputStream:(OrgApacheHarmonySecurityAsn1BerOutputStream *)outArg;

@end

J2OBJC_EMPTY_STATIC_INIT(OrgApacheHarmonySecurityAsn1ASN1Choice)

J2OBJC_FIELD_SETTER(OrgApacheHarmonySecurityAsn1ASN1Choice, type_, IOSObjectArray *)

FOUNDATION_EXPORT void OrgApacheHarmonySecurityAsn1ASN1Choice_initWithOrgApacheHarmonySecurityAsn1ASN1TypeArray_(OrgApacheHarmonySecurityAsn1ASN1Choice *self, IOSObjectArray *type);

J2OBJC_TYPE_LITERAL_HEADER(OrgApacheHarmonySecurityAsn1ASN1Choice)

#endif // _OrgApacheHarmonySecurityAsn1ASN1Choice_H_

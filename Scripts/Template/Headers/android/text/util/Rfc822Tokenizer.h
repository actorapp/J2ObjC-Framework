//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/frameworks/base/core/java/android/text/util/Rfc822Tokenizer.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("AndroidTextUtilRfc822Tokenizer_INCLUDE_ALL")
#ifdef AndroidTextUtilRfc822Tokenizer_RESTRICT
#define AndroidTextUtilRfc822Tokenizer_INCLUDE_ALL 0
#else
#define AndroidTextUtilRfc822Tokenizer_INCLUDE_ALL 1
#endif
#undef AndroidTextUtilRfc822Tokenizer_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (AndroidTextUtilRfc822Tokenizer_) && (AndroidTextUtilRfc822Tokenizer_INCLUDE_ALL || defined(AndroidTextUtilRfc822Tokenizer_INCLUDE))
#define AndroidTextUtilRfc822Tokenizer_

@class IOSObjectArray;
@protocol JavaLangCharSequence;
@protocol JavaUtilCollection;

/*!
 @brief This class works as a Tokenizer for MultiAutoCompleteTextView for
 address list fields, and also provides a method for converting
 a string of addresses (such as might be typed into such a field)
 into a series of Rfc822Tokens.
 */
@interface AndroidTextUtilRfc822Tokenizer : NSObject

#pragma mark Public

- (instancetype)init;

/*!
 
 */
- (jint)findTokenEndWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                     withInt:(jint)cursor;

/*!
 
 */
- (jint)findTokenStartWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                                       withInt:(jint)cursor;

/*!
 @brief Terminates the specified address with a comma and space.
 This assumes that the specified text already has valid syntax.
 The Adapter subclass's convertToString() method must make that
 guarantee.
 */
- (id<JavaLangCharSequence>)terminateTokenWithJavaLangCharSequence:(id<JavaLangCharSequence>)text;

/*!
 @brief This method will try to take a string like
 "Foo Bar (something) &lt;foo\@@google.com&gt;,
 blah\@@google.com (something)"
 and convert it into one or more Rfc822Tokens.
 It does *not* decode MIME encoded-words; charset conversion
 must already have taken place if necessary.
 It will try to be tolerant of broken syntax instead of
 returning an error.
 */
+ (IOSObjectArray *)tokenizeWithJavaLangCharSequence:(id<JavaLangCharSequence>)text;

/*!
 @brief This constructor will try to take a string like
 "Foo Bar (something) &lt;foo\@@google.com&gt;,
 blah\@@google.com (something)"
 and convert it into one or more Rfc822Tokens, output into the supplied
 collection.
 It does *not* decode MIME encoded-words; charset conversion
 must already have taken place if necessary.
 It will try to be tolerant of broken syntax instead of
 returning an error.
 */
+ (void)tokenizeWithJavaLangCharSequence:(id<JavaLangCharSequence>)text
                  withJavaUtilCollection:(id<JavaUtilCollection>)outArg;

@end

J2OBJC_EMPTY_STATIC_INIT(AndroidTextUtilRfc822Tokenizer)

FOUNDATION_EXPORT void AndroidTextUtilRfc822Tokenizer_tokenizeWithJavaLangCharSequence_withJavaUtilCollection_(id<JavaLangCharSequence> text, id<JavaUtilCollection> outArg);

FOUNDATION_EXPORT IOSObjectArray *AndroidTextUtilRfc822Tokenizer_tokenizeWithJavaLangCharSequence_(id<JavaLangCharSequence> text);

FOUNDATION_EXPORT void AndroidTextUtilRfc822Tokenizer_init(AndroidTextUtilRfc822Tokenizer *self);

FOUNDATION_EXPORT AndroidTextUtilRfc822Tokenizer *new_AndroidTextUtilRfc822Tokenizer_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(AndroidTextUtilRfc822Tokenizer)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("AndroidTextUtilRfc822Tokenizer_INCLUDE_ALL")

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Users/tball/tmp/j2objc/inject/javax_inject/build_result/java/javax/inject/Scope.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaxInjectScope_INCLUDE_ALL")
#ifdef JavaxInjectScope_RESTRICT
#define JavaxInjectScope_INCLUDE_ALL 0
#else
#define JavaxInjectScope_INCLUDE_ALL 1
#endif
#undef JavaxInjectScope_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaxInjectScope_) && (JavaxInjectScope_INCLUDE_ALL || defined(JavaxInjectScope_INCLUDE))
#define JavaxInjectScope_

#define JavaLangAnnotationAnnotation_RESTRICT 1
#define JavaLangAnnotationAnnotation_INCLUDE 1
#include "../../java/lang/annotation/Annotation.h"

/*!
 @brief Identifies scope annotations.
 A scope annotation applies to a class
 containing an injectable constructor and governs how the injector reuses
 instances of the type. By default, if no scope annotation is present, the
 injector creates an instance (by injecting the type's constructor), uses
 the instance for one injection, and then forgets it. If a scope annotation
 is present, the injector may retain the instance for possible reuse in a
 later injection. If multiple threads can access a scoped instance, its
 implementation should be thread safe. The implementation of the scope
 itself is left up to the injector.
 <p>In the following example, the scope annotation <code>@@Singleton</code> ensures
 that we only have one Log instance:
 @code

   &#064;Singleton
   class Log {
     void log(String message) { ... }
   
@endcode
 <p>The injector generates an error if it encounters more than one scope
 annotation on the same class or a scope annotation it doesn't support.
 <p>A scope annotation:
 <ul>
 <li>is annotated with <code>@@Scope</code>, <code>@@Retention(RUNTIME)</code>,
 and typically <code>@@Documented</code>.</li>
 <li>should not have attributes.</li>
 <li>is typically not <code>@@Inherited</code>, so scoping is orthogonal to
 implementation inheritance.</li>
 <li>may have restricted usage if annotated with <code>@@Target</code>. While
 this specification covers applying scopes to classes only, some 
 injector configurations might use scope annotations
 in other places (on factory method results for example).</li>
 </ul>
 <p>For example:
 @code

   &#064;java.lang.annotation.Documented
   &#064;java.lang.annotation.Retention(RUNTIME)
   &#064;javax.inject.Scope
   
@endcode
 <p>Annotating scope annotations with <code>@@Scope</code> helps the injector
 detect the case where a programmer used the scope annotation on a class but
 forgot to configure the scope in the injector. A conservative injector
 would generate an error rather than not apply a scope.
 - seealso: javax.inject.Singleton @@Singleton
 */
@protocol JavaxInjectScope < JavaLangAnnotationAnnotation >

@end

@interface JavaxInjectScope : NSObject < JavaxInjectScope >

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxInjectScope)

J2OBJC_TYPE_LITERAL_HEADER(JavaxInjectScope)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaxInjectScope_INCLUDE_ALL")

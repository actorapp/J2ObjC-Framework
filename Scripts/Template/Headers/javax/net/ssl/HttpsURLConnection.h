//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/javax/net/ssl/HttpsURLConnection.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaxNetSslHttpsURLConnection_INCLUDE_ALL")
#ifdef JavaxNetSslHttpsURLConnection_RESTRICT
#define JavaxNetSslHttpsURLConnection_INCLUDE_ALL 0
#else
#define JavaxNetSslHttpsURLConnection_INCLUDE_ALL 1
#endif
#undef JavaxNetSslHttpsURLConnection_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaxNetSslHttpsURLConnection_) && (JavaxNetSslHttpsURLConnection_INCLUDE_ALL || defined(JavaxNetSslHttpsURLConnection_INCLUDE))
#define JavaxNetSslHttpsURLConnection_

#define JavaNetHttpURLConnection_RESTRICT 1
#define JavaNetHttpURLConnection_INCLUDE 1
#include "../../../java/net/HttpURLConnection.h"

@class IOSObjectArray;
@class JavaNetURL;
@class JavaxNetSslSSLSocketFactory;
@protocol JavaSecurityPrincipal;
@protocol JavaxNetSslHostnameVerifier;

/*!
 @brief An <code>HttpURLConnection</code> for HTTPS (<a
 href="http://tools.ietf.org/html/rfc2818">RFC 2818</a>).
 A
 connected <code>HttpsURLConnection</code> allows access to the
 negotiated cipher suite, the server certificate chain, and the
 client certificate chain if any.
 <h3>Providing an application specific X509TrustManager</h3>
 If an application wants to trust Certificate Authority (CA)
 certificates that are not part of the system, it should specify its
 own <code>X509TrustManager</code> via a <code>SSLSocketFactory</code> set on
 the <code>HttpsURLConnection</code>. The <code>X509TrustManager</code> can be
 created based on a <code>KeyStore</code> using a <code>TrustManagerFactory</code>
  to supply trusted CA certificates. Note that
 self-signed certificates are effectively their own CA and can be
 trusted by including them in a <code>KeyStore</code>.
 <p>For example, to trust a set of certificates specified by a <code>KeyStore</code>:
 @code
     KeyStore keyStore = ...;
   String algorithm = TrustManagerFactory.getDefaultAlgorithm();
   TrustManagerFactory tmf = TrustManagerFactory.getInstance(algorithm);
   tmf.init(keyStore);
   SSLContext context = SSLContext.getInstance("TLS");
   context.init(null, tmf.getTrustManagers(), null);
   URL url = new URL("https://www.example.com/");
   HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
   urlConnection.setSSLSocketFactory(context.getSocketFactory());
   InputStream in = urlConnection.getInputStream();
 
@endcode
 <p>It is possible to implement <code>X509TrustManager</code> directly
 instead of using one created by a <code>TrustManagerFactory</code>
 . While this is straightforward in the insecure
 case of allowing all certificate chains to pass verification,
 writing a proper implementation will usually want to take advantage
 of <code>CertPathValidator</code>
 . In general, it might be better to write a
 custom <code>KeyStore</code> implementation to pass to the <code>TrustManagerFactory</code>
  than to try and write a custom <code>X509TrustManager</code>
 .
 <h3>Providing an application specific X509KeyManager</h3>
 A custom <code>X509KeyManager</code> can be used to supply a client
 certificate and its associated private key to authenticate a
 connection to the server. The <code>X509KeyManager</code> can be created
 based on a <code>KeyStore</code> using a <code>KeyManagerFactory</code>.
 <p>For example, to supply client certificates from a <code>KeyStore</code>:
 @code
     KeyStore keyStore = ...;
   String algorithm = KeyManagerFactory.getDefaultAlgorithm();
   KeyManagerFactory kmf = KeyManagerFactory.getInstance(algorithm);
   kmf.init(keyStore);
   SSLContext context = SSLContext.getInstance("TLS");
   context.init(kmf.getKeyManagers(), null, null);
   URL url = new URL("https://www.example.com/");
   HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
   urlConnection.setSSLSocketFactory(context.getSocketFactory());
   InputStream in = urlConnection.getInputStream();
 
@endcode
 <p>A <code>X509KeyManager</code> can also be implemented directly. This
 can allow an application to return a certificate and private key
 from a non-<code>KeyStore</code> source or to specify its own logic for
 selecting a specific credential to use when many may be present in
 a single <code>KeyStore</code>.
 <h3>TLS Intolerance Support</h3>
 This class attempts to create secure connections using common TLS
 extensions and SSL deflate compression. Should that fail, the
 connection will be retried with SSLv3 only.
 */
@interface JavaxNetSslHttpsURLConnection : JavaNetHttpURLConnection {
 @public
  /*!
   @brief The host name verifier used by this connection.
   It is initialized from
 the default hostname verifier
 <code>setDefaultHostnameVerifier(HostnameVerifier)</code> or
 <code>getDefaultHostnameVerifier()</code>.
   */
  id<JavaxNetSslHostnameVerifier> hostnameVerifier_;
}

#pragma mark Public

/*!
 @brief Returns the name of the cipher suite negotiated during the SSL handshake.
 @return the name of the cipher suite negotiated during the SSL handshake.
 @throws IllegalStateException
 if no connection has been established yet.
 */
- (NSString *)getCipherSuite;

/*!
 @brief Returns the default hostname verifier.
 @return the default hostname verifier.
 */
+ (id<JavaxNetSslHostnameVerifier>)getDefaultHostnameVerifier;

/*!
 @brief Returns the default SSL socket factory for new instances.
 @return the default SSL socket factory for new instances.
 */
+ (JavaxNetSslSSLSocketFactory *)getDefaultSSLSocketFactory;

/*!
 @brief Returns the hostname verifier used by this instance.
 @return the hostname verifier used by this instance.
 */
- (id<JavaxNetSslHostnameVerifier>)getHostnameVerifier;

/*!
 @brief Returns the list of local certificates used during the handshake.
 These
 certificates were sent to the peer.
 @return Returns the list of certificates used during the handshake with
 the local identity certificate followed by CAs, or <code>null</code>
 if no certificates were used during the handshake.
 @throws IllegalStateException
 if no connection has been established yet.
 */
- (IOSObjectArray *)getLocalCertificates;

/*!
 @brief Returns the <code>Principal</code> used to identify the local host during the handshake.
 @return the <code>Principal</code> used to identify the local host during the handshake, or
 <code>null</code> if none was used.
 @throws IllegalStateException
 if no connection has been established yet.
 */
- (id<JavaSecurityPrincipal>)getLocalPrincipal;

/*!
 @brief Returns the <code>Principal</code> identifying the peer.
 @return the <code>Principal</code> identifying the peer.
 @throws SSLPeerUnverifiedException
 if the identity of the peer has not been verified.
 @throws IllegalStateException
 if no connection has been established yet.
 */
- (id<JavaSecurityPrincipal>)getPeerPrincipal;

/*!
 @brief Return the list of certificates identifying the peer during the
 handshake.
 @return the list of certificates identifying the peer with the peer's
 identity certificate followed by CAs.
 @throws SSLPeerUnverifiedException
 if the identity of the peer has not been verified..
 @throws IllegalStateException
 if no connection has been established yet.
 */
- (IOSObjectArray *)getServerCertificates;

/*!
 @brief Returns the SSL socket factory used by this instance.
 @return the SSL socket factory used by this instance.
 */
- (JavaxNetSslSSLSocketFactory *)getSSLSocketFactory;

/*!
 @brief Sets the default hostname verifier to be used by new instances.
 @param v
 the new default hostname verifier
 @throws IllegalArgumentException
 if the specified verifier is <code>null</code>.
 */
+ (void)setDefaultHostnameVerifierWithJavaxNetSslHostnameVerifier:(id<JavaxNetSslHostnameVerifier>)v;

/*!
 @brief Sets the default SSL socket factory to be used by new instances.
 @param sf
 the new default SSL socket factory.
 @throws IllegalArgumentException
 if the specified socket factory is <code>null</code>.
 */
+ (void)setDefaultSSLSocketFactoryWithJavaxNetSslSSLSocketFactory:(JavaxNetSslSSLSocketFactory *)sf;

/*!
 @brief Sets the hostname verifier for this instance.
 @param v
 the hostname verifier for this instance.
 @throws IllegalArgumentException
 if the specified verifier is <code>null</code>.
 */
- (void)setHostnameVerifierWithJavaxNetSslHostnameVerifier:(id<JavaxNetSslHostnameVerifier>)v;

/*!
 @brief Sets the SSL socket factory for this instance.
 @param sf
 the SSL socket factory to be used by this instance.
 @throws IllegalArgumentException
 if the specified socket factory is <code>null</code>.
 */
- (void)setSSLSocketFactoryWithJavaxNetSslSSLSocketFactory:(JavaxNetSslSSLSocketFactory *)sf;

#pragma mark Protected

/*!
 @brief Creates a new <code>HttpsURLConnection</code> with the specified <code>URL</code>.
 @param url
 the <code>URL</code> to connect to.
 */
- (instancetype)initWithJavaNetURL:(JavaNetURL *)url;

@end

J2OBJC_STATIC_INIT(JavaxNetSslHttpsURLConnection)

J2OBJC_FIELD_SETTER(JavaxNetSslHttpsURLConnection, hostnameVerifier_, id<JavaxNetSslHostnameVerifier>)

FOUNDATION_EXPORT void JavaxNetSslHttpsURLConnection_setDefaultHostnameVerifierWithJavaxNetSslHostnameVerifier_(id<JavaxNetSslHostnameVerifier> v);

FOUNDATION_EXPORT id<JavaxNetSslHostnameVerifier> JavaxNetSslHttpsURLConnection_getDefaultHostnameVerifier();

FOUNDATION_EXPORT void JavaxNetSslHttpsURLConnection_setDefaultSSLSocketFactoryWithJavaxNetSslSSLSocketFactory_(JavaxNetSslSSLSocketFactory *sf);

FOUNDATION_EXPORT JavaxNetSslSSLSocketFactory *JavaxNetSslHttpsURLConnection_getDefaultSSLSocketFactory();

FOUNDATION_EXPORT void JavaxNetSslHttpsURLConnection_initWithJavaNetURL_(JavaxNetSslHttpsURLConnection *self, JavaNetURL *url);

J2OBJC_TYPE_LITERAL_HEADER(JavaxNetSslHttpsURLConnection)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaxNetSslHttpsURLConnection_INCLUDE_ALL")

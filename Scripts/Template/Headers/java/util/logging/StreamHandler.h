//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/logging/StreamHandler.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaUtilLoggingStreamHandler_INCLUDE_ALL")
#ifdef JavaUtilLoggingStreamHandler_RESTRICT
#define JavaUtilLoggingStreamHandler_INCLUDE_ALL 0
#else
#define JavaUtilLoggingStreamHandler_INCLUDE_ALL 1
#endif
#undef JavaUtilLoggingStreamHandler_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilLoggingStreamHandler_) && (JavaUtilLoggingStreamHandler_INCLUDE_ALL || defined(JavaUtilLoggingStreamHandler_INCLUDE))
#define JavaUtilLoggingStreamHandler_

#define JavaUtilLoggingHandler_RESTRICT 1
#define JavaUtilLoggingHandler_INCLUDE 1
#include "../../../java/util/logging/Handler.h"

@class JavaIoOutputStream;
@class JavaUtilLoggingFormatter;
@class JavaUtilLoggingLogRecord;

/*!
 @brief A <code>StreamHandler</code> object writes log messages to an output stream, that
 is, objects of the class <code>java.io.OutputStream</code>.
 <p>
 A <code>StreamHandler</code> object reads the following properties from the log
 manager to initialize itself. A default value will be used if a property is
 not found or has an invalid value.
 <ul>
 <li>java.util.logging.StreamHandler.encoding specifies the encoding this
 handler will use to encode log messages. Default is the encoding used by the
 current platform.
 <li>java.util.logging.StreamHandler.filter specifies the name of the filter
 class to be associated with this handler. No <code>Filter</code> is used by
 default.
 <li>java.util.logging.StreamHandler.formatter specifies the name of the
 formatter class to be associated with this handler. Default is
 <code>java.util.logging.SimpleFormatter</code>.
 <li>java.util.logging.StreamHandler.level specifies the logging level.
 Defaults is <code>Level.INFO</code>.
 </ul>
 <p>
 This class is not thread-safe.
 */
@interface JavaUtilLoggingStreamHandler : JavaUtilLoggingHandler

#pragma mark Public

/*!
 @brief Constructs a <code>StreamHandler</code> object.
 The new stream handler
 does not have an associated output stream.
 */
- (instancetype)init;

/*!
 @brief Constructs a <code>StreamHandler</code> object with the supplied output stream
 and formatter.
 @param os
 the output stream this handler writes to.
 @param formatter
 the formatter this handler uses to format the output.
 @throws NullPointerException
 if <code>os</code> or <code>formatter</code> is <code>null</code>.
 */
- (instancetype)initWithJavaIoOutputStream:(JavaIoOutputStream *)os
              withJavaUtilLoggingFormatter:(JavaUtilLoggingFormatter *)formatter;

/*!
 @brief Closes this handler.
 The tail string of the formatter associated with
 this handler is written out. A flush operation and a subsequent close
 operation is then performed upon the output stream. Client applications
 should not use a handler after closing it.
 */
- (void)close;

/*!
 @brief Flushes any buffered output.
 */
- (void)flush;

/*!
 @brief Determines whether the supplied log record needs to be logged.
 The
 logging levels are checked as well as the filter. The output stream of
 this handler is also checked. If it is <code>null</code>, this method returns
 <code>false</code>.
 <p>
 Notice : Case of no output stream will return <code>false</code>.
 @param record
 the log record to be checked.
 @return <code>true</code> if <code>record</code> needs to be logged, <code>false</code>
 otherwise.
 */
- (jboolean)isLoggableWithJavaUtilLoggingLogRecord:(JavaUtilLoggingLogRecord *)record;

/*!
 @brief Accepts a logging request.
 The log record is formatted and written to the
 output stream if the following three conditions are met:
 <ul>
 <li>the supplied log record has at least the required logging level;
 <li>the supplied log record passes the filter associated with this
 handler, if any;
 <li>the output stream associated with this handler is not <code>null</code>.
 </ul>
 If it is the first time a log record is written out, the head string of
 the formatter associated with this handler is written out first.
 @param record
 the log record to be logged.
 */
- (void)publishWithJavaUtilLoggingLogRecord:(JavaUtilLoggingLogRecord *)record;

/*!
 @brief Sets the character encoding used by this handler.
 A <code>null</code> value
 indicates that the default encoding should be used.
 @throws UnsupportedEncodingException if <code>charsetName</code> is not supported.
 */
- (void)setEncodingWithNSString:(NSString *)charsetName;

#pragma mark Protected

/*!
 @brief Sets the output stream this handler writes to.
 If there's an existing
 output stream, the tail string of the associated formatter will be
 written to it. Then it will be flushed, closed and replaced with
 <code>os</code>.
 @param os
 the new output stream.
 @throws NullPointerException
 if <code>os</code> is <code>null</code>.
 */
- (void)setOutputStreamWithJavaIoOutputStream:(JavaIoOutputStream *)os;

#pragma mark Package-Private

/*!
 @brief Constructs a <code>StreamHandler</code> object with the supplied output
 stream.
 Default properties are read.
 @param os
 the output stream this handler writes to.
 */
- (instancetype)initWithJavaIoOutputStream:(JavaIoOutputStream *)os;

/*!
 @brief Constructs a <code>StreamHandler</code> object.
 The specified default values
 will be used if the corresponding properties are not found in the log
 manager's properties.
 */
- (instancetype)initWithNSString:(NSString *)defaultLevel
                    withNSString:(NSString *)defaultFilter
                    withNSString:(NSString *)defaultFormatter
                    withNSString:(NSString *)defaultEncoding;

/*!
 @brief Closes this handler, but the underlying output stream is only closed if
 <code>closeStream</code> is <code>true</code>.
 Security is not checked.
 @param closeStream
 whether to close the underlying output stream.
 */
- (void)closeWithBoolean:(jboolean)closeStream;

/*!
 @brief Sets the output stream this handler writes to.
 Note it does nothing else.
 @param newOs
 the new output stream
 */
- (void)internalSetOutputStreamWithJavaIoOutputStream:(JavaIoOutputStream *)newOs;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilLoggingStreamHandler)

FOUNDATION_EXPORT void JavaUtilLoggingStreamHandler_init(JavaUtilLoggingStreamHandler *self);

FOUNDATION_EXPORT JavaUtilLoggingStreamHandler *new_JavaUtilLoggingStreamHandler_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLoggingStreamHandler_initWithJavaIoOutputStream_(JavaUtilLoggingStreamHandler *self, JavaIoOutputStream *os);

FOUNDATION_EXPORT JavaUtilLoggingStreamHandler *new_JavaUtilLoggingStreamHandler_initWithJavaIoOutputStream_(JavaIoOutputStream *os) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLoggingStreamHandler_initWithNSString_withNSString_withNSString_withNSString_(JavaUtilLoggingStreamHandler *self, NSString *defaultLevel, NSString *defaultFilter, NSString *defaultFormatter, NSString *defaultEncoding);

FOUNDATION_EXPORT JavaUtilLoggingStreamHandler *new_JavaUtilLoggingStreamHandler_initWithNSString_withNSString_withNSString_withNSString_(NSString *defaultLevel, NSString *defaultFilter, NSString *defaultFormatter, NSString *defaultEncoding) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilLoggingStreamHandler_initWithJavaIoOutputStream_withJavaUtilLoggingFormatter_(JavaUtilLoggingStreamHandler *self, JavaIoOutputStream *os, JavaUtilLoggingFormatter *formatter);

FOUNDATION_EXPORT JavaUtilLoggingStreamHandler *new_JavaUtilLoggingStreamHandler_initWithJavaIoOutputStream_withJavaUtilLoggingFormatter_(JavaIoOutputStream *os, JavaUtilLoggingFormatter *formatter) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLoggingStreamHandler)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaUtilLoggingStreamHandler_INCLUDE_ALL")

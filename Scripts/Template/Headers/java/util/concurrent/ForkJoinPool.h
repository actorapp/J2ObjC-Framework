//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/concurrent/ForkJoinPool.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaUtilConcurrentForkJoinPool_INCLUDE_ALL")
#ifdef JavaUtilConcurrentForkJoinPool_RESTRICT
#define JavaUtilConcurrentForkJoinPool_INCLUDE_ALL 0
#else
#define JavaUtilConcurrentForkJoinPool_INCLUDE_ALL 1
#endif
#undef JavaUtilConcurrentForkJoinPool_RESTRICT
#ifdef JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory_INCLUDE
#define JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_INCLUDE 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilConcurrentForkJoinPool_) && (JavaUtilConcurrentForkJoinPool_INCLUDE_ALL || defined(JavaUtilConcurrentForkJoinPool_INCLUDE))
#define JavaUtilConcurrentForkJoinPool_

#define JavaUtilConcurrentAbstractExecutorService_RESTRICT 1
#define JavaUtilConcurrentAbstractExecutorService_INCLUDE 1
#include "../../../java/util/concurrent/AbstractExecutorService.h"

@class IOSObjectArray;
@class JavaLangThreadLocal;
@class JavaLangThrowable;
@class JavaUtilConcurrentCountedCompleter;
@class JavaUtilConcurrentForkJoinPool_WorkQueue;
@class JavaUtilConcurrentForkJoinTask;
@class JavaUtilConcurrentForkJoinWorkerThread;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaLangRunnable;
@protocol JavaLangThread_UncaughtExceptionHandler;
@protocol JavaUtilCollection;
@protocol JavaUtilConcurrentCallable;
@protocol JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory;
@protocol JavaUtilConcurrentForkJoinPool_ManagedBlocker;
@protocol JavaUtilConcurrentRunnableFuture;
@protocol JavaUtilList;

/*!
 @brief An <code>ExecutorService</code> for running <code>ForkJoinTask</code>s.
 A <code>ForkJoinPool</code> provides the entry point for submissions
 from non-<code>ForkJoinTask</code> clients, as well as management and
 monitoring operations.
 <p>A <code>ForkJoinPool</code> differs from other kinds of <code>ExecutorService</code>
  mainly by virtue of employing
 <em>work-stealing</em>: all threads in the pool attempt to find and
 execute tasks submitted to the pool and/or created by other active
 tasks (eventually blocking waiting for work if none exist). This
 enables efficient processing when most tasks spawn other subtasks
 (as do most <code>ForkJoinTask</code>s), as well as when many small
 tasks are submitted to the pool from external clients.  Especially
 when setting <em>asyncMode</em> to true in constructors, <code>ForkJoinPool</code>
 s may also be appropriate for use with event-style
 tasks that are never joined.
 <p>A static <code>commonPool()</code> is available and appropriate for
 most applications. The common pool is used by any ForkJoinTask that
 is not explicitly submitted to a specified pool. Using the common
 pool normally reduces resource usage (its threads are slowly
 reclaimed during periods of non-use, and reinstated upon subsequent
 use).
 <p>For applications that require separate or custom pools, a <code>ForkJoinPool</code>
  may be constructed with a given target parallelism
 level; by default, equal to the number of available processors. The
 pool attempts to maintain enough active (or available) threads by
 dynamically adding, suspending, or resuming internal worker
 threads, even if some tasks are stalled waiting to join others.
 However, no such adjustments are guaranteed in the face of blocked
 I/O or other unmanaged synchronization. The nested <code>ManagedBlocker</code>
  interface enables extension of the kinds of
 synchronization accommodated.
 <p>In addition to execution and lifecycle control methods, this
 class provides status check methods (for example
 <code>getStealCount</code>) that are intended to aid in developing,
 tuning, and monitoring fork/join applications. Also, method
 <code>toString</code> returns indications of pool state in a
 convenient form for informal monitoring.
 <p>As is the case with other ExecutorServices, there are three
 main task execution methods summarized in the following table.
 These are designed to be used primarily by clients not already
 engaged in fork/join computations in the current pool.  The main
 forms of these methods accept instances of <code>ForkJoinTask</code>,
 but overloaded forms also allow mixed execution of plain <code>Runnable</code>
 - or <code>Callable</code>- based activities as well.  However,
 tasks that are already executing in a pool should normally instead
 use the within-computation forms listed in the table unless using
 async event-style tasks that are not usually joined, in which case
 there is little difference among choice of methods.
 <table BORDER CELLPADDING=3 CELLSPACING=1>
 <caption>Summary of task execution methods</caption>
 <tr>
 <td></td>
 <td ALIGN=CENTER> <b>Call from non-fork/join clients</b></td>
 <td ALIGN=CENTER> <b>Call from within fork/join computations</b></td>
 </tr>
 <tr>
 <td> <b>Arrange async execution</b></td>
 <td> <code>execute(ForkJoinTask)</code></td>
 <td> <code>ForkJoinTask.fork</code></td>
 </tr>
 <tr>
 <td> <b>Await and obtain result</b></td>
 <td> <code>invoke(ForkJoinTask)</code></td>
 <td> <code>ForkJoinTask.invoke</code></td>
 </tr>
 <tr>
 <td> <b>Arrange exec and obtain Future</b></td>
 <td> <code>submit(ForkJoinTask)</code></td>
 <td> <code>ForkJoinTask.fork</code> (ForkJoinTasks <em>are</em> Futures)</td>
 </tr>
 </table>
 <p>The common pool is by default constructed with default
 parameters, but these may be controlled by setting three
 system properties:
 <ul>
 <li><code>java.util.concurrent.ForkJoinPool.common.parallelism</code>
 - the parallelism level, a non-negative integer
 <li><code>java.util.concurrent.ForkJoinPool.common.threadFactory</code>
 - the class name of a <code>ForkJoinWorkerThreadFactory</code>
 <li><code>java.util.concurrent.ForkJoinPool.common.exceptionHandler</code>
 - the class name of a <code>UncaughtExceptionHandler</code>
 </ul>
 The system class loader is used to load these classes.
 Upon any error in establishing these settings, default parameters
 are used. It is possible to disable or limit the use of threads in
 the common pool by setting the parallelism property to zero, and/or
 using a factory that may return <code>null</code>.
 <p><b>Implementation notes</b>: This implementation restricts the
 maximum number of running threads to 32767. Attempts to create
 pools with greater than the maximum number result in
 <code>IllegalArgumentException</code>.
 <p>This implementation rejects submitted tasks (that is, by throwing
 <code>RejectedExecutionException</code>) only when the pool is shut down
 or internal resources have been exhausted.
 @since 1.7
 @author Doug Lea
 */
@interface JavaUtilConcurrentForkJoinPool : JavaUtilConcurrentAbstractExecutorService {
 @public
  volatile_jlong pad00_, pad01_, pad02_, pad03_, pad04_, pad05_, pad06_;
  volatile_jlong stealCount_;
  volatile_jlong ctl_;
  volatile_jint plock_;
  volatile_jint indexSeed_;
  jshort parallelism_;
  jshort mode_;
  IOSObjectArray *workQueues_;
  id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> factory_;
  id<JavaLangThread_UncaughtExceptionHandler> ueh_;
  NSString *workerNamePrefix_;
  volatile_id pad10_, pad11_, pad12_, pad13_, pad14_, pad15_, pad16_, pad17_;
  volatile_id pad18_, pad19_, pad1a_, pad1b_;
}

+ (JavaLangThreadLocal *)submitters;

+ (id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)defaultForkJoinWorkerThreadFactory;

+ (JavaUtilConcurrentForkJoinPool *)common;

+ (jint)commonParallelism;

+ (jint)LIFO_QUEUE;

+ (jint)FIFO_QUEUE;

+ (jint)SHARED_QUEUE;

#pragma mark Public

/*!
 @brief Creates a <code>ForkJoinPool</code> with parallelism equal to <code>java.lang.Runtime.availableProcessors</code>
 , using the default thread factory
 ,
 no UncaughtExceptionHandler, and non-async LIFO processing mode.
 */
- (instancetype)init;

/*!
 @brief Creates a <code>ForkJoinPool</code> with the indicated parallelism
 level, the default thread factory
 ,
 no UncaughtExceptionHandler, and non-async LIFO processing mode.
 @param parallelism the parallelism level
 @throws IllegalArgumentException if parallelism less than or
 equal to zero, or greater than implementation limit
 */
- (instancetype)initWithInt:(jint)parallelism;

/*!
 @brief Creates a <code>ForkJoinPool</code> with the given parameters.
 @param parallelism the parallelism level. For default value,
 use <code>java.lang.Runtime.availableProcessors</code>.
 @param factory the factory for creating new threads. For default value,
 use <code>defaultForkJoinWorkerThreadFactory</code>.
 @param handler the handler for internal worker threads that
 terminate due to unrecoverable errors encountered while executing
 tasks. For default value, use <code>null</code>.
 @param asyncMode if true,
 establishes local first-in-first-out scheduling mode for forked
 tasks that are never joined. This mode may be more appropriate
 than default locally stack-based mode in applications in which
 worker threads only process event-style asynchronous tasks.
 For default value, use <code>false</code>.
 @throws IllegalArgumentException if parallelism less than or
 equal to zero, or greater than implementation limit
 @throws NullPointerException if the factory is null
 */
- (instancetype)initWithInt:(jint)parallelism
withJavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory:(id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)factory
withJavaLangThread_UncaughtExceptionHandler:(id<JavaLangThread_UncaughtExceptionHandler>)handler
                withBoolean:(jboolean)asyncMode;

/*!
 @brief If called by a ForkJoinTask operating in this pool, equivalent
 in effect to <code>ForkJoinTask.helpQuiesce</code>.
 Otherwise,
 waits and/or attempts to assist performing tasks until this
 pool <code>isQuiescent</code> or the indicated timeout elapses.
 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @return <code>true</code> if quiescent; <code>false</code> if the
 timeout elapsed.
 */
- (jboolean)awaitQuiescenceWithLong:(jlong)timeout
     withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Blocks until all tasks have completed execution after a
 shutdown request, or the timeout occurs, or the current thread
 is interrupted, whichever happens first.
 Because the <code>commonPool()</code>
  never terminates until program shutdown, when
 applied to the common pool, this method is equivalent to <code>awaitQuiescence(long,TimeUnit)</code>
  but always returns <code>false</code>.
 @param timeout the maximum time to wait
 @param unit the time unit of the timeout argument
 @return <code>true</code> if this executor terminated and
 <code>false</code> if the timeout elapsed before termination
 @throws InterruptedException if interrupted while waiting
 */
- (jboolean)awaitTerminationWithLong:(jlong)timeout
      withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Returns the common pool instance.
 This pool is statically
 constructed; its run state is unaffected by attempts to <code>shutdown</code>
  or <code>shutdownNow</code>. However this pool and any
 ongoing processing are automatically terminated upon program
 <code>System.exit</code>.  Any program that relies on asynchronous
 task processing to complete before program termination should
 invoke <code>commonPool().</code><code>awaitQuiescence</code>,
 before exit.
 @return the common pool instance
 @since 1.8
 */
+ (JavaUtilConcurrentForkJoinPool *)commonPool;

/*!
 @brief Arranges for (asynchronous) execution of the given task.
 @param task the task
 @throws NullPointerException if the task is null
 @throws RejectedExecutionException if the task cannot be
 scheduled for execution
 */
- (void)executeWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @throws NullPointerException if the task is null
 @throws RejectedExecutionException if the task cannot be
 scheduled for execution
 */
- (void)executeWithJavaLangRunnable:(id<JavaLangRunnable>)task;

/*!
 @brief Returns an estimate of the number of threads that are currently
 stealing or executing tasks.
 This method may overestimate the
 number of active threads.
 @return the number of active threads
 */
- (jint)getActiveThreadCount;

/*!
 @brief Returns <code>true</code> if this pool uses local first-in-first-out
 scheduling mode for forked tasks that are never joined.
 @return <code>true</code> if this pool uses async mode
 */
- (jboolean)getAsyncMode;

/*!
 @brief Returns the targeted parallelism level of the common pool.
 @return the targeted parallelism level of the common pool
 @since 1.8
 */
+ (jint)getCommonPoolParallelism;

/*!
 @brief Returns the factory used for constructing new workers.
 @return the factory used for constructing new workers
 */
- (id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)getFactory;

/*!
 @brief Returns the targeted parallelism level of this pool.
 @return the targeted parallelism level of this pool
 */
- (jint)getParallelism;

/*!
 @brief Returns the number of worker threads that have started but not
 yet terminated.
 The result returned by this method may differ
 from <code>getParallelism</code> when threads are created to
 maintain parallelism when others are cooperatively blocked.
 @return the number of worker threads
 */
- (jint)getPoolSize;

/*!
 @brief Returns an estimate of the number of tasks submitted to this
 pool that have not yet begun executing.
 This method may take
 time proportional to the number of submissions.
 @return the number of queued submissions
 */
- (jint)getQueuedSubmissionCount;

/*!
 @brief Returns an estimate of the total number of tasks currently held
 in queues by worker threads (but not including tasks submitted
 to the pool that have not begun executing).
 This value is only
 an approximation, obtained by iterating across all threads in
 the pool. This method may be useful for tuning task
 granularities.
 @return the number of queued tasks
 */
- (jlong)getQueuedTaskCount;

/*!
 @brief Returns an estimate of the number of worker threads that are
 not blocked waiting to join tasks or for other managed
 synchronization.
 This method may overestimate the
 number of running threads.
 @return the number of worker threads
 */
- (jint)getRunningThreadCount;

/*!
 @brief Returns an estimate of the total number of tasks stolen from
 one thread's work queue by another.
 The reported value
 underestimates the actual total number of steals when the pool
 is not quiescent. This value may be useful for monitoring and
 tuning fork/join programs: in general, steal counts should be
 high enough to keep threads busy, but low enough to avoid
 overhead and contention across threads.
 @return the number of steals
 */
- (jlong)getStealCount;

/*!
 @brief Returns the handler for internal worker threads that terminate
 due to unrecoverable errors encountered while executing tasks.
 @return the handler, or <code>null</code> if none
 */
- (id<JavaLangThread_UncaughtExceptionHandler>)getUncaughtExceptionHandler;

/*!
 @brief Returns <code>true</code> if there are any tasks submitted to this
 pool that have not yet begun executing.
 @return <code>true</code> if there are any queued submissions
 */
- (jboolean)hasQueuedSubmissions;

/*!
 @brief Performs the given task, returning its result upon completion.
 If the computation encounters an unchecked Exception or Error,
 it is rethrown as the outcome of this invocation.  Rethrown
 exceptions behave in the same way as regular exceptions, but,
 when possible, contain stack traces (as displayed for example
 using <code>ex.printStackTrace()</code>) of both the current thread
 as well as the thread actually encountering the exception;
 minimally only the latter.
 @param task the task
 @return the task's result
 @throws NullPointerException if the task is null
 @throws RejectedExecutionException if the task cannot be
 scheduled for execution
 */
- (id)invokeWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @throws NullPointerException
 @throws RejectedExecutionException
 */
- (id<JavaUtilList>)invokeAllWithJavaUtilCollection:(id<JavaUtilCollection>)tasks;

/*!
 @brief Returns <code>true</code> if all worker threads are currently idle.
 An idle worker is one that cannot obtain a task to execute
 because none are available to steal from other threads, and
 there are no pending submissions to the pool. This method is
 conservative; it might not return <code>true</code> immediately upon
 idleness of all threads, but will eventually become true if
 threads remain inactive.
 @return <code>true</code> if all threads are currently idle
 */
- (jboolean)isQuiescent;

/*!
 @brief Returns <code>true</code> if this pool has been shut down.
 @return <code>true</code> if this pool has been shut down
 */
- (jboolean)isShutdown;

/*!
 @brief Returns <code>true</code> if all tasks have completed following shut down.
 @return <code>true</code> if all tasks have completed following shut down
 */
- (jboolean)isTerminated;

/*!
 @brief Returns <code>true</code> if the process of termination has
 commenced but not yet completed.
 This method may be useful for
 debugging. A return of <code>true</code> reported a sufficient
 period after shutdown may indicate that submitted tasks have
 ignored or suppressed interruption, or are waiting for I/O,
 causing this executor not to properly terminate. (See the
 advisory notes for class <code>ForkJoinTask</code> stating that
 tasks should not normally entail blocking operations.  But if
 they do, they must abort them on interrupt.)
 @return <code>true</code> if terminating but not yet terminated
 */
- (jboolean)isTerminating;

/*!
 @brief Blocks in accord with the given blocker.
 If the current thread
 is a <code>ForkJoinWorkerThread</code>, this method possibly
 arranges for a spare thread to be activated if necessary to
 ensure sufficient parallelism while the current thread is blocked.
 <p>If the caller is not a <code>ForkJoinTask</code>, this method is
 behaviorally equivalent to
 @code
  while (!blocker.isReleasable())
   if (blocker.block())
     return;
 
@endcode
 If the caller is a <code>ForkJoinTask</code>, then the pool may
 first be expanded to ensure parallelism, and later adjusted.
 @param blocker the blocker
 @throws InterruptedException if blocker.block did so
 */
+ (void)managedBlockWithJavaUtilConcurrentForkJoinPool_ManagedBlocker:(id<JavaUtilConcurrentForkJoinPool_ManagedBlocker>)blocker;

/*!
 @brief Possibly initiates an orderly shutdown in which previously
 submitted tasks are executed, but no new tasks will be
 accepted.
 Invocation has no effect on execution state if this
 is the <code>commonPool()</code>, and no additional effect if
 already shut down.  Tasks that are in the process of being
 submitted concurrently during the course of this method may or
 may not be rejected.
 */
- (void)shutdown;

/*!
 @brief Possibly attempts to cancel and/or stop all tasks, and reject
 all subsequently submitted tasks.
 Invocation has no effect on
 execution state if this is the <code>commonPool()</code>, and no
 additional effect if already shut down. Otherwise, tasks that
 are in the process of being submitted or executed concurrently
 during the course of this method may or may not be
 rejected. This method cancels both existing and unexecuted
 tasks, in order to permit termination in the presence of task
 dependencies. So the method always returns an empty list
 (unlike the case for some other Executors).
 @return an empty list
 */
- (id<JavaUtilList>)shutdownNow;

/*!
 @throws NullPointerException if the task is null
 @throws RejectedExecutionException if the task cannot be
 scheduled for execution
 */
- (JavaUtilConcurrentForkJoinTask *)submitWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable>)task;

/*!
 @brief Submits a ForkJoinTask for execution.
 @param task the task to submit
 @return the task
 @throws NullPointerException if the task is null
 @throws RejectedExecutionException if the task cannot be
 scheduled for execution
 */
- (JavaUtilConcurrentForkJoinTask *)submitWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @throws NullPointerException if the task is null
 @throws RejectedExecutionException if the task cannot be
 scheduled for execution
 */
- (JavaUtilConcurrentForkJoinTask *)submitWithJavaLangRunnable:(id<JavaLangRunnable>)task;

/*!
 @throws NullPointerException if the task is null
 @throws RejectedExecutionException if the task cannot be
 scheduled for execution
 */
- (JavaUtilConcurrentForkJoinTask *)submitWithJavaLangRunnable:(id<JavaLangRunnable>)task
                                                        withId:(id)result;

/*!
 @brief Returns a string identifying this pool, as well as its state,
 including indications of run state, parallelism level, and
 worker and task counts.
 @return a string identifying this pool, as well as its state
 */
- (NSString *)description;

#pragma mark Protected

/*!
 @brief Removes all available unexecuted submitted and forked tasks
 from scheduling queues and adds them to the given collection,
 without altering their execution status.
 These may include
 artificially generated or wrapped tasks. This method is
 designed to be invoked only when the pool is known to be
 quiescent. Invocations at other times may not remove all
 tasks. A failure encountered while attempting to add elements
 to collection <code>c</code> may result in elements being in
 neither, either or both collections when the associated
 exception is thrown.  The behavior of this operation is
 undefined if the specified collection is modified while the
 operation is in progress.
 @param c the collection to transfer elements into
 @return the number of elements transferred
 */
- (jint)drainTasksToWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (id<JavaUtilConcurrentRunnableFuture>)newTaskForWithJavaUtilConcurrentCallable:(id<JavaUtilConcurrentCallable>)callable OBJC_METHOD_FAMILY_NONE;

- (id<JavaUtilConcurrentRunnableFuture>)newTaskForWithJavaLangRunnable:(id<JavaLangRunnable>)runnable
                                                                withId:(id)value OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Removes and returns the next unexecuted submission if one is
 available.
 This method may be useful in extensions to this
 class that re-assign work in systems with multiple pools.
 @return the next submission, or <code>null</code> if none
 */
- (JavaUtilConcurrentForkJoinTask *)pollSubmission;

#pragma mark Package-Private

/*!
 @brief Helps and/or blocks until the given task is done.
 @param joiner the joining worker
 @param task the task
 @return task status on exit
 */
- (jint)awaitJoinWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)joiner
                           withJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Returns common pool queue for a thread that has submitted at
 least one task.
 */
+ (JavaUtilConcurrentForkJoinPool_WorkQueue *)commonSubmitterQueue;

/*!
 @brief Final callback from terminating worker, as well as upon failure
 to construct or start a worker.
 Removes record of worker from
 array, and adjusts counts. If pool is shutting down, tries to
 complete termination.
 @param wt the worker thread, or null if construction failed
 @param ex the exception causing failure, or null if none
 */
- (void)deregisterWorkerWithJavaUtilConcurrentForkJoinWorkerThread:(JavaUtilConcurrentForkJoinWorkerThread *)wt
                                             withJavaLangThrowable:(JavaLangThrowable *)ex;

- (jint)externalHelpCompleteWithJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)task;

/*!
 @brief Unless shutting down, adds the given task to a submission queue
 at submitter's current queue index (modulo submission
 range).
 Only the most common path is directly handled in this
 method. All others are relayed to fullExternalPush.
 @param task the task. Caller must ensure non-null.
 */
- (void)externalPushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Returns a cheap heuristic guide for task partitioning when
 programmers, frameworks, tools, or languages have little or no
 idea about task granularity.
 In essence by offering this
 method, we ask users only about tradeoffs in overhead vs
 expected throughput and its variance, rather than how finely to
 partition tasks.
 In a steady state strict (tree-structured) computation, each
 thread makes available for stealing enough tasks for other
 threads to remain active. Inductively, if all threads play by
 the same rules, each thread should make available only a
 constant number of tasks.
 The minimum useful constant is just 1. But using a value of 1
 would require immediate replenishment upon each steal to
 maintain enough tasks, which is infeasible.  Further,
 partitionings/granularities of offered tasks should minimize
 steal rates, which in general means that threads nearer the top
 of computation tree should generate more than those nearer the
 bottom. In perfect steady state, each thread is at
 approximately the same level of computation tree. However,
 producing extra tasks amortizes the uncertainty of progress and
 diffusion assumptions.
 So, users will want to use values larger (but not much larger)
 than 1 to both smooth over transient shortages and hedge
 against uneven progress; as traded off against the cost of
 extra task overhead. We leave the user to pick a threshold
 value to compare with the results of this call to guide
 decisions, but recommend values such as 3.
 When all threads are active, it is on average OK to estimate
 surplus strictly locally. In steady-state, if one thread is
 maintaining say 2 surplus tasks, then so are others. So we can
 just use estimated queue length.  However, this strategy alone
 leads to serious mis-estimates in some non-steady-state
 conditions (ramp-up, ramp-down, other stalls). We can detect
 many of these by further considering the number of "idle"
 threads, that are known to have zero queued tasks, so
 compensate by a factor of (#idle/#active) threads.
 Note: The approximation of #busy workers as #active workers is
 not very good under current signalling scheme, and should be
 improved.
 */
+ (jint)getSurplusQueuedTaskCount;

/*!
 @brief Stripped-down variant of awaitJoin used by timed joins.
 Tries
 to help join only while there is continuous progress. (Caller
 will then enter a timed wait.)
 @param joiner the joining worker
 @param task the task
 */
- (void)helpJoinOnceWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)joiner
                              withJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Runs tasks until <code>isQuiescent()</code>.
 We piggyback on
 active count ctl maintenance, but rather than blocking
 when tasks cannot be found, we rescan until all others cannot
 find tasks either.
 */
- (void)helpQuiescePoolWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)w;

/*!
 @brief Increments active count; mainly called upon return from blocking.
 */
- (void)incrementActiveCount;

/*!
 @brief Gets and removes a local or stolen task for the given worker.
 @return a task, if available
 */
- (JavaUtilConcurrentForkJoinTask *)nextTaskForWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)w;

/*!
 @brief Waits and/or attempts to assist performing tasks indefinitely
 until the <code>commonPool()</code> <code>isQuiescent</code>.
 */
+ (void)quiesceCommonPool;

/*!
 @brief Callback from ForkJoinWorkerThread to establish and record its
 WorkQueue.
 To avoid scanning bias due to packing entries in
 front of the workQueues array, we treat the array as a simple
 power-of-two hash table using per-thread seed as hash,
 expanding as needed.
 @param wt the worker thread
 @return the worker's queue
 */
- (JavaUtilConcurrentForkJoinPool_WorkQueue *)registerWorkerWithJavaUtilConcurrentForkJoinWorkerThread:(JavaUtilConcurrentForkJoinWorkerThread *)wt;

/*!
 @brief Top-level runloop for workers, called by ForkJoinWorkerThread.run.
 */
- (void)runWorkerWithJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)w;

/*!
 @brief Tries to create or activate a worker if too few are active.
 @param ws the worker array to use to find signallees
 @param q if non-null, the queue holding tasks to be processed
 */
- (void)signalWorkWithJavaUtilConcurrentForkJoinPool_WorkQueueArray:(IOSObjectArray *)ws
                       withJavaUtilConcurrentForkJoinPool_WorkQueue:(JavaUtilConcurrentForkJoinPool_WorkQueue *)q;

/*!
 @brief Tries to decrement active count (sometimes implicitly) and
 possibly release or create a compensating worker in preparation
 for blocking.
 Fails on contention or termination. Otherwise,
 adds a new thread if no idle workers are available and pool
 may become starved.
 @param c the assumed ctl value
 */
- (jboolean)tryCompensateWithLong:(jlong)c;

/*!
 @brief Tries to pop the given task from submitter's queue in common pool.
 */
- (jboolean)tryExternalUnpushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentForkJoinPool)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, workQueues_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, factory_, id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, ueh_, id<JavaLangThread_UncaughtExceptionHandler>)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, workerNamePrefix_, NSString *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad10_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad11_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad12_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad13_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad14_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad15_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad16_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad17_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad18_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad19_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad1a_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool, pad1b_, id)

/*!
 @brief Per-thread submission bookkeeping.
 Shared across all pools
 to reduce ThreadLocal pollution and because random motion
 to avoid contention in one pool is likely to hold for others.
 Lazily initialized on first submission (but null-checked
 in other contexts to avoid unnecessary initialization).
 */
inline JavaLangThreadLocal *JavaUtilConcurrentForkJoinPool_get_submitters();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaLangThreadLocal *JavaUtilConcurrentForkJoinPool_submitters;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentForkJoinPool, submitters, JavaLangThreadLocal *)

/*!
 @brief Creates a new ForkJoinWorkerThread.
 This factory is used unless
 overridden in ForkJoinPool constructors.
 */
inline id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> JavaUtilConcurrentForkJoinPool_get_defaultForkJoinWorkerThreadFactory();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> JavaUtilConcurrentForkJoinPool_defaultForkJoinWorkerThreadFactory;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentForkJoinPool, defaultForkJoinWorkerThreadFactory, id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory>)

/*!
 @brief Common (static) pool.
 Non-null for public use unless a static
 construction exception, but internal usages null-check on use
 to paranoically avoid potential initialization circularities
 as well as to simplify generated code.
 */
inline JavaUtilConcurrentForkJoinPool *JavaUtilConcurrentForkJoinPool_get_common();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *JavaUtilConcurrentForkJoinPool_common;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentForkJoinPool, common, JavaUtilConcurrentForkJoinPool *)

/*!
 @brief Common pool parallelism.
 To allow simpler use and management
 when common pool threads are disabled, we allow the underlying
 common.parallelism field to be zero, but in that case still report
 parallelism as 1 to reflect resulting caller-runs mechanics.
 */
inline jint JavaUtilConcurrentForkJoinPool_get_commonParallelism();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint JavaUtilConcurrentForkJoinPool_commonParallelism;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaUtilConcurrentForkJoinPool, commonParallelism, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_LIFO_QUEUE();
#define JavaUtilConcurrentForkJoinPool_LIFO_QUEUE 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, LIFO_QUEUE, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_FIFO_QUEUE();
#define JavaUtilConcurrentForkJoinPool_FIFO_QUEUE 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, FIFO_QUEUE, jint)

inline jint JavaUtilConcurrentForkJoinPool_get_SHARED_QUEUE();
#define JavaUtilConcurrentForkJoinPool_SHARED_QUEUE -1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool, SHARED_QUEUE, jint)

FOUNDATION_EXPORT jint JavaUtilConcurrentForkJoinPool_getSurplusQueuedTaskCount();

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_WorkQueue *JavaUtilConcurrentForkJoinPool_commonSubmitterQueue();

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_init(JavaUtilConcurrentForkJoinPool *self);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *new_JavaUtilConcurrentForkJoinPool_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_initWithInt_(JavaUtilConcurrentForkJoinPool *self, jint parallelism);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *new_JavaUtilConcurrentForkJoinPool_initWithInt_(jint parallelism) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_initWithInt_withJavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_withJavaLangThread_UncaughtExceptionHandler_withBoolean_(JavaUtilConcurrentForkJoinPool *self, jint parallelism, id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> factory, id<JavaLangThread_UncaughtExceptionHandler> handler, jboolean asyncMode);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *new_JavaUtilConcurrentForkJoinPool_initWithInt_withJavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_withJavaLangThread_UncaughtExceptionHandler_withBoolean_(jint parallelism, id<JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory> factory, id<JavaLangThread_UncaughtExceptionHandler> handler, jboolean asyncMode) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool *JavaUtilConcurrentForkJoinPool_commonPool();

FOUNDATION_EXPORT jint JavaUtilConcurrentForkJoinPool_getCommonPoolParallelism();

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_quiesceCommonPool();

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_managedBlockWithJavaUtilConcurrentForkJoinPool_ManagedBlocker_(id<JavaUtilConcurrentForkJoinPool_ManagedBlocker> blocker);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_) && (JavaUtilConcurrentForkJoinPool_INCLUDE_ALL || defined(JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_INCLUDE))
#define JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory_

@class JavaUtilConcurrentForkJoinPool;
@class JavaUtilConcurrentForkJoinWorkerThread;

/*!
 @brief Factory for creating new <code>ForkJoinWorkerThread</code>s.
 A <code>ForkJoinWorkerThreadFactory</code> must be defined and used
 for <code>ForkJoinWorkerThread</code> subclasses that extend base
 functionality or initialize threads with different contexts.
 */
@protocol JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory < NSObject, JavaObject >

/*!
 @brief Returns a new worker thread operating in the given pool.
 @param pool the pool this thread works in
 @return the new worker thread
 @throws NullPointerException if the pool is null
 */
- (JavaUtilConcurrentForkJoinWorkerThread *)newThreadWithJavaUtilConcurrentForkJoinPool:(JavaUtilConcurrentForkJoinPool *)pool OBJC_METHOD_FAMILY_NONE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory)

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory_) && (JavaUtilConcurrentForkJoinPool_INCLUDE_ALL || defined(JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory_INCLUDE))
#define JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory_

@class JavaUtilConcurrentForkJoinPool;
@class JavaUtilConcurrentForkJoinWorkerThread;

/*!
 @brief Default ForkJoinWorkerThreadFactory implementation; creates a
 new ForkJoinWorkerThread.
 */
@interface JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory : NSObject < JavaUtilConcurrentForkJoinPool_ForkJoinWorkerThreadFactory >

#pragma mark Public

- (JavaUtilConcurrentForkJoinWorkerThread *)newThreadWithJavaUtilConcurrentForkJoinPool:(JavaUtilConcurrentForkJoinPool *)pool OBJC_METHOD_FAMILY_NONE;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory_init(JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory *self);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory *new_JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_DefaultForkJoinWorkerThreadFactory)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_EmptyTask_) && (JavaUtilConcurrentForkJoinPool_INCLUDE_ALL || defined(JavaUtilConcurrentForkJoinPool_EmptyTask_INCLUDE))
#define JavaUtilConcurrentForkJoinPool_EmptyTask_

#define JavaUtilConcurrentForkJoinTask_RESTRICT 1
#define JavaUtilConcurrentForkJoinTask_INCLUDE 1
#include "../../../java/util/concurrent/ForkJoinTask.h"

@class JavaLangVoid;

/*!
 @brief Class for artificial tasks that are used to replace the target
 of local joins if they are removed from an interior queue slot
 in WorkQueue.tryRemoveAndExec.
 We don't need the proxy to
 actually do anything beyond having a unique identity.
 */
@interface JavaUtilConcurrentForkJoinPool_EmptyTask : JavaUtilConcurrentForkJoinTask

#pragma mark Public

- (jboolean)exec;

- (id)getRawResult;

- (void)setRawResultWithId:(id)x;

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinPool_EmptyTask)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_EmptyTask_init(JavaUtilConcurrentForkJoinPool_EmptyTask *self);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_EmptyTask *new_JavaUtilConcurrentForkJoinPool_EmptyTask_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_EmptyTask)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_WorkQueue_) && (JavaUtilConcurrentForkJoinPool_INCLUDE_ALL || defined(JavaUtilConcurrentForkJoinPool_WorkQueue_INCLUDE))
#define JavaUtilConcurrentForkJoinPool_WorkQueue_

@class IOSObjectArray;
@class JavaLangThread;
@class JavaUtilConcurrentCountedCompleter;
@class JavaUtilConcurrentForkJoinPool;
@class JavaUtilConcurrentForkJoinTask;
@class JavaUtilConcurrentForkJoinWorkerThread;

/*!
 @brief Queues supporting work-stealing as well as external task
 submission.
 See above for main rationale and algorithms.
 Implementation relies heavily on "Unsafe" intrinsics
 and selective use of "volatile":
 Field "base" is the index (mod array.length) of the least valid
 queue slot, which is always the next position to steal (poll)
 from if nonempty. Reads and writes require volatile orderings
 but not CAS, because updates are only performed after slot
 CASes.
 Field "top" is the index (mod array.length) of the next queue
 slot to push to or pop from. It is written only by owner thread
 for push, or under lock for external/shared push, and accessed
 by other threads only after reading (volatile) base.  Both top
 and base are allowed to wrap around on overflow, but (top -
 base) (or more commonly -(base - top) to force volatile read of
 base before top) still estimates size. The lock ("qlock") is
 forced to -1 on termination, causing all further lock attempts
 to fail. (Note: we don't need CAS for termination state because
 upon pool shutdown, all shared-queues will stop being used
 anyway.)  Nearly all lock bodies are set up so that exceptions
 within lock bodies are "impossible" (modulo JVM errors that
 would cause failure anyway.)
 The array slots are read and written using the emulation of
 volatiles/atomics provided by Unsafe. Insertions must in
 general use putOrderedObject as a form of releasing store to
 ensure that all writes to the task object are ordered before
 its publication in the queue.  All removals entail a CAS to
 null.  The array is always a power of two. To ensure safety of
 Unsafe array operations, all accesses perform explicit null
 checks and implicit bounds checks via power-of-two masking.
 In addition to basic queuing support, this class contains
 fields described elsewhere to control execution. It turns out
 to work better memory-layout-wise to include them in this class
 rather than a separate class.
 Performance on most platforms is very sensitive to placement of
 instances of both WorkQueues and their arrays -- we absolutely
 do not want multiple WorkQueue instances or multiple queue
 arrays sharing cache lines. (It would be best for queue objects
 and their arrays to share, but there is nothing available to
 help arrange that). The @@Contended annotation alerts JVMs to
 try to keep instances apart.
 */
@interface JavaUtilConcurrentForkJoinPool_WorkQueue : NSObject {
 @public
  volatile_jlong pad00_, pad01_, pad02_, pad03_, pad04_, pad05_, pad06_;
  volatile_jint eventCount_;
  jint nextWait_;
  jint nsteals_;
  jint hint_;
  jshort poolIndex_;
  jshort mode_;
  volatile_jint qlock_;
  volatile_jint base_;
  jint top_;
  IOSObjectArray *array_;
  __weak JavaUtilConcurrentForkJoinPool *pool_;
  JavaUtilConcurrentForkJoinWorkerThread *owner_;
  volatile_id parker_;
  volatile_id currentJoin_;
  JavaUtilConcurrentForkJoinTask *currentSteal_;
  volatile_id pad10_, pad11_, pad12_, pad13_, pad14_, pad15_, pad16_, pad17_;
  volatile_id pad18_, pad19_, pad1a_, pad1b_, pad1c_, pad1d_;
}

+ (jint)INITIAL_QUEUE_CAPACITY;

+ (jint)MAXIMUM_QUEUE_CAPACITY;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentForkJoinPool:(JavaUtilConcurrentForkJoinPool *)pool
            withJavaUtilConcurrentForkJoinWorkerThread:(JavaUtilConcurrentForkJoinWorkerThread *)owner
                                               withInt:(jint)mode
                                               withInt:(jint)seed;

/*!
 @brief Removes and cancels all known tasks, ignoring any exceptions.
 */
- (void)cancelAll;

/*!
 @brief Tries to pop and execute the given task or any other task
 in its CountedCompleter computation.
 */
- (jboolean)externalPopAndExecCCWithJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)root;

/*!
 @brief Initializes or doubles the capacity of array.
 Call either
 by owner or with lock held -- it is OK for base, but not
 top, to move while resizings are in progress.
 */
- (IOSObjectArray *)growArray;

/*!
 @brief Internal version
 */
- (jboolean)internalPopAndExecCCWithJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)root;

/*!
 @brief Returns true if owned and not known to be blocked.
 */
- (jboolean)isApparentlyUnblocked;

/*!
 @brief Provides a more accurate estimate of whether this queue has
 any tasks than does queueSize, by checking whether a
 near-empty queue has at least one unclaimed task.
 */
- (jboolean)isEmpty;

/*!
 @brief Takes next task, if one exists, in order specified by mode.
 */
- (JavaUtilConcurrentForkJoinTask *)nextLocalTask;

/*!
 @brief Returns next task, if one exists, in order specified by mode.
 */
- (JavaUtilConcurrentForkJoinTask *)peek;

/*!
 @brief Takes next task, if one exists, in FIFO order.
 */
- (JavaUtilConcurrentForkJoinTask *)poll;

/*!
 @brief Polls and runs tasks until empty.
 */
- (void)pollAndExecAll;

/*!
 @brief Tries to poll for and execute the given task or any other
 task in its CountedCompleter computation.
 */
- (jboolean)pollAndExecCCWithJavaUtilConcurrentCountedCompleter:(JavaUtilConcurrentCountedCompleter *)root;

/*!
 @brief Takes a task in FIFO order if b is base of queue and a task
 can be claimed without contention.
 Specialized versions
 appear in ForkJoinPool methods scan and tryHelpStealer.
 */
- (JavaUtilConcurrentForkJoinTask *)pollAtWithInt:(jint)b;

/*!
 @brief Takes next task, if one exists, in LIFO order.
 Call only
 by owner in unshared queues.
 */
- (JavaUtilConcurrentForkJoinTask *)pop;

/*!
 @brief Pushes a task.
 Call only by owner in unshared queues.  (The
 shared-queue version is embedded in method externalPush.)
 @param task the task. Caller must ensure non-null.
 @throws RejectedExecutionException if array cannot be resized
 */
- (void)pushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Returns the approximate number of tasks in the queue.
 */
- (jint)queueSize;

/*!
 @brief Executes a top-level task and any local tasks remaining
 after execution.
 */
- (void)runTaskWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief If present, removes from queue and executes the given task,
 or any other cancelled task.
 Returns (true) on any CAS
 or consistency check failure so caller can retry.
 @return false if no progress can be made, else true
 */
- (jboolean)tryRemoveAndExecWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)task;

/*!
 @brief Pops the given task only if it is at the current top.
 (A shared version is available only via FJP.tryExternalUnpush)
 */
- (jboolean)tryUnpushWithJavaUtilConcurrentForkJoinTask:(JavaUtilConcurrentForkJoinTask *)t;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentForkJoinPool_WorkQueue)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, array_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, owner_, JavaUtilConcurrentForkJoinWorkerThread *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, parker_, JavaLangThread *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, currentJoin_, JavaUtilConcurrentForkJoinTask *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, currentSteal_, JavaUtilConcurrentForkJoinTask *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad10_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad11_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad12_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad13_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad14_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad15_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad16_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad17_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad18_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad19_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad1a_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad1b_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad1c_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentForkJoinPool_WorkQueue, pad1d_, id)

/*!
 @brief Capacity of work-stealing queue array upon initialization.
 Must be a power of two; at least 4, but should be larger to
 reduce or eliminate cacheline sharing among queues.
 Currently, it is much larger, as a partial workaround for
 the fact that JVMs often place arrays in locations that
 share GC bookkeeping (especially cardmarks) such that
 per-write accesses encounter serious memory contention.
 */
inline jint JavaUtilConcurrentForkJoinPool_WorkQueue_get_INITIAL_QUEUE_CAPACITY();
#define JavaUtilConcurrentForkJoinPool_WorkQueue_INITIAL_QUEUE_CAPACITY 8192
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool_WorkQueue, INITIAL_QUEUE_CAPACITY, jint)

/*!
 @brief Maximum size for queue arrays.
 Must be a power of two less
 than or equal to 1 << (31 - width of array entry) to ensure
 lack of wraparound of index calculations, but defined to a
 value a bit less than this to help users trap runaway
 programs before saturating systems.
 */
inline jint JavaUtilConcurrentForkJoinPool_WorkQueue_get_MAXIMUM_QUEUE_CAPACITY();
#define JavaUtilConcurrentForkJoinPool_WorkQueue_MAXIMUM_QUEUE_CAPACITY 67108864
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentForkJoinPool_WorkQueue, MAXIMUM_QUEUE_CAPACITY, jint)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_WorkQueue_initWithJavaUtilConcurrentForkJoinPool_withJavaUtilConcurrentForkJoinWorkerThread_withInt_withInt_(JavaUtilConcurrentForkJoinPool_WorkQueue *self, JavaUtilConcurrentForkJoinPool *pool, JavaUtilConcurrentForkJoinWorkerThread *owner, jint mode, jint seed);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_WorkQueue *new_JavaUtilConcurrentForkJoinPool_WorkQueue_initWithJavaUtilConcurrentForkJoinPool_withJavaUtilConcurrentForkJoinWorkerThread_withInt_withInt_(JavaUtilConcurrentForkJoinPool *pool, JavaUtilConcurrentForkJoinWorkerThread *owner, jint mode, jint seed) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_WorkQueue)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_Submitter_) && (JavaUtilConcurrentForkJoinPool_INCLUDE_ALL || defined(JavaUtilConcurrentForkJoinPool_Submitter_INCLUDE))
#define JavaUtilConcurrentForkJoinPool_Submitter_

/*!
 @brief Per-thread records for threads that submit to pools.
 Currently
 holds only pseudo-random seed / index that is used to choose
 submission queues in method externalPush. In the future, this may
 also incorporate a means to implement different task rejection
 and resubmission policies.
 Seeds for submitters and workers/workQueues work in basically
 the same way but are initialized and updated using slightly
 different mechanics. Both are initialized using the same
 approach as in class ThreadLocal, where successive values are
 unlikely to collide with previous values. Seeds are then
 randomly modified upon collisions using xorshifts, which
 requires a non-zero seed.
 */
@interface JavaUtilConcurrentForkJoinPool_Submitter : NSObject {
 @public
  jint seed_;
}

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)s;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinPool_Submitter)

FOUNDATION_EXPORT void JavaUtilConcurrentForkJoinPool_Submitter_initWithInt_(JavaUtilConcurrentForkJoinPool_Submitter *self, jint s);

FOUNDATION_EXPORT JavaUtilConcurrentForkJoinPool_Submitter *new_JavaUtilConcurrentForkJoinPool_Submitter_initWithInt_(jint s) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_Submitter)

#endif

#if !defined (JavaUtilConcurrentForkJoinPool_ManagedBlocker_) && (JavaUtilConcurrentForkJoinPool_INCLUDE_ALL || defined(JavaUtilConcurrentForkJoinPool_ManagedBlocker_INCLUDE))
#define JavaUtilConcurrentForkJoinPool_ManagedBlocker_

/*!
 @brief Interface for extending managed parallelism for tasks running
 in <code>ForkJoinPool</code>s.
 <p>A <code>ManagedBlocker</code> provides two methods.  Method
 <code>isReleasable</code> must return <code>true</code> if blocking is
 not necessary. Method <code>block</code> blocks the current thread
 if necessary (perhaps internally invoking <code>isReleasable</code>
 before actually blocking). These actions are performed by any
 thread invoking <code>ForkJoinPool.managedBlock(ManagedBlocker)</code>.
 The unusual methods in this API accommodate synchronizers that
 may, but don't usually, block for long periods. Similarly, they
 allow more efficient internal handling of cases in which
 additional workers may be, but usually are not, needed to
 ensure sufficient parallelism.  Toward this end,
 implementations of method <code>isReleasable</code> must be amenable
 to repeated invocation.
 <p>For example, here is a ManagedBlocker based on a
 ReentrantLock:
 @code
 
  class ManagedLocker implements ManagedBlocker 
   final ReentrantLock lock;
   boolean hasLock = false;
   ManagedLocker(ReentrantLock lock) { this.lock = lock; }
   public boolean block() {
     if (!hasLock)
       lock.lock();
     return true;
   }
   public boolean isReleasable() {
     return hasLock || (hasLock = lock.tryLock());
   }
  
@endcode
 <p>Here is a class that possibly blocks waiting for an
 item on a given queue:
 @code
 
  class QueueTaker<E> implements ManagedBlocker 
   final BlockingQueue<E> queue;
   volatile E item = null;
   QueueTaker(BlockingQueue<E> q) { this.queue = q; }
   public boolean block() throws InterruptedException {
     if (item == null)
       item = queue.take();
     return true;
   }
   public boolean isReleasable() {
     return item != null || (item = queue.poll()) != null;
   }
   public E getItem() { // call after pool.managedBlock completes
     return item;
   }
  
@endcode
 */
@protocol JavaUtilConcurrentForkJoinPool_ManagedBlocker < NSObject, JavaObject >

/*!
 @brief Possibly blocks the current thread, for example waiting for
 a lock or condition.
 @return <code>true</code> if no additional blocking is necessary
 (i.e., if isReleasable would return true)
 @throws InterruptedException if interrupted while waiting
 (the method is not required to do so, but is allowed to)
 */
- (jboolean)block;

/*!
 @brief Returns <code>true</code> if blocking is unnecessary.
 @return <code>true</code> if blocking is unnecessary
 */
- (jboolean)isReleasable;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentForkJoinPool_ManagedBlocker)

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentForkJoinPool_ManagedBlocker)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaUtilConcurrentForkJoinPool_INCLUDE_ALL")

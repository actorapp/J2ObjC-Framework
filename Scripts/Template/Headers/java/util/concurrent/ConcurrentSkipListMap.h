//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/concurrent/ConcurrentSkipListMap.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL")
#ifdef JavaUtilConcurrentConcurrentSkipListMap_RESTRICT
#define JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL 0
#else
#define JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL 1
#endif
#undef JavaUtilConcurrentConcurrentSkipListMap_RESTRICT
#ifdef JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_INCLUDE
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_INCLUDE
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_INCLUDE
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_INCLUDE
#define JavaUtilConcurrentConcurrentSkipListMap_Iter_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_INCLUDE
#define JavaUtilConcurrentConcurrentSkipListMap_Iter_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_INCLUDE
#define JavaUtilConcurrentConcurrentSkipListMap_Iter_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_INCLUDE
#define JavaUtilConcurrentConcurrentSkipListMap_Index_INCLUDE 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_

#define JavaUtilAbstractMap_RESTRICT 1
#define JavaUtilAbstractMap_INCLUDE 1
#include "../../../java/util/AbstractMap.h"

#define JavaUtilConcurrentConcurrentNavigableMap_RESTRICT 1
#define JavaUtilConcurrentConcurrentNavigableMap_INCLUDE 1
#include "../../../java/util/concurrent/ConcurrentNavigableMap.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../java/io/Serializable.h"

@class JavaUtilAbstractMap_SimpleImmutableEntry;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilIterator;
@protocol JavaUtilList;
@protocol JavaUtilMap;
@protocol JavaUtilMap_Entry;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilSet;
@protocol JavaUtilSortedMap;

/*!
 @brief A scalable concurrent <code>ConcurrentNavigableMap</code> implementation.
 The map is sorted according to the natural
 ordering
  of its keys, or by a <code>Comparator</code> provided at map
 creation time, depending on which constructor is used.
 <p>This class implements a concurrent variant of <a
 href="http://en.wikipedia.org/wiki/Skip_list" target="_top">SkipLists</a>
 providing expected average <i>log(n)</i> time cost for the
 <code>containsKey</code>, <code>get</code>, <code>put</code> and
 <code>remove</code> operations and their variants.  Insertion, removal,
 update, and access operations safely execute concurrently by
 multiple threads.  Iterators are <i>weakly consistent</i>, returning
 elements reflecting the state of the map at some point at or since
 the creation of the iterator.  They do <em>not</em> throw <code>ConcurrentModificationException</code>
 , and may proceed concurrently with
 other operations. Ascending key ordered views and their iterators
 are faster than descending ones.
 <p>All <code>Map.Entry</code> pairs returned by methods in this class
 and its views represent snapshots of mappings at the time they were
 produced. They do <em>not</em> support the <code>Entry.setValue</code>
 method. (Note however that it is possible to change mappings in the
 associated map using <code>put</code>, <code>putIfAbsent</code>, or
 <code>replace</code>, depending on exactly which effect you need.)
 <p>Beware that, unlike in most collections, the <code>size</code>
 method is <em>not</em> a constant-time operation. Because of the
 asynchronous nature of these maps, determining the current number
 of elements requires a traversal of the elements, and so may report
 inaccurate results if this collection is modified during traversal.
 Additionally, the bulk operations <code>putAll</code>, <code>equals</code>,
 <code>toArray</code>, <code>containsValue</code>, and <code>clear</code> are
 <em>not</em> guaranteed to be performed atomically. For example, an
 iterator operating concurrently with a <code>putAll</code> operation
 might view only some of the added elements.
 <p>This class and its views and iterators implement all of the
 <em>optional</em> methods of the <code>Map</code> and <code>Iterator</code>
 interfaces. Like most other concurrent collections, this class does
 <em>not</em> permit the use of <code>null</code> keys or values because some
 null return values cannot be reliably distinguished from the absence of
 elements.
 @author Doug Lea
 @since 1.6
 */
@interface JavaUtilConcurrentConcurrentSkipListMap : JavaUtilAbstractMap < JavaUtilConcurrentConcurrentNavigableMap, NSCopying, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Constructs a new, empty map, sorted according to the
 natural ordering of the keys.
 */
- (instancetype)init;

/*!
 @brief Constructs a new, empty map, sorted according to the specified
 comparator.
 @param comparator the comparator that will be used to order this map.
 If <code>null</code>, the natural
 ordering
  of the keys will be used.
 */
- (instancetype)initWithJavaUtilComparator:(id<JavaUtilComparator>)comparator;

/*!
 @brief Constructs a new map containing the same mappings as the given map,
 sorted according to the natural ordering of
 the keys.
 @param m the map whose mappings are to be placed in this map
 @throws ClassCastException if the keys in <code>m</code> are not
 <code>Comparable</code>, or are not mutually comparable
 @throws NullPointerException if the specified map or any of its keys
 or values are null
 */
- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 @brief Constructs a new map containing the same mappings and using the
 same ordering as the specified sorted map.
 @param m the sorted map whose mappings are to be placed in this
 map, and whose comparator is to be used to sort this map
 @throws NullPointerException if the specified sorted map or any of
 its keys or values are null
 */
- (instancetype)initWithJavaUtilSortedMap:(id<JavaUtilSortedMap>)m;

/*!
 @brief Returns a key-value mapping associated with the least key
 greater than or equal to the given key, or <code>null</code> if
 there is no such entry.
 The returned entry does <em>not</em>
 support the <code>Entry.setValue</code> method.
 @throws ClassCastException
 @throws NullPointerException if the specified key is null
 */
- (id<JavaUtilMap_Entry>)ceilingEntryWithId:(id)key;

/*!
 @throws ClassCastException
 @throws NullPointerException if the specified key is null
 */
- (id)ceilingKeyWithId:(id)key;

/*!
 @brief Removes all of the mappings from this map.
 */
- (void)clear;

/*!
 @brief Returns a shallow copy of this <code>ConcurrentSkipListMap</code>
 instance.
 (The keys and values themselves are not cloned.)
 @return a shallow copy of this map
 */
- (JavaUtilConcurrentConcurrentSkipListMap *)clone;

- (id<JavaUtilComparator>)comparator;

/*!
 @brief Returns <code>true</code> if this map contains a mapping for the specified
 key.
 @param key key whose presence in this map is to be tested
 @return <code>true</code> if this map contains a mapping for the specified key
 @throws ClassCastException if the specified key cannot be compared
 with the keys currently in the map
 @throws NullPointerException if the specified key is null
 */
- (jboolean)containsKeyWithId:(id)key;

/*!
 @brief Returns <code>true</code> if this map maps one or more keys to the
 specified value.
 This operation requires time linear in the
 map size. Additionally, it is possible for the map to change
 during execution of this method, in which case the returned
 result may be inaccurate.
 @param value value whose presence in this map is to be tested
 @return <code>true</code> if a mapping to <code>value</code> exists;
 <code>false</code> otherwise
 @throws NullPointerException if the specified value is null
 */
- (jboolean)containsValueWithId:(id)value;

- (id<JavaUtilNavigableSet>)descendingKeySet;

- (id<JavaUtilConcurrentConcurrentNavigableMap>)descendingMap;

/*!
 @brief Returns a <code>Set</code> view of the mappings contained in this map.
 The set's iterator returns the entries in ascending key order.
 The set is backed by the map, so changes to the map are
 reflected in the set, and vice-versa.  The set supports element
 removal, which removes the corresponding mapping from the map,
 via the <code>Iterator.remove</code>, <code>Set.remove</code>,
 <code>removeAll</code>, <code>retainAll</code> and <code>clear</code>
 operations.  It does not support the <code>add</code> or
 <code>addAll</code> operations.
 <p>The view's <code>iterator</code> is a "weakly consistent" iterator
 that will never throw <code>ConcurrentModificationException</code>,
 and guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not guaranteed to)
 reflect any modifications subsequent to construction.
 <p>The <code>Map.Entry</code> elements returned by
 <code>iterator.next()</code> do <em>not</em> support the
 <code>setValue</code> operation.
 @return a set view of the mappings contained in this map,
 sorted in ascending key order
 */
- (id<JavaUtilSet>)entrySet;

/*!
 @brief Compares the specified object with this map for equality.
 Returns <code>true</code> if the given object is also a map and the
 two maps represent the same mappings.  More formally, two maps
 <code>m1</code> and <code>m2</code> represent the same mappings if
 <code>m1.entrySet().equals(m2.entrySet())</code>.  This
 operation may return misleading results if either map is
 concurrently modified during execution of this method.
 @param o object to be compared for equality with this map
 @return <code>true</code> if the specified object is equal to this map
 */
- (jboolean)isEqual:(id)o;

/*!
 @brief Returns a key-value mapping associated with the least
 key in this map, or <code>null</code> if the map is empty.
 The returned entry does <em>not</em> support
 the <code>Entry.setValue</code> method.
 */
- (id<JavaUtilMap_Entry>)firstEntry;

/*!
 @throws NoSuchElementException
 */
- (id)firstKey;

/*!
 @brief Returns a key-value mapping associated with the greatest key
 less than or equal to the given key, or <code>null</code> if there
 is no such key.
 The returned entry does <em>not</em> support
 the <code>Entry.setValue</code> method.
 @param key the key
 @throws ClassCastException
 @throws NullPointerException if the specified key is null
 */
- (id<JavaUtilMap_Entry>)floorEntryWithId:(id)key;

/*!
 @param key the key
 @throws ClassCastException
 @throws NullPointerException if the specified key is null
 */
- (id)floorKeyWithId:(id)key;

/*!
 @brief Returns the value to which the specified key is mapped,
 or <code>null</code> if this map contains no mapping for the key.
 <p>More formally, if this map contains a mapping from a key
 <code>k</code> to a value <code>v</code> such that <code>key</code> compares
 equal to <code>k</code> according to the map's ordering, then this
 method returns <code>v</code>; otherwise it returns <code>null</code>.
 (There can be at most one such mapping.)
 @throws ClassCastException if the specified key cannot be compared
 with the keys currently in the map
 @throws NullPointerException if the specified key is null
 */
- (id)getWithId:(id)key;

/*!
 @throws ClassCastException
 @throws NullPointerException if <code>toKey</code> is null
 @throws IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)headMapWithId:(id)toKey;

/*!
 @throws ClassCastException
 @throws NullPointerException if <code>toKey</code> is null
 @throws IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)headMapWithId:(id)toKey
                                                  withBoolean:(jboolean)inclusive;

/*!
 @brief Returns a key-value mapping associated with the least key
 strictly greater than the given key, or <code>null</code> if there
 is no such key.
 The returned entry does <em>not</em> support
 the <code>Entry.setValue</code> method.
 @param key the key
 @throws ClassCastException
 @throws NullPointerException if the specified key is null
 */
- (id<JavaUtilMap_Entry>)higherEntryWithId:(id)key;

/*!
 @param key the key
 @throws ClassCastException
 @throws NullPointerException if the specified key is null
 */
- (id)higherKeyWithId:(id)key;

/*!
 @brief Returns <code>true</code> if this map contains no key-value mappings.
 @return <code>true</code> if this map contains no key-value mappings
 */
- (jboolean)isEmpty;

/*!
 @brief Returns a <code>NavigableSet</code> view of the keys contained in this map.
 The set's iterator returns the keys in ascending order.
 The set is backed by the map, so changes to the map are
 reflected in the set, and vice-versa.  The set supports element
 removal, which removes the corresponding mapping from the map,
 via the <code>Iterator.remove</code>, <code>Set.remove</code>,
 <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code>
 operations.  It does not support the <code>add</code> or <code>addAll</code>
 operations.
 <p>The view's <code>iterator</code> is a "weakly consistent" iterator
 that will never throw <code>ConcurrentModificationException</code>,
 and guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not guaranteed to)
 reflect any modifications subsequent to construction.
 <p>This method is equivalent to method <code>navigableKeySet</code>.
 @return a navigable set view of the keys in this map
 */
- (id<JavaUtilNavigableSet>)keySet;

/*!
 @brief Returns a key-value mapping associated with the greatest
 key in this map, or <code>null</code> if the map is empty.
 The returned entry does <em>not</em> support
 the <code>Entry.setValue</code> method.
 */
- (id<JavaUtilMap_Entry>)lastEntry;

/*!
 @throws NoSuchElementException
 */
- (id)lastKey;

/*!
 @brief Returns a key-value mapping associated with the greatest key
 strictly less than the given key, or <code>null</code> if there is
 no such key.
 The returned entry does <em>not</em> support the
 <code>Entry.setValue</code> method.
 @throws ClassCastException
 @throws NullPointerException if the specified key is null
 */
- (id<JavaUtilMap_Entry>)lowerEntryWithId:(id)key;

/*!
 @throws ClassCastException
 @throws NullPointerException if the specified key is null
 */
- (id)lowerKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)navigableKeySet;

/*!
 @brief Removes and returns a key-value mapping associated with
 the least key in this map, or <code>null</code> if the map is empty.
 The returned entry does <em>not</em> support
 the <code>Entry.setValue</code> method.
 */
- (id<JavaUtilMap_Entry>)pollFirstEntry;

/*!
 @brief Removes and returns a key-value mapping associated with
 the greatest key in this map, or <code>null</code> if the map is empty.
 The returned entry does <em>not</em> support
 the <code>Entry.setValue</code> method.
 */
- (id<JavaUtilMap_Entry>)pollLastEntry;

/*!
 @brief Associates the specified value with the specified key in this map.
 If the map previously contained a mapping for the key, the old
 value is replaced.
 @param key key with which the specified value is to be associated
 @param value value to be associated with the specified key
 @return the previous value associated with the specified key, or
 <code>null</code> if there was no mapping for the key
 @throws ClassCastException if the specified key cannot be compared
 with the keys currently in the map
 @throws NullPointerException if the specified key or value is null
 */
- (id)putWithId:(id)key
         withId:(id)value;

/*!
 
 @return the previous value associated with the specified key,
 or <code>null</code> if there was no mapping for the key
 @throws ClassCastException if the specified key cannot be compared
 with the keys currently in the map
 @throws NullPointerException if the specified key or value is null
 */
- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

/*!
 @brief Removes the mapping for the specified key from this map if present.
 @param key key for which mapping should be removed
 @return the previous value associated with the specified key, or
 <code>null</code> if there was no mapping for the key
 @throws ClassCastException if the specified key cannot be compared
 with the keys currently in the map
 @throws NullPointerException if the specified key is null
 */
- (id)removeWithId:(id)key;

/*!
 
 @throws ClassCastException if the specified key cannot be compared
 with the keys currently in the map
 @throws NullPointerException if the specified key is null
 */
- (jboolean)removeWithId:(id)key
                  withId:(id)value;

/*!
 
 @return the previous value associated with the specified key,
 or <code>null</code> if there was no mapping for the key
 @throws ClassCastException if the specified key cannot be compared
 with the keys currently in the map
 @throws NullPointerException if the specified key or value is null
 */
- (id)replaceWithId:(id)key
             withId:(id)value;

/*!
 
 @throws ClassCastException if the specified key cannot be compared
 with the keys currently in the map
 @throws NullPointerException if any of the arguments are null
 */
- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

/*!
 @brief Returns the number of key-value mappings in this map.
 If this map
 contains more than <code>Integer.MAX_VALUE</code> elements, it
 returns <code>Integer.MAX_VALUE</code>.
 <p>Beware that, unlike in most collections, this method is
 <em>NOT</em> a constant-time operation. Because of the
 asynchronous nature of these maps, determining the current
 number of elements requires traversing them all to count them.
 Additionally, it is possible for the size to change during
 execution of this method, in which case the returned result
 will be inaccurate. Thus, this method is typically not very
 useful in concurrent applications.
 @return the number of elements in this map
 */
- (jint)size;

/*!
 @throws ClassCastException
 @throws NullPointerException if <code>fromKey</code> or <code>toKey</code> is null
 @throws IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)subMapWithId:(id)fromKey
                                                 withBoolean:(jboolean)fromInclusive
                                                      withId:(id)toKey
                                                 withBoolean:(jboolean)toInclusive;

/*!
 @throws ClassCastException
 @throws NullPointerException if <code>fromKey</code> or <code>toKey</code> is null
 @throws IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)subMapWithId:(id)fromKey
                                                      withId:(id)toKey;

/*!
 @throws ClassCastException
 @throws NullPointerException if <code>fromKey</code> is null
 @throws IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)tailMapWithId:(id)fromKey;

/*!
 @throws ClassCastException
 @throws NullPointerException if <code>fromKey</code> is null
 @throws IllegalArgumentException
 */
- (id<JavaUtilConcurrentConcurrentNavigableMap>)tailMapWithId:(id)fromKey
                                                  withBoolean:(jboolean)inclusive;

/*!
 @brief Returns a <code>Collection</code> view of the values contained in this map.
 The collection's iterator returns the values in ascending order
 of the corresponding keys.
 The collection is backed by the map, so changes to the map are
 reflected in the collection, and vice-versa.  The collection
 supports element removal, which removes the corresponding
 mapping from the map, via the <code>Iterator.remove</code>,
 <code>Collection.remove</code>, <code>removeAll</code>,
 <code>retainAll</code> and <code>clear</code> operations.  It does not
 support the <code>add</code> or <code>addAll</code> operations.
 <p>The view's <code>iterator</code> is a "weakly consistent" iterator
 that will never throw <code>ConcurrentModificationException</code>,
 and guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not guaranteed to)
 reflect any modifications subsequent to construction.
 */
- (id<JavaUtilCollection>)values;

#pragma mark Package-Private

/*!
 @brief Compares using comparator or natural ordering.
 Used when the
 ComparableUsingComparator approach doesn't apply.
 */
- (jint)compareWithId:(id)k1
               withId:(id)k2;

/*!
 @brief Main deletion method.
 Locates node, nulls value, appends a
 deletion marker, unlinks predecessor, removes associated index
 nodes, and possibly reduces head index level.
 Index nodes are cleared out simply by calling findPredecessor.
 which unlinks indexes to deleted nodes found along path to key,
 which will include the indexes to this node.  This is done
 unconditionally. We can't check beforehand whether there are
 index nodes because it might be the case that some or all
 indexes hadn't been inserted yet for this node during initial
 search for it, and we'd like to ensure lack of garbage
 retention, so must call to be sure.
 @param okey the key
 @param value if non-null, the value that must be
 associated with key
 @return the node, or null if not found
 */
- (id)doRemoveWithId:(id)okey
              withId:(id)value;

/*!
 @brief Removes first entry; returns its snapshot.
 @return null if empty, else snapshot of first entry
 */
- (id<JavaUtilMap_Entry>)doRemoveFirstEntry;

/*!
 @brief Removes last entry; returns its snapshot.
 Specialized variant of doRemove.
 @return null if empty, else snapshot of last entry
 */
- (id<JavaUtilMap_Entry>)doRemoveLastEntry;

- (id<JavaUtilIterator>)entryIterator;

/*!
 @brief Specialized variant of findNode to get first valid node.
 @return first node or null if empty
 */
- (JavaUtilConcurrentConcurrentSkipListMap_Node *)findFirst;

/*!
 @brief Specialized version of find to get last valid node.
 @return last node or null if empty
 */
- (JavaUtilConcurrentConcurrentSkipListMap_Node *)findLast;

/*!
 @brief Utility for ceiling, floor, lower, higher methods.
 @param kkey the key
 @param rel the relation -- OR'ed combination of EQ, LT, GT
 @return nearest node fitting relation, or null if no such
 */
- (JavaUtilConcurrentConcurrentSkipListMap_Node *)findNearWithId:(id)kkey
                                                         withInt:(jint)rel;

/*!
 @brief Returns SimpleImmutableEntry for results of findNear.
 @param key the key
 @param rel the relation -- OR'ed combination of EQ, LT, GT
 @return Entry fitting relation, or null if no such
 */
- (JavaUtilAbstractMap_SimpleImmutableEntry *)getNearWithId:(id)key
                                                    withInt:(jint)rel;

/*!
 @brief Returns true if given key greater than or equal to least and
 strictly less than fence, bypassing either test if least or
 fence are null.
 Needed mainly in submap operations.
 */
- (jboolean)inHalfOpenRangeWithId:(id)key
                           withId:(id)least
                           withId:(id)fence;

/*!
 @brief Initializes or resets state.
 Needed by constructors, clone,
 clear, readObject. and ConcurrentSkipListSet.clone.
 (Note that comparator must be separately initialized.)
 */
- (void)initialize__ OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns true if given key greater than or equal to least and less
 or equal to fence.
 Needed mainly in submap operations.
 */
- (jboolean)inOpenRangeWithId:(id)key
                       withId:(id)least
                       withId:(id)fence;

- (id<JavaUtilIterator>)keyIterator;

+ (id<JavaUtilList>)toListWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (id<JavaUtilIterator>)valueIterator;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_init(JavaUtilConcurrentConcurrentSkipListMap *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *new_JavaUtilConcurrentConcurrentSkipListMap_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilComparator_(JavaUtilConcurrentConcurrentSkipListMap *self, id<JavaUtilComparator> comparator);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *new_JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilComparator_(id<JavaUtilComparator> comparator) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilMap_(JavaUtilConcurrentConcurrentSkipListMap *self, id<JavaUtilMap> m);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *new_JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilMap_(id<JavaUtilMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilSortedMap_(JavaUtilConcurrentConcurrentSkipListMap *self, id<JavaUtilSortedMap> m);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap *new_JavaUtilConcurrentConcurrentSkipListMap_initWithJavaUtilSortedMap_(id<JavaUtilSortedMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilConcurrentConcurrentSkipListMap_toListWithJavaUtilCollection_(id<JavaUtilCollection> c);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_Node_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_Node_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_Node_

@class JavaUtilAbstractMap_SimpleImmutableEntry;

/*!
 @brief Nodes hold keys and values, and are singly linked in sorted
 order, possibly with some intervening marker nodes.
 The list is
 headed by a dummy node accessible as head.node. The value field
 is declared only as Object because it takes special non-V
 values for marker and header nodes.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_Node : NSObject {
 @public
  id key_;
  volatile_id value_;
  volatile_id next_;
}

#pragma mark Package-Private

/*!
 @brief Creates a new regular node.
 */
- (instancetype)initWithId:(id)key
                    withId:(id)value
withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)next;

/*!
 @brief Creates a new marker node.
 A marker is distinguished by
 having its value field point to itself.  Marker nodes also
 have null keys, a fact that is exploited in a few places,
 but this doesn't distinguish markers from the base-level
 header node (head.node), which also has a null key.
 */
- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)next;

/*!
 @brief Tries to append a deletion marker to this node.
 @param f the assumed current successor of this node
 @return true if successful
 */
- (jboolean)appendMarkerWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)f;

/*!
 @brief compareAndSet next field
 */
- (jboolean)casNextWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)cmp
                   withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)val;

/*!
 @brief compareAndSet value field
 */
- (jboolean)casValueWithId:(id)cmp
                    withId:(id)val;

/*!
 @brief Creates and returns a new SimpleImmutableEntry holding current
 mapping if this node holds a valid value, else null.
 @return new entry or null
 */
- (JavaUtilAbstractMap_SimpleImmutableEntry *)createSnapshot;

/*!
 @brief Returns value if this node contains a valid key-value pair,
 else null.
 @return this node's value if it isn't a marker or header or
 is deleted, else null
 */
- (id)getValidValue;

/*!
 @brief Helps out a deletion by appending marker or unlinking from
 predecessor.
 This is called during traversals when value
 field seen to be null.
 @param b predecessor
 @param f successor
 */
- (void)helpDeleteWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)b
                  withJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)f;

/*!
 @brief Returns true if this node is the header of base-level list.
 @return true if this node is header node
 */
- (jboolean)isBaseHeader;

/*!
 @brief Returns true if this node is a marker.
 This method isn't
 actually called in any current code checking for markers
 because callers will have already read value field and need
 to use that read (not another done here) and so directly
 test if value points to node.
 @return true if this node is a marker node
 */
- (jboolean)isMarker;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_Node)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Node, key_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Node, value_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Node, next_, JavaUtilConcurrentConcurrentSkipListMap_Node *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Node_initWithId_withId_withJavaUtilConcurrentConcurrentSkipListMap_Node_(JavaUtilConcurrentConcurrentSkipListMap_Node *self, id key, id value, JavaUtilConcurrentConcurrentSkipListMap_Node *next);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Node *new_JavaUtilConcurrentConcurrentSkipListMap_Node_initWithId_withId_withJavaUtilConcurrentConcurrentSkipListMap_Node_(id key, id value, JavaUtilConcurrentConcurrentSkipListMap_Node *next) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Node_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_(JavaUtilConcurrentConcurrentSkipListMap_Node *self, JavaUtilConcurrentConcurrentSkipListMap_Node *next);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Node *new_JavaUtilConcurrentConcurrentSkipListMap_Node_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_(JavaUtilConcurrentConcurrentSkipListMap_Node *next) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_Node)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_Index_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_Index_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_Index_

@class JavaUtilConcurrentConcurrentSkipListMap_Node;

/*!
 @brief Index nodes represent the levels of the skip list.
 Note that
 even though both Nodes and Indexes have forward-pointing
 fields, they have different types and are handled in different
 ways, that can't nicely be captured by placing field in a
 shared abstract class.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_Index : NSObject {
 @public
  JavaUtilConcurrentConcurrentSkipListMap_Node *node_;
  JavaUtilConcurrentConcurrentSkipListMap_Index *down_;
  volatile_id right_;
}

#pragma mark Package-Private

/*!
 @brief Creates index node with given values.
 */
- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)node
                   withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)down
                   withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)right;

/*!
 @brief compareAndSet right field
 */
- (jboolean)casRightWithJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)cmp
                    withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)val;

/*!
 @brief Returns true if the node this indexes has been deleted.
 @return true if indexed node is known to be deleted
 */
- (jboolean)indexesDeletedNode;

/*!
 @brief Tries to CAS newSucc as successor.
 To minimize races with
 unlink that may lose this index node, if the node being
 indexed is known to be deleted, it doesn't try to link in.
 @param succ the expected current successor
 @param newSucc the new successor
 @return true if successful
 */
- (jboolean)linkWithJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)succ
                withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)newSucc;

/*!
 @brief Tries to CAS right field to skip over apparent successor
 succ.
 Fails (forcing a retraversal by caller) if this node
 is known to be deleted.
 @param succ the expected current successor
 @return true if successful
 */
- (jboolean)unlinkWithJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)succ;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_Index)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Index, node_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Index, down_, JavaUtilConcurrentConcurrentSkipListMap_Index *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Index, right_, JavaUtilConcurrentConcurrentSkipListMap_Index *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Index_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_(JavaUtilConcurrentConcurrentSkipListMap_Index *self, JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Index *new_JavaUtilConcurrentConcurrentSkipListMap_Index_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_(JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_Index)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_

@class JavaUtilConcurrentConcurrentSkipListMap_Index;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;

/*!
 @brief Nodes heading each level keep track of their level.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_HeadIndex : JavaUtilConcurrentConcurrentSkipListMap_Index {
 @public
  jint level_;
}

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap_Node:(JavaUtilConcurrentConcurrentSkipListMap_Node *)node
                   withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)down
                   withJavaUtilConcurrentConcurrentSkipListMap_Index:(JavaUtilConcurrentConcurrentSkipListMap_Index *)right
                                                             withInt:(jint)level;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_HeadIndex)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_withInt_(JavaUtilConcurrentConcurrentSkipListMap_HeadIndex *self, JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right, jint level);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_HeadIndex *new_JavaUtilConcurrentConcurrentSkipListMap_HeadIndex_initWithJavaUtilConcurrentConcurrentSkipListMap_Node_withJavaUtilConcurrentConcurrentSkipListMap_Index_withJavaUtilConcurrentConcurrentSkipListMap_Index_withInt_(JavaUtilConcurrentConcurrentSkipListMap_Node *node, JavaUtilConcurrentConcurrentSkipListMap_Index *down, JavaUtilConcurrentConcurrentSkipListMap_Index *right, jint level) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_HeadIndex)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator_

#define JavaLangComparable_RESTRICT 1
#define JavaLangComparable_INCLUDE 1
#include "../../../java/lang/Comparable.h"

@protocol JavaUtilComparator;

/*!
 @brief Represents a key with a comparator as a Comparable.
 Because most sorted collections seem to use natural ordering on
 Comparables (Strings, Integers, etc), most internal methods are
 geared to use them. This is generally faster than checking
 per-comparison whether to use comparator or comparable because
 it doesn't require a (Comparable) cast for each comparison.
 (Optimizers can only sometimes remove such redundant checks
 themselves.) When Comparators are used,
 ComparableUsingComparators are created so that they act in the
 same way as natural orderings. This penalizes use of
 Comparators vs Comparables, which seems like the right
 tradeoff.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator : NSObject < JavaLangComparable > {
 @public
  id actualKey_;
  id<JavaUtilComparator> cmp_;
}

#pragma mark Public

- (jint)compareToWithId:(id)k2;

#pragma mark Package-Private

- (instancetype)initWithId:(id)key
    withJavaUtilComparator:(id<JavaUtilComparator>)cmp;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator, actualKey_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator, cmp_, id<JavaUtilComparator>)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator_initWithId_withJavaUtilComparator_(JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator *self, id key, id<JavaUtilComparator> cmp);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator *new_JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator_initWithId_withJavaUtilComparator_(id key, id<JavaUtilComparator> cmp) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_ComparableUsingComparator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_Iter_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_Iter_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_Iter_

#define JavaUtilIterator_RESTRICT 1
#define JavaUtilIterator_INCLUDE 1
#include "../../../java/util/Iterator.h"

@class JavaUtilConcurrentConcurrentSkipListMap;
@class JavaUtilConcurrentConcurrentSkipListMap_Node;

/*!
 @brief Base of iterator classes:
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_Iter : NSObject < JavaUtilIterator > {
 @public
  /*!
   @brief the last node returned by next()
   */
  JavaUtilConcurrentConcurrentSkipListMap_Node *lastReturned_;
  /*!
   @brief the next node to return from next();
   */
  JavaUtilConcurrentConcurrentSkipListMap_Node *next_;
  /*!
   @brief Cache of next value field to maintain weak consistency
   */
  id nextValue_;
}

#pragma mark Public

- (jboolean)hasNext;

- (void)remove;

#pragma mark Package-Private

/*!
 @brief Initializes ascending iterator for entire range.
 */
- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)outer$;

/*!
 @brief Advances next to higher entry.
 */
- (void)advance;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_Iter)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Iter, lastReturned_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Iter, next_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_Iter, nextValue_, id)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Iter_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap_Iter *self, JavaUtilConcurrentConcurrentSkipListMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_Iter)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_

@class JavaUtilConcurrentConcurrentSkipListMap;

@interface JavaUtilConcurrentConcurrentSkipListMap_ValueIterator : JavaUtilConcurrentConcurrentSkipListMap_Iter

#pragma mark Public

- (id)next;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_ValueIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap_ValueIterator *self, JavaUtilConcurrentConcurrentSkipListMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_ValueIterator *new_JavaUtilConcurrentConcurrentSkipListMap_ValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_ValueIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_

@class JavaUtilConcurrentConcurrentSkipListMap;

@interface JavaUtilConcurrentConcurrentSkipListMap_KeyIterator : JavaUtilConcurrentConcurrentSkipListMap_Iter

#pragma mark Public

- (id)next;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_KeyIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap_KeyIterator *self, JavaUtilConcurrentConcurrentSkipListMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_KeyIterator *new_JavaUtilConcurrentConcurrentSkipListMap_KeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_KeyIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_

@class JavaUtilConcurrentConcurrentSkipListMap;
@protocol JavaUtilMap_Entry;

@interface JavaUtilConcurrentConcurrentSkipListMap_EntryIterator : JavaUtilConcurrentConcurrentSkipListMap_Iter

#pragma mark Public

- (id<JavaUtilMap_Entry>)next;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_EntryIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap_EntryIterator *self, JavaUtilConcurrentConcurrentSkipListMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_EntryIterator *new_JavaUtilConcurrentConcurrentSkipListMap_EntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_(JavaUtilConcurrentConcurrentSkipListMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_EntryIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_KeySet_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_KeySet_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_KeySet_

#define JavaUtilAbstractSet_RESTRICT 1
#define JavaUtilAbstractSet_INCLUDE 1
#include "../../../java/util/AbstractSet.h"

#define JavaUtilNavigableSet_RESTRICT 1
#define JavaUtilNavigableSet_INCLUDE 1
#include "../../../java/util/NavigableSet.h"

@class IOSObjectArray;
@protocol JavaUtilComparator;
@protocol JavaUtilConcurrentConcurrentNavigableMap;
@protocol JavaUtilIterator;

@interface JavaUtilConcurrentConcurrentSkipListMap_KeySet : JavaUtilAbstractSet < JavaUtilNavigableSet >

#pragma mark Public

- (id)ceilingWithId:(id)e;

- (void)clear;

- (id<JavaUtilComparator>)comparator;

- (jboolean)containsWithId:(id)o;

- (id<JavaUtilIterator>)descendingIterator;

- (id<JavaUtilNavigableSet>)descendingSet;

- (jboolean)isEqual:(id)o;

- (id)first;

- (id)floorWithId:(id)e;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement;

- (id<JavaUtilNavigableSet>)headSetWithId:(id)toElement
                              withBoolean:(jboolean)inclusive;

- (id)higherWithId:(id)e;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (id)last;

- (id)lowerWithId:(id)e;

- (id)pollFirst;

- (id)pollLast;

- (jboolean)removeWithId:(id)o;

- (jint)size;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                             withBoolean:(jboolean)fromInclusive
                                  withId:(id)toElement
                             withBoolean:(jboolean)toInclusive;

- (id<JavaUtilNavigableSet>)subSetWithId:(id)fromElement
                                  withId:(id)toElement;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement;

- (id<JavaUtilNavigableSet>)tailSetWithId:(id)fromElement
                              withBoolean:(jboolean)inclusive;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentNavigableMap:(id<JavaUtilConcurrentConcurrentNavigableMap>)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_KeySet)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_KeySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(JavaUtilConcurrentConcurrentSkipListMap_KeySet *self, id<JavaUtilConcurrentConcurrentNavigableMap> map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_KeySet *new_JavaUtilConcurrentConcurrentSkipListMap_KeySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(id<JavaUtilConcurrentConcurrentNavigableMap> map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_KeySet)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_Values_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_Values_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_Values_

#define JavaUtilAbstractCollection_RESTRICT 1
#define JavaUtilAbstractCollection_INCLUDE 1
#include "../../../java/util/AbstractCollection.h"

@class IOSObjectArray;
@protocol JavaUtilConcurrentConcurrentNavigableMap;
@protocol JavaUtilIterator;

@interface JavaUtilConcurrentConcurrentSkipListMap_Values : JavaUtilAbstractCollection

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (jint)size;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentNavigableMap:(id<JavaUtilConcurrentConcurrentNavigableMap>)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_Values)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_Values_initWithJavaUtilConcurrentConcurrentNavigableMap_(JavaUtilConcurrentConcurrentSkipListMap_Values *self, id<JavaUtilConcurrentConcurrentNavigableMap> map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_Values *new_JavaUtilConcurrentConcurrentSkipListMap_Values_initWithJavaUtilConcurrentConcurrentNavigableMap_(id<JavaUtilConcurrentConcurrentNavigableMap> map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_Values)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_EntrySet_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_EntrySet_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_EntrySet_

#define JavaUtilAbstractSet_RESTRICT 1
#define JavaUtilAbstractSet_INCLUDE 1
#include "../../../java/util/AbstractSet.h"

@class IOSObjectArray;
@protocol JavaUtilConcurrentConcurrentNavigableMap;
@protocol JavaUtilIterator;

@interface JavaUtilConcurrentConcurrentSkipListMap_EntrySet : JavaUtilAbstractSet

#pragma mark Public

- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)isEqual:(id)o;

- (jboolean)isEmpty;

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

- (jint)size;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentNavigableMap:(id<JavaUtilConcurrentConcurrentNavigableMap>)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_EntrySet)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_EntrySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(JavaUtilConcurrentConcurrentSkipListMap_EntrySet *self, id<JavaUtilConcurrentConcurrentNavigableMap> map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_EntrySet *new_JavaUtilConcurrentConcurrentSkipListMap_EntrySet_initWithJavaUtilConcurrentConcurrentNavigableMap_(id<JavaUtilConcurrentConcurrentNavigableMap> map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_EntrySet)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_SubMap_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_

#define JavaUtilAbstractMap_RESTRICT 1
#define JavaUtilAbstractMap_INCLUDE 1
#include "../../../java/util/AbstractMap.h"

#define JavaUtilConcurrentConcurrentNavigableMap_RESTRICT 1
#define JavaUtilConcurrentConcurrentNavigableMap_INCLUDE 1
#include "../../../java/util/concurrent/ConcurrentNavigableMap.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../java/io/Serializable.h"

@class JavaUtilConcurrentConcurrentSkipListMap;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilIterator;
@protocol JavaUtilMap_Entry;
@protocol JavaUtilNavigableSet;
@protocol JavaUtilSet;

/*!
 @brief Submaps returned by <code>ConcurrentSkipListMap</code> submap operations
 represent a subrange of mappings of their underlying
 maps.
 Instances of this class support all methods of their
 underlying maps, differing in that mappings outside their range are
 ignored, and attempts to add mappings outside their ranges result
 in <code>IllegalArgumentException</code>.  Instances of this class are
 constructed only using the <code>subMap</code>, <code>headMap</code>, and
 <code>tailMap</code> methods of their underlying maps.
  include
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap : JavaUtilAbstractMap < JavaUtilConcurrentConcurrentNavigableMap, NSCopying, JavaIoSerializable >

#pragma mark Public

- (id<JavaUtilMap_Entry>)ceilingEntryWithId:(id)key;

- (id)ceilingKeyWithId:(id)key;

- (void)clear;

- (id<JavaUtilComparator>)comparator;

- (jboolean)containsKeyWithId:(id)key;

- (jboolean)containsValueWithId:(id)value;

- (id<JavaUtilNavigableSet>)descendingKeySet;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)descendingMap;

- (id<JavaUtilSet>)entrySet;

- (id<JavaUtilMap_Entry>)firstEntry;

- (id)firstKey;

- (id<JavaUtilMap_Entry>)floorEntryWithId:(id)key;

- (id)floorKeyWithId:(id)key;

- (id)getWithId:(id)key;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)headMapWithId:(id)toKey;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)headMapWithId:(id)toKey
                                                      withBoolean:(jboolean)inclusive;

- (id<JavaUtilMap_Entry>)higherEntryWithId:(id)key;

- (id)higherKeyWithId:(id)key;

- (jboolean)isEmpty;

- (id<JavaUtilNavigableSet>)keySet;

- (id<JavaUtilMap_Entry>)lastEntry;

- (id)lastKey;

- (id<JavaUtilMap_Entry>)lowerEntryWithId:(id)key;

- (id)lowerKeyWithId:(id)key;

- (id<JavaUtilNavigableSet>)navigableKeySet;

- (id<JavaUtilMap_Entry>)pollFirstEntry;

- (id<JavaUtilMap_Entry>)pollLastEntry;

- (id)putWithId:(id)key
         withId:(id)value;

- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

- (id)removeWithId:(id)key;

- (jboolean)removeWithId:(id)key
                  withId:(id)value;

- (id)replaceWithId:(id)key
             withId:(id)value;

- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

- (jint)size;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)subMapWithId:(id)fromKey
                                                     withBoolean:(jboolean)fromInclusive
                                                          withId:(id)toKey
                                                     withBoolean:(jboolean)toInclusive;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)subMapWithId:(id)fromKey
                                                          withId:(id)toKey;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)tailMapWithId:(id)fromKey;

- (JavaUtilConcurrentConcurrentSkipListMap_SubMap *)tailMapWithId:(id)fromKey
                                                      withBoolean:(jboolean)inclusive;

- (id<JavaUtilCollection>)values;

#pragma mark Package-Private

/*!
 @brief Creates a new submap, initializing all fields.
 */
- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap:(JavaUtilConcurrentConcurrentSkipListMap *)map
                                                         withId:(id)fromKey
                                                    withBoolean:(jboolean)fromInclusive
                                                         withId:(id)toKey
                                                    withBoolean:(jboolean)toInclusive
                                                    withBoolean:(jboolean)isDescending;

- (id<JavaUtilIterator>)entryIterator;

- (id<JavaUtilIterator>)keyIterator;

- (id<JavaUtilIterator>)valueIterator;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_initWithJavaUtilConcurrentConcurrentSkipListMap_withId_withBoolean_withId_withBoolean_withBoolean_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *self, JavaUtilConcurrentConcurrentSkipListMap *map, id fromKey, jboolean fromInclusive, id toKey, jboolean toInclusive, jboolean isDescending);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap *new_JavaUtilConcurrentConcurrentSkipListMap_SubMap_initWithJavaUtilConcurrentConcurrentSkipListMap_withId_withBoolean_withId_withBoolean_withBoolean_(JavaUtilConcurrentConcurrentSkipListMap *map, id fromKey, jboolean fromInclusive, id toKey, jboolean toInclusive, jboolean isDescending) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_

#define JavaUtilIterator_RESTRICT 1
#define JavaUtilIterator_INCLUDE 1
#include "../../../java/util/Iterator.h"

@class JavaUtilConcurrentConcurrentSkipListMap_Node;
@class JavaUtilConcurrentConcurrentSkipListMap_SubMap;

/*!
 @brief Variant of main Iter class to traverse through submaps.
 */
@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter : NSObject < JavaUtilIterator > {
 @public
  /*!
   @brief the last node returned by next()
   */
  JavaUtilConcurrentConcurrentSkipListMap_Node *lastReturned_;
  /*!
   @brief the next node to return from next();
   */
  JavaUtilConcurrentConcurrentSkipListMap_Node *next_;
  /*!
   @brief Cache of next value field to maintain weak consistency
   */
  id nextValue_;
}

#pragma mark Public

- (jboolean)hasNext;

- (void)remove;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap:(JavaUtilConcurrentConcurrentSkipListMap_SubMap *)outer$;

- (void)advance;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter, lastReturned_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter, next_, JavaUtilConcurrentConcurrentSkipListMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter, nextValue_, id)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter *self, JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_

@class JavaUtilConcurrentConcurrentSkipListMap_SubMap;

@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator : JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter

#pragma mark Public

- (id)next;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap:(JavaUtilConcurrentConcurrentSkipListMap_SubMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator *self, JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator *new_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapValueIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_

@class JavaUtilConcurrentConcurrentSkipListMap_SubMap;

@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator : JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter

#pragma mark Public

- (id)next;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap:(JavaUtilConcurrentConcurrentSkipListMap_SubMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator *self, JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator *new_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapKeyIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_) && (JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_

@class JavaUtilConcurrentConcurrentSkipListMap_SubMap;
@protocol JavaUtilMap_Entry;

@interface JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator : JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapIter

#pragma mark Public

- (id<JavaUtilMap_Entry>)next;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap:(JavaUtilConcurrentConcurrentSkipListMap_SubMap *)outer$;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator *self, JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator *new_JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator_initWithJavaUtilConcurrentConcurrentSkipListMap_SubMap_(JavaUtilConcurrentConcurrentSkipListMap_SubMap *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentSkipListMap_SubMap_SubMapEntryIterator)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaUtilConcurrentConcurrentSkipListMap_INCLUDE_ALL")

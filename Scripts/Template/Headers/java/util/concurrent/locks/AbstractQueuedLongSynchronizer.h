//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java
//

#include "../../../../J2ObjC_header.h"

#pragma push_macro("JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_INCLUDE_ALL")
#ifdef JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_RESTRICT
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_INCLUDE_ALL 0
#else
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_INCLUDE_ALL 1
#endif
#undef JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_) && (JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_INCLUDE_ALL || defined(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_INCLUDE))
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_

#define JavaUtilConcurrentLocksAbstractOwnableSynchronizer_RESTRICT 1
#define JavaUtilConcurrentLocksAbstractOwnableSynchronizer_INCLUDE 1
#include "../../../../java/util/concurrent/locks/AbstractOwnableSynchronizer.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../../java/io/Serializable.h"

@class JavaLangThread;
@class JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject;
@class JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node;
@protocol JavaUtilCollection;

/*!
 @brief A version of <code>AbstractQueuedSynchronizer</code> in
 which synchronization state is maintained as a <tt>long</tt>.
 This class has exactly the same structure, properties, and methods
 as <tt>AbstractQueuedSynchronizer</tt> with the exception
 that all state-related parameters and results are defined
 as <tt>long</tt> rather than <tt>int</tt>. This class
 may be useful when creating synchronizers such as
 multilevel locks and barriers that require
 64 bits of state.
 <p>See <code>AbstractQueuedSynchronizer</code> for usage
 notes and examples.
 @since 1.6
 @author Doug Lea
 */
@interface JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer : JavaUtilConcurrentLocksAbstractOwnableSynchronizer < JavaIoSerializable >

+ (jlong)spinForTimeoutThreshold;

#pragma mark Public

/*!
 @brief Acquires in exclusive mode, ignoring interrupts.
 Implemented
 by invoking at least once <code>tryAcquire</code>,
 returning on success.  Otherwise the thread is queued, possibly
 repeatedly blocking and unblocking, invoking <code>tryAcquire</code>
  until success.  This method can be used
 to implement method <code>Lock.lock</code>.
 @param arg the acquire argument.  This value is conveyed to
 <code>tryAcquire</code> but is otherwise uninterpreted and
 can represent anything you like.
 */
- (void)acquireWithLong:(jlong)arg;

/*!
 @brief Acquires in exclusive mode, aborting if interrupted.
 Implemented by first checking interrupt status, then invoking
 at least once <code>tryAcquire</code>, returning on
 success.  Otherwise the thread is queued, possibly repeatedly
 blocking and unblocking, invoking <code>tryAcquire</code>
 until success or the thread is interrupted.  This method can be
 used to implement method <code>Lock.lockInterruptibly</code>.
 @param arg the acquire argument.  This value is conveyed to
 <code>tryAcquire</code> but is otherwise uninterpreted and
 can represent anything you like.
 @throws InterruptedException if the current thread is interrupted
 */
- (void)acquireInterruptiblyWithLong:(jlong)arg;

/*!
 @brief Acquires in shared mode, ignoring interrupts.
 Implemented by
 first invoking at least once <code>tryAcquireShared</code>,
 returning on success.  Otherwise the thread is queued, possibly
 repeatedly blocking and unblocking, invoking <code>tryAcquireShared</code>
  until success.
 @param arg the acquire argument.  This value is conveyed to
 <code>tryAcquireShared</code> but is otherwise uninterpreted
 and can represent anything you like.
 */
- (void)acquireSharedWithLong:(jlong)arg;

/*!
 @brief Acquires in shared mode, aborting if interrupted.
 Implemented
 by first checking interrupt status, then invoking at least once
 <code>tryAcquireShared</code>, returning on success.  Otherwise the
 thread is queued, possibly repeatedly blocking and unblocking,
 invoking <code>tryAcquireShared</code> until success or the thread
 is interrupted.
 @param arg the acquire argument
 This value is conveyed to <code>tryAcquireShared</code> but is
 otherwise uninterpreted and can represent anything
 you like.
 @throws InterruptedException if the current thread is interrupted
 */
- (void)acquireSharedInterruptiblyWithLong:(jlong)arg;

/*!
 @brief Returns a collection containing threads that may be waiting to
 acquire in exclusive mode.
 This has the same properties
 as <code>getQueuedThreads</code> except that it only returns
 those threads waiting due to an exclusive acquire.
 @return the collection of threads
 */
- (id<JavaUtilCollection>)getExclusiveQueuedThreads;

/*!
 @brief Returns the first (longest-waiting) thread in the queue, or
 <code>null</code> if no threads are currently queued.
 <p>In this implementation, this operation normally returns in
 constant time, but may iterate upon contention if other threads are
 concurrently modifying the queue.
 @return the first (longest-waiting) thread in the queue, or
 <code>null</code> if no threads are currently queued
 */
- (JavaLangThread *)getFirstQueuedThread;

/*!
 @brief Returns a collection containing threads that may be waiting to
 acquire.
 Because the actual set of threads may change
 dynamically while constructing this result, the returned
 collection is only a best-effort estimate.  The elements of the
 returned collection are in no particular order.  This method is
 designed to facilitate construction of subclasses that provide
 more extensive monitoring facilities.
 @return the collection of threads
 */
- (id<JavaUtilCollection>)getQueuedThreads;

/*!
 @brief Returns an estimate of the number of threads waiting to
 acquire.
 The value is only an estimate because the number of
 threads may change dynamically while this method traverses
 internal data structures.  This method is designed for use in
 monitoring system state, not for synchronization
 control.
 @return the estimated number of threads waiting to acquire
 */
- (jint)getQueueLength;

/*!
 @brief Returns a collection containing threads that may be waiting to
 acquire in shared mode.
 This has the same properties
 as <code>getQueuedThreads</code> except that it only returns
 those threads waiting due to a shared acquire.
 @return the collection of threads
 */
- (id<JavaUtilCollection>)getSharedQueuedThreads;

/*!
 @brief Returns a collection containing those threads that may be
 waiting on the given condition associated with this
 synchronizer.
 Because the actual set of threads may change
 dynamically while constructing this result, the returned
 collection is only a best-effort estimate. The elements of the
 returned collection are in no particular order.
 @param condition the condition
 @return the collection of threads
 @throws IllegalMonitorStateException if exclusive synchronization
 is not held
 @throws IllegalArgumentException if the given condition is
 not associated with this synchronizer
 @throws NullPointerException if the condition is null
 */
- (id<JavaUtilCollection>)getWaitingThreadsWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject *)condition;

/*!
 @brief Returns an estimate of the number of threads waiting on the
 given condition associated with this synchronizer.
 Note that
 because timeouts and interrupts may occur at any time, the
 estimate serves only as an upper bound on the actual number of
 waiters.  This method is designed for use in monitoring of the
 system state, not for synchronization control.
 @param condition the condition
 @return the estimated number of waiting threads
 @throws IllegalMonitorStateException if exclusive synchronization
 is not held
 @throws IllegalArgumentException if the given condition is
 not associated with this synchronizer
 @throws NullPointerException if the condition is null
 */
- (jint)getWaitQueueLengthWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject *)condition;

/*!
 @brief Queries whether any threads have ever contended to acquire this
 synchronizer; that is if an acquire method has ever blocked.
 <p>In this implementation, this operation returns in
 constant time.
 @return <code>true</code> if there has ever been contention
 */
- (jboolean)hasContended;

/*!
 @brief Queries whether any threads are waiting to acquire.
 Note that
 because cancellations due to interrupts and timeouts may occur
 at any time, a <code>true</code> return does not guarantee that any
 other thread will ever acquire.
 <p>In this implementation, this operation returns in
 constant time.
 @return <code>true</code> if there may be other threads waiting to acquire
 */
- (jboolean)hasQueuedThreads;

/*!
 @brief Queries whether any threads are waiting on the given condition
 associated with this synchronizer.
 Note that because timeouts
 and interrupts may occur at any time, a <tt>true</tt> return
 does not guarantee that a future <tt>signal</tt> will awaken
 any threads.  This method is designed primarily for use in
 monitoring of the system state.
 @param condition the condition
 @return <tt>true</tt> if there are any waiting threads
 @throws IllegalMonitorStateException if exclusive synchronization
 is not held
 @throws IllegalArgumentException if the given condition is
 not associated with this synchronizer
 @throws NullPointerException if the condition is null
 */
- (jboolean)hasWaitersWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject *)condition;

/*!
 @brief Returns true if the given thread is currently queued.
 <p>This implementation traverses the queue to determine
 presence of the given thread.
 @param thread the thread
 @return <code>true</code> if the given thread is on the queue
 @throws NullPointerException if the thread is null
 */
- (jboolean)isQueuedWithJavaLangThread:(JavaLangThread *)thread;

/*!
 @brief Queries whether the given ConditionObject
 uses this synchronizer as its lock.
 @param condition the condition
 @return <tt>true</tt> if owned
 @throws NullPointerException if the condition is null
 */
- (jboolean)ownsWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject *)condition;

/*!
 @brief Releases in exclusive mode.
 Implemented by unblocking one or
 more threads if <code>tryRelease</code> returns true.
 This method can be used to implement method <code>Lock.unlock</code>.
 @param arg the release argument.  This value is conveyed to
 <code>tryRelease</code> but is otherwise uninterpreted and
 can represent anything you like.
 @return the value returned from <code>tryRelease</code>
 */
- (jboolean)release__WithLong:(jlong)arg;

/*!
 @brief Releases in shared mode.
 Implemented by unblocking one or more
 threads if <code>tryReleaseShared</code> returns true.
 @param arg the release argument.  This value is conveyed to
 <code>tryReleaseShared</code> but is otherwise uninterpreted
 and can represent anything you like.
 @return the value returned from <code>tryReleaseShared</code>
 */
- (jboolean)releaseSharedWithLong:(jlong)arg;

/*!
 @brief Returns a string identifying this synchronizer, as well as its state.
 The state, in brackets, includes the String <code>"State ="</code>
 followed by the current value of <code>getState</code>, and either
 <code>"nonempty"</code> or <code>"empty"</code> depending on whether the
 queue is empty.
 @return a string identifying this synchronizer, as well as its state
 */
- (NSString *)description;

/*!
 @brief Attempts to acquire in exclusive mode, aborting if interrupted,
 and failing if the given timeout elapses.
 Implemented by first
 checking interrupt status, then invoking at least once <code>tryAcquire</code>
 , returning on success.  Otherwise, the thread is
 queued, possibly repeatedly blocking and unblocking, invoking
 <code>tryAcquire</code> until success or the thread is interrupted
 or the timeout elapses.  This method can be used to implement
 method <code>Lock.tryLock(long,TimeUnit)</code>.
 @param arg the acquire argument.  This value is conveyed to
 <code>tryAcquire</code> but is otherwise uninterpreted and
 can represent anything you like.
 @param nanosTimeout the maximum number of nanoseconds to wait
 @return <code>true</code> if acquired; <code>false</code> if timed out
 @throws InterruptedException if the current thread is interrupted
 */
- (jboolean)tryAcquireNanosWithLong:(jlong)arg
                           withLong:(jlong)nanosTimeout;

/*!
 @brief Attempts to acquire in shared mode, aborting if interrupted, and
 failing if the given timeout elapses.
 Implemented by first
 checking interrupt status, then invoking at least once <code>tryAcquireShared</code>
 , returning on success.  Otherwise, the
 thread is queued, possibly repeatedly blocking and unblocking,
 invoking <code>tryAcquireShared</code> until success or the thread
 is interrupted or the timeout elapses.
 @param arg the acquire argument.  This value is conveyed to
 <code>tryAcquireShared</code> but is otherwise uninterpreted
 and can represent anything you like.
 @param nanosTimeout the maximum number of nanoseconds to wait
 @return <code>true</code> if acquired; <code>false</code> if timed out
 @throws InterruptedException if the current thread is interrupted
 */
- (jboolean)tryAcquireSharedNanosWithLong:(jlong)arg
                                 withLong:(jlong)nanosTimeout;

#pragma mark Protected

/*!
 @brief Creates a new <tt>AbstractQueuedLongSynchronizer</tt> instance
 with initial synchronization state of zero.
 */
- (instancetype)init;

/*!
 @brief Atomically sets synchronization state to the given updated
 value if the current state value equals the expected value.
 This operation has memory semantics of a <tt>volatile</tt> read
 and write.
 @param expect the expected value
 @param update the new value
 @return true if successful. False return indicates that the actual
 value was not equal to the expected value.
 */
- (jboolean)compareAndSetStateWithLong:(jlong)expect
                              withLong:(jlong)update;

/*!
 @brief Returns the current value of synchronization state.
 This operation has memory semantics of a <tt>volatile</tt> read.
 @return current state value
 */
- (jlong)getState;

/*!
 @brief Returns <code>true</code> if synchronization is held exclusively with
 respect to the current (calling) thread.
 This method is invoked
 upon each call to a non-waiting <code>ConditionObject</code> method.
 (Waiting methods instead invoke <code>release</code>.)
 <p>The default implementation throws <code>UnsupportedOperationException</code>
 . This method is invoked
 internally only within <code>ConditionObject</code> methods, so need
 not be defined if conditions are not used.
 @return <code>true</code> if synchronization is held exclusively;
 <code>false</code> otherwise
 @throws UnsupportedOperationException if conditions are not supported
 */
- (jboolean)isHeldExclusively;

/*!
 @brief Sets the value of synchronization state.
 This operation has memory semantics of a <tt>volatile</tt> write.
 @param newState the new state value
 */
- (void)setStateWithLong:(jlong)newState;

/*!
 @brief Attempts to acquire in exclusive mode.
 This method should query
 if the state of the object permits it to be acquired in the
 exclusive mode, and if so to acquire it.
 <p>This method is always invoked by the thread performing
 acquire.  If this method reports failure, the acquire method
 may queue the thread, if it is not already queued, until it is
 signalled by a release from some other thread. This can be used
 to implement method <code>Lock.tryLock()</code>.
 <p>The default
 implementation throws <code>UnsupportedOperationException</code>.
 @param arg the acquire argument. This value is always the one
 passed to an acquire method, or is the value saved on entry
 to a condition wait.  The value is otherwise uninterpreted
 and can represent anything you like.
 @return <code>true</code> if successful. Upon success, this object has
 been acquired.
 @throws IllegalMonitorStateException if acquiring would place this
 synchronizer in an illegal state. This exception must be
 thrown in a consistent fashion for synchronization to work
 correctly.
 @throws UnsupportedOperationException if exclusive mode is not supported
 */
- (jboolean)tryAcquireWithLong:(jlong)arg;

/*!
 @brief Attempts to acquire in shared mode.
 This method should query if
 the state of the object permits it to be acquired in the shared
 mode, and if so to acquire it.
 <p>This method is always invoked by the thread performing
 acquire.  If this method reports failure, the acquire method
 may queue the thread, if it is not already queued, until it is
 signalled by a release from some other thread.
 <p>The default implementation throws <code>UnsupportedOperationException</code>
 .
 @param arg the acquire argument. This value is always the one
 passed to an acquire method, or is the value saved on entry
 to a condition wait.  The value is otherwise uninterpreted
 and can represent anything you like.
 @return a negative value on failure; zero if acquisition in shared
 mode succeeded but no subsequent shared-mode acquire can
 succeed; and a positive value if acquisition in shared
 mode succeeded and subsequent shared-mode acquires might
 also succeed, in which case a subsequent waiting thread
 must check availability. (Support for three different
 return values enables this method to be used in contexts
 where acquires only sometimes act exclusively.)  Upon
 success, this object has been acquired.
 @throws IllegalMonitorStateException if acquiring would place this
 synchronizer in an illegal state. This exception must be
 thrown in a consistent fashion for synchronization to work
 correctly.
 @throws UnsupportedOperationException if shared mode is not supported
 */
- (jlong)tryAcquireSharedWithLong:(jlong)arg;

/*!
 @brief Attempts to set the state to reflect a release in exclusive
 mode.
 <p>This method is always invoked by the thread performing release.
 <p>The default implementation throws
 <code>UnsupportedOperationException</code>.
 @param arg the release argument. This value is always the one
 passed to a release method, or the current state value upon
 entry to a condition wait.  The value is otherwise
 uninterpreted and can represent anything you like.
 @return <code>true</code> if this object is now in a fully released
 state, so that any waiting threads may attempt to acquire;
 and <code>false</code> otherwise.
 @throws IllegalMonitorStateException if releasing would place this
 synchronizer in an illegal state. This exception must be
 thrown in a consistent fashion for synchronization to work
 correctly.
 @throws UnsupportedOperationException if exclusive mode is not supported
 */
- (jboolean)tryReleaseWithLong:(jlong)arg;

/*!
 @brief Attempts to set the state to reflect a release in shared mode.
 <p>This method is always invoked by the thread performing release.
 <p>The default implementation throws
 <code>UnsupportedOperationException</code>.
 @param arg the release argument. This value is always the one
 passed to a release method, or the current state value upon
 entry to a condition wait.  The value is otherwise
 uninterpreted and can represent anything you like.
 @return <code>true</code> if this release of shared mode may permit a
 waiting acquire (shared or exclusive) to succeed; and
 <code>false</code> otherwise
 @throws IllegalMonitorStateException if releasing would place this
 synchronizer in an illegal state. This exception must be
 thrown in a consistent fashion for synchronization to work
 correctly.
 @throws UnsupportedOperationException if shared mode is not supported
 */
- (jboolean)tryReleaseSharedWithLong:(jlong)arg;

#pragma mark Package-Private

/*!
 @brief Acquires in exclusive uninterruptible mode for thread already in
 queue.
 Used by condition wait methods as well as acquire.
 @param node the node
 @param arg the acquire argument
 @return <code>true</code> if interrupted while waiting
 */
- (jboolean)acquireQueuedWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)node
                                                                               withLong:(jlong)arg;

/*!
 @brief Returns <code>true</code> if the apparent first queued thread, if one
 exists, is waiting in exclusive mode.
 If this method returns
 <code>true</code>, and the current thread is attempting to acquire in
 shared mode (that is, this method is invoked from <code>tryAcquireShared</code>
 ) then it is guaranteed that the current thread
 is not the first queued thread.  Used only as a heuristic in
 ReentrantReadWriteLock.
 */
- (jboolean)apparentlyFirstQueuedIsExclusive;

/*!
 @brief Invokes release with current state value; returns saved state.
 Cancels node and throws exception on failure.
 @param node the condition node for this wait
 @return previous sync state
 */
- (jlong)fullyReleaseWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)node;

/*!
 @brief Queries whether any threads have been waiting to acquire longer
 than the current thread.
 <p>An invocation of this method is equivalent to (but may be
 more efficient than):
 @code
  getFirstQueuedThread() != Thread.currentThread() &&
  hasQueuedThreads()
 
@endcode
 <p>Note that because cancellations due to interrupts and
 timeouts may occur at any time, a <code>true</code> return does not
 guarantee that some other thread will acquire before the current
 thread.  Likewise, it is possible for another thread to win a
 race to enqueue after this method has returned <code>false</code>,
 due to the queue being empty.
 <p>This method is designed to be used by a fair synchronizer to
 avoid <a href="AbstractQueuedSynchronizer.html#barging">barging</a>.
 Such a synchronizer's <code>tryAcquire</code> method should return
 <code>false</code>, and its <code>tryAcquireShared</code> method should
 return a negative value, if this method returns <code>true</code>
 (unless this is a reentrant acquire).  For example, the <code>tryAcquire</code>
  method for a fair, reentrant, exclusive mode
 synchronizer might look like this:
 @code
 
  protected boolean tryAcquire(int arg) 
   if (isHeldExclusively()) {
     // A reentrant acquire; increment hold count
     return true;
   } else if (hasQueuedPredecessors()) {
     return false;
   } else {
     // try to acquire normally
   }
  
@endcode
 @return <code>true</code> if there is a queued thread preceding the
 current thread, and <code>false</code> if the current thread
 is at the head of the queue or the queue is empty
 @since 1.7
 */
- (jboolean)hasQueuedPredecessors;

/*!
 @brief Returns true if a node, always one that was initially placed on
 a condition queue, is now waiting to reacquire on sync queue.
 @param node the node
 @return true if is reacquiring
 */
- (jboolean)isOnSyncQueueWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)node;

/*!
 @brief Convenience method to interrupt current thread.
 */
+ (void)selfInterrupt;

/*!
 @brief Transfers node, if necessary, to sync queue after a cancelled
 wait.
 Returns true if thread was cancelled before being
 signalled.
 @param node its node
 @return true if cancelled before the node was signalled
 */
- (jboolean)transferAfterCancelledWaitWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)node;

/*!
 @brief Transfers a node from a condition queue onto sync queue.
 Returns true if successful.
 @param node the node
 @return true if successfully transferred (else the node was
 cancelled before signal).
 */
- (jboolean)transferForSignalWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)node;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer)

/*!
 @brief The number of nanoseconds for which it is faster to spin
 rather than to use timed park.
 A rough estimate suffices
 to improve responsiveness with very short timeouts.
 */
inline jlong JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_get_spinForTimeoutThreshold();
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_spinForTimeoutThreshold 1000LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer, spinForTimeoutThreshold, jlong)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_init(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer *self);

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_selfInterrupt();

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer)

#endif

#if !defined (JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_) && (JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_INCLUDE_ALL || defined(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_INCLUDE))
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_

@class JavaLangThread;

/*!
 @brief Wait queue node class.
 <p>The wait queue is a variant of a "CLH" (Craig, Landin, and
 Hagersten) lock queue. CLH locks are normally used for
 spinlocks.  We instead use them for blocking synchronizers, but
 use the same basic tactic of holding some of the control
 information about a thread in the predecessor of its node.  A
 "status" field in each node keeps track of whether a thread
 should block.  A node is signalled when its predecessor
 releases.  Each node of the queue otherwise serves as a
 specific-notification-style monitor holding a single waiting
 thread. The status field does NOT control whether threads are
 granted locks etc though.  A thread may try to acquire if it is
 first in the queue. But being first does not guarantee success;
 it only gives the right to contend.  So the currently released
 contender thread may need to rewait.
 <p>To enqueue into a CLH lock, you atomically splice it in as new
 tail. To dequeue, you just set the head field.
 @code

      +------+  prev +-----+       +-----+
  head |      | <---- |     | <---- |     |  tail
      +------+       +-----+       +-----+
  
@endcode
 <p>Insertion into a CLH queue requires only a single atomic
 operation on "tail", so there is a simple atomic point of
 demarcation from unqueued to queued. Similarly, dequeing
 involves only updating the "head". However, it takes a bit
 more work for nodes to determine who their successors are,
 in part to deal with possible cancellation due to timeouts
 and interrupts.
 <p>The "prev" links (not used in original CLH locks), are mainly
 needed to handle cancellation. If a node is cancelled, its
 successor is (normally) relinked to a non-cancelled
 predecessor. For explanation of similar mechanics in the case
 of spin locks, see the papers by Scott and Scherer at
 http://www.cs.rochester.edu/u/scott/synchronization/
 <p>We also use "next" links to implement blocking mechanics.
 The thread id for each node is kept in its own node, so a
 predecessor signals the next node to wake up by traversing
 next link to determine which thread it is.  Determination of
 successor must avoid races with newly queued nodes to set
 the "next" fields of their predecessors.  This is solved
 when necessary by checking backwards from the atomically
 updated "tail" when a node's successor appears to be null.
 (Or, said differently, the next-links are an optimization
 so that we don't usually need a backward scan.)
 <p>Cancellation introduces some conservatism to the basic
 algorithms.  Since we must poll for cancellation of other
 nodes, we can miss noticing whether a cancelled node is
 ahead or behind us. This is dealt with by always unparking
 successors upon cancellation, allowing them to stabilize on
 a new predecessor, unless we can identify an uncancelled
 predecessor who will carry this responsibility.
 <p>CLH queues need a dummy header node to get started. But
 we don't create them on construction, because it would be wasted
 effort if there is never contention. Instead, the node
 is constructed and head and tail pointers are set upon first
 contention.
 <p>Threads waiting on Conditions use the same nodes, but
 use an additional link. Conditions only need to link nodes
 in simple (non-concurrent) linked queues because they are
 only accessed when exclusively held.  Upon await, a node is
 inserted into a condition queue.  Upon signal, the node is
 transferred to the main queue.  A special value of status
 field is used to mark which queue a node is on.
 <p>Thanks go to Dave Dice, Mark Moir, Victor Luchangco, Bill
 Scherer and Michael Scott, along with members of JSR-166
 expert group, for helpful ideas, discussions, and critiques
 on the design of this class.
 */
@interface JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node : NSObject {
 @public
  /*!
   @brief Status field, taking on only the values:
 SIGNAL:     The successor of this node is (or will soon be)
 blocked (via park), so the current node must
 unpark its successor when it releases or
 cancels.
   To avoid races, acquire methods must
 first indicate they need a signal,
 then retry the atomic acquire, and then,
 on failure, block.
 CANCELLED:  This node is cancelled due to timeout or interrupt.
 Nodes never leave this state. In particular,
 a thread with cancelled node never again blocks.
 CONDITION:  This node is currently on a condition queue.
 It will not be used as a sync queue node
 until transferred, at which time the status
 will be set to 0. (Use of this value here has
 nothing to do with the other uses of the
 field, but simplifies mechanics.)
 PROPAGATE:  A releaseShared should be propagated to other
 nodes. This is set (for head node only) in
 doReleaseShared to ensure propagation
 continues, even if other operations have
 since intervened.
 0:          None of the above
 The values are arranged numerically to simplify use.
 Non-negative values mean that a node doesn't need to
 signal. So, most code doesn't need to check for particular
 values, just for sign.
 The field is initialized to 0 for normal sync nodes, and
 CONDITION for condition nodes.  It is modified using CAS
 (or when possible, unconditional volatile writes).
   */
  volatile_jint waitStatus_;
  /*!
   @brief Link to predecessor node that current node/thread relies on
 for checking waitStatus.
   Assigned during enqueing, and nulled
 out (for sake of GC) only upon dequeuing.  Also, upon
 cancellation of a predecessor, we short-circuit while
 finding a non-cancelled one, which will always exist
 because the head node is never cancelled: A node becomes
 head only as a result of successful acquire. A
 cancelled thread never succeeds in acquiring, and a thread only
 cancels itself, not any other node.
   */
  volatile_id prev_;
  /*!
   @brief Link to the successor node that the current node/thread
 unparks upon release.
   Assigned during enqueuing, adjusted
 when bypassing cancelled predecessors, and nulled out (for
 sake of GC) when dequeued.  The enq operation does not
 assign next field of a predecessor until after attachment,
 so seeing a null next field does not necessarily mean that
 node is at end of queue. However, if a next field appears
 to be null, we can scan prev's from the tail to
 double-check.  The next field of cancelled nodes is set to
 point to the node itself instead of null, to make life
 easier for isOnSyncQueue.
   */
  volatile_id next_;
  /*!
   @brief The thread that enqueued this node.
   Initialized on
 construction and nulled out after use.
   */
  volatile_id thread_;
  /*!
   @brief Link to next node waiting on condition, or the special
 value SHARED.
   Because condition queues are accessed only
 when holding in exclusive mode, we just need a simple
 linked queue to hold nodes while they are waiting on
 conditions. They are then transferred to the queue to
 re-acquire. And because conditions can only be exclusive,
 we save a field by using special value to indicate shared
 mode.
   */
  JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *nextWaiter_;
}

+ (JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)SHARED;

+ (JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)EXCLUSIVE;

+ (jint)CANCELLED;

+ (jint)SIGNAL;

+ (jint)CONDITION;

+ (jint)PROPAGATE;

#pragma mark Package-Private

- (instancetype)init;

- (instancetype)initWithJavaLangThread:(JavaLangThread *)thread
                               withInt:(jint)waitStatus;

- (instancetype)initWithJavaLangThread:(JavaLangThread *)thread
withJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)mode;

/*!
 @brief Returns true if node is waiting in shared mode
 */
- (jboolean)isShared;

/*!
 @brief Returns previous node, or throws NullPointerException if null.
 Use when predecessor cannot be null.  The null check could
 be elided, but is present to help the VM.
 @return the predecessor of this node
 */
- (JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)predecessor;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, prev_, JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, next_, JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, thread_, JavaLangThread *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, nextWaiter_, JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)

/*!
 @brief Marker to indicate a node is waiting in shared mode
 */
inline JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_get_SHARED();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_SHARED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, SHARED, JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)

/*!
 @brief Marker to indicate a node is waiting in exclusive mode
 */
inline JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_get_EXCLUSIVE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_EXCLUSIVE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, EXCLUSIVE, JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *)

/*!
 @brief waitStatus value to indicate thread has cancelled
 */
inline jint JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_get_CANCELLED();
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_CANCELLED 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, CANCELLED, jint)

/*!
 @brief waitStatus value to indicate successor's thread needs unparking
 */
inline jint JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_get_SIGNAL();
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_SIGNAL -1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, SIGNAL, jint)

/*!
 @brief waitStatus value to indicate thread is waiting on condition
 */
inline jint JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_get_CONDITION();
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_CONDITION -2
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, CONDITION, jint)

/*!
 @brief waitStatus value to indicate the next acquireShared should
 unconditionally propagate
 */
inline jint JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_get_PROPAGATE();
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_PROPAGATE -3
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node, PROPAGATE, jint)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_init(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *self);

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *new_JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_initWithJavaLangThread_withJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *self, JavaLangThread *thread, JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *mode);

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *new_JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_initWithJavaLangThread_withJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_(JavaLangThread *thread, JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *mode) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_initWithJavaLangThread_withInt_(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *self, JavaLangThread *thread, jint waitStatus);

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node *new_JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node_initWithJavaLangThread_withInt_(JavaLangThread *thread, jint waitStatus) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_Node)

#endif

#if !defined (JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject_) && (JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_INCLUDE_ALL || defined(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject_INCLUDE))
#define JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject_

#define JavaUtilConcurrentLocksCondition_RESTRICT 1
#define JavaUtilConcurrentLocksCondition_INCLUDE 1
#include "../../../../java/util/concurrent/locks/Condition.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../../java/io/Serializable.h"

@class JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer;
@class JavaUtilConcurrentTimeUnit;
@class JavaUtilDate;
@protocol JavaUtilCollection;

/*!
 @brief Condition implementation for a <code>AbstractQueuedLongSynchronizer</code>
  serving as the basis of a <code>Lock</code>
  implementation.
 <p>Method documentation for this class describes mechanics,
 not behavioral specifications from the point of view of Lock
 and Condition users. Exported versions of this class will in
 general need to be accompanied by documentation describing
 condition semantics that rely on those of the associated
 <tt>AbstractQueuedLongSynchronizer</tt>.
 <p>This class is Serializable, but all fields are transient,
 so deserialized conditions have no waiters.
 @since 1.6
 */
@interface JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject : NSObject < JavaUtilConcurrentLocksCondition, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Creates a new <tt>ConditionObject</tt> instance.
 */
- (instancetype)initWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer *)outer$;

/*!
 @brief Implements interruptible condition wait.
 <ol>
 <li> If current thread is interrupted, throw InterruptedException.
 <li> Save lock state returned by <code>getState</code>.
 <li> Invoke <code>release</code> with
 saved state as argument, throwing
 IllegalMonitorStateException if it fails.
 <li> Block until signalled or interrupted.
 <li> Reacquire by invoking specialized version of
 <code>acquire</code> with saved state as argument.
 <li> If interrupted while blocked in step 4, throw InterruptedException.
 </ol>
 */
- (void)await;

/*!
 @brief Implements timed condition wait.
 <ol>
 <li> If current thread is interrupted, throw InterruptedException.
 <li> Save lock state returned by <code>getState</code>.
 <li> Invoke <code>release</code> with
 saved state as argument, throwing
 IllegalMonitorStateException if it fails.
 <li> Block until signalled, interrupted, or timed out.
 <li> Reacquire by invoking specialized version of
 <code>acquire</code> with saved state as argument.
 <li> If interrupted while blocked in step 4, throw InterruptedException.
 <li> If timed out while blocked in step 4, return false, else true.
 </ol>
 */
- (jboolean)awaitWithLong:(jlong)time
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Implements timed condition wait.
 <ol>
 <li> If current thread is interrupted, throw InterruptedException.
 <li> Save lock state returned by <code>getState</code>.
 <li> Invoke <code>release</code> with
 saved state as argument, throwing
 IllegalMonitorStateException if it fails.
 <li> Block until signalled, interrupted, or timed out.
 <li> Reacquire by invoking specialized version of
 <code>acquire</code> with saved state as argument.
 <li> If interrupted while blocked in step 4, throw InterruptedException.
 </ol>
 */
- (jlong)awaitNanosWithLong:(jlong)nanosTimeout;

/*!
 @brief Implements uninterruptible condition wait.
 <ol>
 <li> Save lock state returned by <code>getState</code>.
 <li> Invoke <code>release</code> with
 saved state as argument, throwing
 IllegalMonitorStateException if it fails.
 <li> Block until signalled.
 <li> Reacquire by invoking specialized version of
 <code>acquire</code> with saved state as argument.
 </ol>
 */
- (void)awaitUninterruptibly;

/*!
 @brief Implements absolute timed condition wait.
 <ol>
 <li> If current thread is interrupted, throw InterruptedException.
 <li> Save lock state returned by <code>getState</code>.
 <li> Invoke <code>release</code> with
 saved state as argument, throwing
 IllegalMonitorStateException if it fails.
 <li> Block until signalled, interrupted, or timed out.
 <li> Reacquire by invoking specialized version of
 <code>acquire</code> with saved state as argument.
 <li> If interrupted while blocked in step 4, throw InterruptedException.
 <li> If timed out while blocked in step 4, return false, else true.
 </ol>
 */
- (jboolean)awaitUntilWithJavaUtilDate:(JavaUtilDate *)deadline;

/*!
 @brief Moves the longest-waiting thread, if one exists, from the
 wait queue for this condition to the wait queue for the
 owning lock.
 @throws IllegalMonitorStateException if <code>isHeldExclusively</code>
 returns <code>false</code>
 */
- (void)signal;

/*!
 @brief Moves all threads from the wait queue for this condition to
 the wait queue for the owning lock.
 @throws IllegalMonitorStateException if <code>isHeldExclusively</code>
 returns <code>false</code>
 */
- (void)signalAll;

#pragma mark Protected

/*!
 @brief Returns a collection containing those threads that may be
 waiting on this Condition.
 Implements <code>AbstractQueuedLongSynchronizer.getWaitingThreads</code>.
 @return the collection of threads
 @throws IllegalMonitorStateException if <code>isHeldExclusively</code>
 returns <code>false</code>
 */
- (id<JavaUtilCollection>)getWaitingThreads;

/*!
 @brief Returns an estimate of the number of threads waiting on
 this condition.
 Implements <code>AbstractQueuedLongSynchronizer.getWaitQueueLength</code>.
 @return the estimated number of waiting threads
 @throws IllegalMonitorStateException if <code>isHeldExclusively</code>
 returns <code>false</code>
 */
- (jint)getWaitQueueLength;

/*!
 @brief Queries whether any threads are waiting on this condition.
 Implements <code>AbstractQueuedLongSynchronizer.hasWaiters</code>.
 @return <code>true</code> if there are any waiting threads
 @throws IllegalMonitorStateException if <code>isHeldExclusively</code>
 returns <code>false</code>
 */
- (jboolean)hasWaiters;

#pragma mark Package-Private

/*!
 @brief Returns true if this condition was created by the given
 synchronization object.
 @return <code>true</code> if owned
 */
- (jboolean)isOwnedByWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer:(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer *)sync;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject)

FOUNDATION_EXPORT void JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject_initWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject *self, JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer *outer$);

FOUNDATION_EXPORT JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject *new_JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject_initWithJavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer *outer$) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_ConditionObject)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaUtilConcurrentLocksAbstractQueuedLongSynchronizer_INCLUDE_ALL")

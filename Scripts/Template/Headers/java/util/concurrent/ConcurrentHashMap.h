//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/concurrent/ConcurrentHashMap.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL")
#ifdef JavaUtilConcurrentConcurrentHashMap_RESTRICT
#define JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL 0
#else
#define JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL 1
#endif
#undef JavaUtilConcurrentConcurrentHashMap_RESTRICT
#ifdef JavaUtilConcurrentConcurrentHashMap_EntrySetView_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_CollectionView_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_ValuesView_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_CollectionView_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_KeySetView_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_CollectionView_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_EntryIterator_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_BaseIterator_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_ValueIterator_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_BaseIterator_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_KeyIterator_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_BaseIterator_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_BaseIterator_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_Traverser_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_TreeBin_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_Node_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_TreeNode_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_Node_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_ReservationNode_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_Node_INCLUDE 1
#endif
#ifdef JavaUtilConcurrentConcurrentHashMap_ForwardingNode_INCLUDE
#define JavaUtilConcurrentConcurrentHashMap_Node_INCLUDE 1
#endif

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilConcurrentConcurrentHashMap_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_

#define JavaUtilAbstractMap_RESTRICT 1
#define JavaUtilAbstractMap_INCLUDE 1
#include "../../../java/util/AbstractMap.h"

#define JavaUtilConcurrentConcurrentMap_RESTRICT 1
#define JavaUtilConcurrentConcurrentMap_INCLUDE 1
#include "../../../java/util/concurrent/ConcurrentMap.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../java/io/Serializable.h"

@class IOSClass;
@class IOSObjectArray;
@class JavaLangThreadLocal;
@class JavaUtilConcurrentAtomicAtomicInteger;
@class JavaUtilConcurrentConcurrentHashMap_KeySetView;
@class JavaUtilConcurrentConcurrentHashMap_Node;
@protocol JavaUtilCollection;
@protocol JavaUtilEnumeration;
@protocol JavaUtilMap;
@protocol JavaUtilSet;

/*!
 @brief A hash table supporting full concurrency of retrievals and
 high expected concurrency for updates.
 This class obeys the
 same functional specification as <code>java.util.Hashtable</code>, and
 includes versions of methods corresponding to each method of
 <code>Hashtable</code>. However, even though all operations are
 thread-safe, retrieval operations do <em>not</em> entail locking,
 and there is <em>not</em> any support for locking the entire table
 in a way that prevents all access.  This class is fully
 interoperable with <code>Hashtable</code> in programs that rely on its
 thread safety but not on its synchronization details.
 <p>Retrieval operations (including <code>get</code>) generally do not
 block, so may overlap with update operations (including <code>put</code>
 and <code>remove</code>). Retrievals reflect the results of the most
 recently <em>completed</em> update operations holding upon their
 onset. (More formally, an update operation for a given key bears a
 <em>happens-before</em> relation with any (non-null) retrieval for
 that key reporting the updated value.)  For aggregate operations
 such as <code>putAll</code> and <code>clear</code>, concurrent retrievals may
 reflect insertion or removal of only some entries.  Similarly,
 Iterators and Enumerations return elements reflecting the state of
 the hash table at some point at or since the creation of the
 iterator/enumeration.  They do <em>not</em> throw <code>ConcurrentModificationException</code>
 .  However, iterators are designed
 to be used by only one thread at a time.  Bear in mind that the
 results of aggregate status methods including <code>size</code>, <code>isEmpty</code>
 , and <code>containsValue</code> are typically useful only when
 a map is not undergoing concurrent updates in other threads.
 Otherwise the results of these methods reflect transient states
 that may be adequate for monitoring or estimation purposes, but not
 for program control.
 <p>The table is dynamically expanded when there are too many
 collisions (i.e., keys that have distinct hash codes but fall into
 the same slot modulo the table size), with the expected average
 effect of maintaining roughly two bins per mapping (corresponding
 to a 0.75 load factor threshold for resizing). There may be much
 variance around this average as mappings are added and removed, but
 overall, this maintains a commonly accepted time/space tradeoff for
 hash tables.  However, resizing this or any other kind of hash
 table may be a relatively slow operation. When possible, it is a
 good idea to provide a size estimate as an optional <code>initialCapacity</code>
  constructor argument. An additional optional
 <code>loadFactor</code> constructor argument provides a further means of
 customizing initial table capacity by specifying the table density
 to be used in calculating the amount of space to allocate for the
 given number of elements.  Also, for compatibility with previous
 versions of this class, constructors may optionally specify an
 expected <code>concurrencyLevel</code> as an additional hint for
 internal sizing.  Note that using many keys with exactly the same
 <code>hashCode()</code> is a sure way to slow down performance of any
 hash table. To ameliorate impact, when keys are <code>Comparable</code>,
 this class may use comparison order among keys to help break ties.
 <p>This class and its views and iterators implement all of the
 <em>optional</em> methods of the <code>Map</code> and <code>Iterator</code>
 interfaces.
 <p>Like <code>Hashtable</code> but unlike <code>HashMap</code>, this class
 does <em>not</em> allow <code>null</code> to be used as a key or value.
 @since 1.5
 @author Doug Lea
 */
@interface JavaUtilConcurrentConcurrentHashMap : JavaUtilAbstractMap < JavaUtilConcurrentConcurrentMap, JavaIoSerializable > {
 @public
  /*!
   @brief The array of bins.
   Lazily initialized upon first insertion.
 Size is always a power of two. Accessed directly by iterators.
   */
  volatile_id table_;
}

+ (jint)MAX_ARRAY_SIZE;

+ (jint)TREEIFY_THRESHOLD;

+ (jint)UNTREEIFY_THRESHOLD;

+ (jint)MIN_TREEIFY_CAPACITY;

+ (jint)MOVED;

+ (jint)TREEBIN;

+ (jint)RESERVED;

+ (jint)HASH_BITS;

+ (jint)NCPU;

+ (JavaUtilConcurrentAtomicAtomicInteger *)counterHashCodeGenerator;

+ (jint)SEED_INCREMENT;

+ (JavaLangThreadLocal *)threadCounterHashCode;

#pragma mark Public

/*!
 @brief Creates a new, empty map with the default initial table size (16).
 */
- (instancetype)init;

/*!
 @brief Creates a new, empty map with an initial table size
 accommodating the specified number of elements without the need
 to dynamically resize.
 @param initialCapacity The implementation performs internal
 sizing to accommodate this many elements.
 @throws IllegalArgumentException if the initial capacity of
 elements is negative
 */
- (instancetype)initWithInt:(jint)initialCapacity;

/*!
 @brief Creates a new, empty map with an initial table size based on
 the given number of elements (<code>initialCapacity</code>) and
 initial table density (<code>loadFactor</code>).
 @param initialCapacity the initial capacity. The implementation
 performs internal sizing to accommodate this many elements,
 given the specified load factor.
 @param loadFactor the load factor (table density) for
 establishing the initial table size
 @throws IllegalArgumentException if the initial capacity of
 elements is negative or the load factor is nonpositive
 @since 1.6
 */
- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor;

/*!
 @brief Creates a new, empty map with an initial table size based on
 the given number of elements (<code>initialCapacity</code>), table
 density (<code>loadFactor</code>), and number of concurrently
 updating threads (<code>concurrencyLevel</code>).
 @param initialCapacity the initial capacity. The implementation
 performs internal sizing to accommodate this many elements,
 given the specified load factor.
 @param loadFactor the load factor (table density) for
 establishing the initial table size
 @param concurrencyLevel the estimated number of concurrently
 updating threads. The implementation may use this value as
 a sizing hint.
 @throws IllegalArgumentException if the initial capacity is
 negative or the load factor or concurrencyLevel are
 nonpositive
 */
- (instancetype)initWithInt:(jint)initialCapacity
                  withFloat:(jfloat)loadFactor
                    withInt:(jint)concurrencyLevel;

/*!
 @brief Creates a new map with the same mappings as the given map.
 @param m the map
 */
- (instancetype)initWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 @brief Removes all of the mappings from this map.
 */
- (void)clear;

/*!
 @brief Legacy method testing if some key maps into the specified value
 in this table.
 This method is identical in functionality to
 <code>containsValue(Object)</code>, and exists solely to ensure
 full compatibility with class <code>java.util.Hashtable</code>,
 which supported this method prior to introduction of the
 Java Collections framework.
 @param value a value to search for
 @return <code>true</code> if and only if some key maps to the
 <code>value</code> argument in this table as
 determined by the <code>equals</code> method;
 <code>false</code> otherwise
 @throws NullPointerException if the specified value is null
 */
- (jboolean)containsWithId:(id)value;

/*!
 @brief Tests if the specified object is a key in this table.
 @param key possible key
 @return <code>true</code> if and only if the specified object
 is a key in this table, as determined by the
 <code>equals</code> method; <code>false</code> otherwise
 @throws NullPointerException if the specified key is null
 */
- (jboolean)containsKeyWithId:(id)key;

/*!
 @brief Returns <code>true</code> if this map maps one or more keys to the
 specified value.
 Note: This method may require a full traversal
 of the map, and is much slower than method <code>containsKey</code>.
 @param value value whose presence in this map is to be tested
 @return <code>true</code> if this map maps one or more keys to the
 specified value
 @throws NullPointerException if the specified value is null
 */
- (jboolean)containsValueWithId:(id)value;

/*!
 @brief Returns an enumeration of the values in this table.
 @return an enumeration of the values in this table
 - seealso: #values()
 */
- (id<JavaUtilEnumeration>)elements;

/*!
 @brief Returns a <code>Set</code> view of the mappings contained in this map.
 The set is backed by the map, so changes to the map are
 reflected in the set, and vice-versa.  The set supports element
 removal, which removes the corresponding mapping from the map,
 via the <code>Iterator.remove</code>, <code>Set.remove</code>,
 <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code>
 operations.
 <p>The view's <code>iterator</code> is a "weakly consistent" iterator
 that will never throw <code>ConcurrentModificationException</code>,
 and guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not guaranteed to)
 reflect any modifications subsequent to construction.
 @return the set view
 */
- (id<JavaUtilSet>)entrySet;

/*!
 @brief Compares the specified object with this map for equality.
 Returns <code>true</code> if the given object is a map with the same
 mappings as this map.  This operation may return misleading
 results if either map is concurrently modified during execution
 of this method.
 @param o object to be compared for equality with this map
 @return <code>true</code> if the specified object is equal to this map
 */
- (jboolean)isEqual:(id)o;

/*!
 @brief Returns the value to which the specified key is mapped,
 or <code>null</code> if this map contains no mapping for the key.
 <p>More formally, if this map contains a mapping from a key
 <code>k</code> to a value <code>v</code> such that <code>key.equals(k)</code>,
 then this method returns <code>v</code>; otherwise it returns
 <code>null</code>.  (There can be at most one such mapping.)
 @throws NullPointerException if the specified key is null
 */
- (id)getWithId:(id)key;

/*!
 @brief Returns the hash code value for this <code>Map</code>, i.e.,
 the sum of, for each key-value pair in the map,
 <code>key.hashCode() ^ value.hashCode()</code>.
 @return the hash code value for this map
 */
- (NSUInteger)hash;

/*!
 
 */
- (jboolean)isEmpty;

/*!
 @brief Returns an enumeration of the keys in this table.
 @return an enumeration of the keys in this table
 - seealso: #keySet()
 */
- (id<JavaUtilEnumeration>)keys;

/*!
 @brief Returns a <code>Set</code> view of the keys contained in this map.
 The set is backed by the map, so changes to the map are
 reflected in the set, and vice-versa. The set supports element
 removal, which removes the corresponding mapping from this map,
 via the <code>Iterator.remove</code>, <code>Set.remove</code>,
 <code>removeAll</code>, <code>retainAll</code>, and <code>clear</code>
 operations.  It does not support the <code>add</code> or
 <code>addAll</code> operations.
 <p>The view's <code>iterator</code> is a "weakly consistent" iterator
 that will never throw <code>ConcurrentModificationException</code>,
 and guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not guaranteed to)
 reflect any modifications subsequent to construction.
 @return the set view
 */
- (id<JavaUtilSet>)keySet;

/*!
 @brief Returns a <code>Set</code> view of the keys in this map, using the
 given common mapped value for any additions (i.e., <code>Collection.add</code>
  and <code>Collection.addAll(Collection)</code>).
 This is of course only appropriate if it is acceptable to use
 the same value for all additions from this view.
 @param mappedValue the mapped value to use for any additions
 @return the set view
 @throws NullPointerException if the mappedValue is null
 */
- (JavaUtilConcurrentConcurrentHashMap_KeySetView *)keySetWithId:(id)mappedValue;

/*!
 @brief Returns the number of mappings.
 This method should be used
 instead of <code>size</code> because a ConcurrentHashMap may
 contain more mappings than can be represented as an int. The
 value returned is an estimate; the actual count may differ if
 there are concurrent insertions or removals.
 @return the number of mappings
 @since 1.8
 */
- (jlong)mappingCount;

/*!
 @brief Creates a new <code>Set</code> backed by a ConcurrentHashMap
 from the given type to <code>Boolean.TRUE</code>.
 @return the new set
 @since 1.8
 */
+ (JavaUtilConcurrentConcurrentHashMap_KeySetView *)newKeySet OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a new <code>Set</code> backed by a ConcurrentHashMap
 from the given type to <code>Boolean.TRUE</code>.
 @param initialCapacity The implementation performs internal
 sizing to accommodate this many elements.
 @return the new set
 @throws IllegalArgumentException if the initial capacity of
 elements is negative
 @since 1.8
 */
+ (JavaUtilConcurrentConcurrentHashMap_KeySetView *)newKeySetWithInt:(jint)initialCapacity OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Maps the specified key to the specified value in this table.
 Neither the key nor the value can be null.
 <p>The value can be retrieved by calling the <code>get</code> method
 with a key that is equal to the original key.
 @param key key with which the specified value is to be associated
 @param value value to be associated with the specified key
 @return the previous value associated with <code>key</code>, or
 <code>null</code> if there was no mapping for <code>key</code>
 @throws NullPointerException if the specified key or value is null
 */
- (id)putWithId:(id)key
         withId:(id)value;

/*!
 @brief Copies all of the mappings from the specified map to this one.
 These mappings replace any mappings that this map had for any of the
 keys currently in the specified map.
 @param m mappings to be stored in this map
 */
- (void)putAllWithJavaUtilMap:(id<JavaUtilMap>)m;

/*!
 
 @return the previous value associated with the specified key,
 or <code>null</code> if there was no mapping for the key
 @throws NullPointerException if the specified key or value is null
 */
- (id)putIfAbsentWithId:(id)key
                 withId:(id)value;

/*!
 @brief Removes the key (and its corresponding value) from this map.
 This method does nothing if the key is not in the map.
 @param key the key that needs to be removed
 @return the previous value associated with <code>key</code>, or
 <code>null</code> if there was no mapping for <code>key</code>
 @throws NullPointerException if the specified key is null
 */
- (id)removeWithId:(id)key;

/*!
 
 @throws NullPointerException if the specified key is null
 */
- (jboolean)removeWithId:(id)key
                  withId:(id)value;

/*!
 
 @return the previous value associated with the specified key,
 or <code>null</code> if there was no mapping for the key
 @throws NullPointerException if the specified key or value is null
 */
- (id)replaceWithId:(id)key
             withId:(id)value;

/*!
 
 @throws NullPointerException if any of the arguments are null
 */
- (jboolean)replaceWithId:(id)key
                   withId:(id)oldValue
                   withId:(id)newValue;

/*!
 
 */
- (jint)size;

/*!
 @brief Returns a string representation of this map.
 The string
 representation consists of a list of key-value mappings (in no
 particular order) enclosed in braces ("<code></code> ").  Adjacent
 mappings are separated by the characters <code>", "</code> (comma
 and space).  Each key-value mapping is rendered as the key
 followed by an equals sign ("<code>=</code>") followed by the
 associated value.
 @return a string representation of this map
 */
- (NSString *)description;

/*!
 @brief Returns a <code>Collection</code> view of the values contained in this map.
 The collection is backed by the map, so changes to the map are
 reflected in the collection, and vice-versa.  The collection
 supports element removal, which removes the corresponding
 mapping from this map, via the <code>Iterator.remove</code>,
 <code>Collection.remove</code>, <code>removeAll</code>,
 <code>retainAll</code>, and <code>clear</code> operations.  It does not
 support the <code>add</code> or <code>addAll</code> operations.
 <p>The view's <code>iterator</code> is a "weakly consistent" iterator
 that will never throw <code>ConcurrentModificationException</code>,
 and guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not guaranteed to)
 reflect any modifications subsequent to construction.
 @return the collection view
 */
- (id<JavaUtilCollection>)values;

#pragma mark Package-Private

+ (jboolean)casTabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                              withInt:(jint)i
                         withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)c
                         withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)v;

/*!
 @brief Returns x's Class if it is of the form "class C implements
 Comparable<C>", else null.
 */
+ (IOSClass *)comparableClassForWithId:(id)x;

/*!
 @brief Returns k.compareTo(x) if x matches kc (k's screened comparable
 class), else 0.
 */
+ (jint)compareComparablesWithIOSClass:(IOSClass *)kc
                                withId:(id)k
                                withId:(id)x;

/*!
 @brief Helps transfer if a resize is in progress.
 */
- (IOSObjectArray *)helpTransferWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                     withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)f;

/*!
 @brief Implementation for put and putIfAbsent
 */
- (id)putValWithId:(id)key
            withId:(id)value
       withBoolean:(jboolean)onlyIfAbsent;

/*!
 @brief Implementation for the four public remove/replace methods:
 Replaces node value with v, conditional upon match of cv if
 non-null.
 If resulting value is null, delete.
 */
- (id)replaceNodeWithId:(id)key
                 withId:(id)value
                 withId:(id)cv;

/*!
 @brief Returns the stamp bits for resizing a table of size n.
 Must be negative when shifted left by RESIZE_STAMP_SHIFT.
 */
+ (jint)resizeStampWithInt:(jint)n;

+ (void)setTabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                          withInt:(jint)i
                     withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)v;

/*!
 @brief Spreads (XORs) higher bits of hash to lower and also forces top
 bit to 0.
 Because the table uses power-of-two masking, sets of
 hashes that vary only in bits above the current mask will
 always collide. (Among known examples are sets of Float keys
 holding consecutive whole numbers in small tables.)  So we
 apply a transform that spreads the impact of higher bits
 downward. There is a tradeoff between speed, utility, and
 quality of bit-spreading. Because many common sets of hashes
 are already reasonably distributed (so don't benefit from
 spreading), and because we use trees to handle large sets of
 collisions in bins, we just XOR some shifted bits in the
 cheapest possible way to reduce systematic lossage, as well as
 to incorporate impact of the highest bits that would otherwise
 never be used in index calculations because of table bounds.
 */
+ (jint)spreadWithInt:(jint)h;

- (jlong)sumCount;

+ (JavaUtilConcurrentConcurrentHashMap_Node *)tabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                                                             withInt:(jint)i;

/*!
 @brief Returns a list on non-TreeNodes replacing those in given list.
 */
+ (JavaUtilConcurrentConcurrentHashMap_Node *)untreeifyWithJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)b;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap)

J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap, table_, IOSObjectArray *)

/*!
 @brief The largest possible (non-power of two) array size.
 Needed by toArray and related methods.
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_MAX_ARRAY_SIZE();
#define JavaUtilConcurrentConcurrentHashMap_MAX_ARRAY_SIZE 2147483639
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, MAX_ARRAY_SIZE, jint)

/*!
 @brief The bin count threshold for using a tree rather than list for a
 bin.
 Bins are converted to trees when adding an element to a
 bin with at least this many nodes. The value must be greater
 than 2, and should be at least 8 to mesh with assumptions in
 tree removal about conversion back to plain bins upon
 shrinkage.
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_TREEIFY_THRESHOLD();
#define JavaUtilConcurrentConcurrentHashMap_TREEIFY_THRESHOLD 8
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, TREEIFY_THRESHOLD, jint)

/*!
 @brief The bin count threshold for untreeifying a (split) bin during a
 resize operation.
 Should be less than TREEIFY_THRESHOLD, and at
 most 6 to mesh with shrinkage detection under removal.
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_UNTREEIFY_THRESHOLD();
#define JavaUtilConcurrentConcurrentHashMap_UNTREEIFY_THRESHOLD 6
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, UNTREEIFY_THRESHOLD, jint)

/*!
 @brief The smallest table capacity for which bins may be treeified.
 (Otherwise the table is resized if too many nodes in a bin.)
 The value should be at least 4 * TREEIFY_THRESHOLD to avoid
 conflicts between resizing and treeification thresholds.
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_MIN_TREEIFY_CAPACITY();
#define JavaUtilConcurrentConcurrentHashMap_MIN_TREEIFY_CAPACITY 64
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, MIN_TREEIFY_CAPACITY, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_get_MOVED();
#define JavaUtilConcurrentConcurrentHashMap_MOVED -1879048193
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, MOVED, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_get_TREEBIN();
#define JavaUtilConcurrentConcurrentHashMap_TREEBIN ((jint) 0x80000000)
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, TREEBIN, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_get_RESERVED();
#define JavaUtilConcurrentConcurrentHashMap_RESERVED -2147483647
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, RESERVED, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_get_HASH_BITS();
#define JavaUtilConcurrentConcurrentHashMap_HASH_BITS 2147483647
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, HASH_BITS, jint)

/*!
 @brief Number of CPUS, to place bounds on some sizings
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_NCPU();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_NCPU;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaUtilConcurrentConcurrentHashMap, NCPU, jint)

/*!
 @brief Generates initial value for per-thread CounterHashCodes.
 */
inline JavaUtilConcurrentAtomicAtomicInteger *JavaUtilConcurrentConcurrentHashMap_get_counterHashCodeGenerator();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilConcurrentAtomicAtomicInteger *JavaUtilConcurrentConcurrentHashMap_counterHashCodeGenerator;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentConcurrentHashMap, counterHashCodeGenerator, JavaUtilConcurrentAtomicAtomicInteger *)

/*!
 @brief Increment for counterHashCodeGenerator.
 See class ThreadLocal
 for explanation.
 */
inline jint JavaUtilConcurrentConcurrentHashMap_get_SEED_INCREMENT();
#define JavaUtilConcurrentConcurrentHashMap_SEED_INCREMENT 1640531527
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap, SEED_INCREMENT, jint)

/*!
 @brief Per-thread counter hash codes.
 Shared across all instances.
 */
inline JavaLangThreadLocal *JavaUtilConcurrentConcurrentHashMap_get_threadCounterHashCode();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaLangThreadLocal *JavaUtilConcurrentConcurrentHashMap_threadCounterHashCode;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilConcurrentConcurrentHashMap, threadCounterHashCode, JavaLangThreadLocal *)

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_spreadWithInt_(jint h);

FOUNDATION_EXPORT IOSClass *JavaUtilConcurrentConcurrentHashMap_comparableClassForWithId_(id x);

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_compareComparablesWithIOSClass_withId_withId_(IOSClass *kc, id k, id x);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Node *JavaUtilConcurrentConcurrentHashMap_tabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_(IOSObjectArray *tab, jint i);

FOUNDATION_EXPORT jboolean JavaUtilConcurrentConcurrentHashMap_casTabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withJavaUtilConcurrentConcurrentHashMap_Node_withJavaUtilConcurrentConcurrentHashMap_Node_(IOSObjectArray *tab, jint i, JavaUtilConcurrentConcurrentHashMap_Node *c, JavaUtilConcurrentConcurrentHashMap_Node *v);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_setTabAtWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withJavaUtilConcurrentConcurrentHashMap_Node_(IOSObjectArray *tab, jint i, JavaUtilConcurrentConcurrentHashMap_Node *v);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_init(JavaUtilConcurrentConcurrentHashMap *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithInt_(JavaUtilConcurrentConcurrentHashMap *self, jint initialCapacity);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithInt_(jint initialCapacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithJavaUtilMap_(JavaUtilConcurrentConcurrentHashMap *self, id<JavaUtilMap> m);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithJavaUtilMap_(id<JavaUtilMap> m) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_(JavaUtilConcurrentConcurrentHashMap *self, jint initialCapacity, jfloat loadFactor);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_(jint initialCapacity, jfloat loadFactor) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_withInt_(JavaUtilConcurrentConcurrentHashMap *self, jint initialCapacity, jfloat loadFactor, jint concurrencyLevel);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap *new_JavaUtilConcurrentConcurrentHashMap_initWithInt_withFloat_withInt_(jint initialCapacity, jfloat loadFactor, jint concurrencyLevel) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySetView *JavaUtilConcurrentConcurrentHashMap_newKeySet();

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySetView *JavaUtilConcurrentConcurrentHashMap_newKeySetWithInt_(jint initialCapacity);

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_resizeStampWithInt_(jint n);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Node *JavaUtilConcurrentConcurrentHashMap_untreeifyWithJavaUtilConcurrentConcurrentHashMap_Node_(JavaUtilConcurrentConcurrentHashMap_Node *b);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_Node_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_Node_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_Node_

#define JavaUtilMap_RESTRICT 1
#define JavaUtilMap_Entry_INCLUDE 1
#include "../../../java/util/Map.h"

/*!
 @brief Key-value entry.
 This class is never exported out as a
 user-mutable Map.Entry (i.e., one supporting setValue; see
 MapEntry below), but can be used for read-only traversals used
 in bulk tasks.  Subclasses of Node with a negative hash field
 are special, and contain null keys and values (but are never
 exported).  Otherwise, keys and vals are never null.
 */
@interface JavaUtilConcurrentConcurrentHashMap_Node : NSObject < JavaUtilMap_Entry > {
 @public
  jint hash__;
  id key_;
  volatile_id val_;
  JavaUtilConcurrentConcurrentHashMap_Node *next_;
}

#pragma mark Public

- (jboolean)isEqual:(id)o;

- (id)getKey;

- (id)getValue;

- (NSUInteger)hash;

- (id)setValueWithId:(id)value;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)hash_
                     withId:(id)key
                     withId:(id)val
withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)next;

/*!
 @brief Virtualized support for map.get(); overridden in subclasses.
 */
- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_Node)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Node, key_, id)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Node, val_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Node, next_, JavaUtilConcurrentConcurrentHashMap_Node *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_Node_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_(JavaUtilConcurrentConcurrentHashMap_Node *self, jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Node *new_JavaUtilConcurrentConcurrentHashMap_Node_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_(jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_Node)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_Segment_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_Segment_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_Segment_

#define JavaUtilConcurrentLocksReentrantLock_RESTRICT 1
#define JavaUtilConcurrentLocksReentrantLock_INCLUDE 1
#include "../../../java/util/concurrent/locks/ReentrantLock.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../java/io/Serializable.h"

/*!
 @brief Stripped-down version of helper class used in previous version,
 declared for the sake of serialization compatibility
 */
@interface JavaUtilConcurrentConcurrentHashMap_Segment : JavaUtilConcurrentLocksReentrantLock < JavaIoSerializable > {
 @public
  jfloat loadFactor_;
}

#pragma mark Package-Private

- (instancetype)initWithFloat:(jfloat)lf;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_Segment)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_Segment_initWithFloat_(JavaUtilConcurrentConcurrentHashMap_Segment *self, jfloat lf);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Segment *new_JavaUtilConcurrentConcurrentHashMap_Segment_initWithFloat_(jfloat lf) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_Segment)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ForwardingNode_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_ForwardingNode_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_ForwardingNode_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_Node;

/*!
 @brief A node inserted at head of bins during transfer operations.
 */
@interface JavaUtilConcurrentConcurrentHashMap_ForwardingNode : JavaUtilConcurrentConcurrentHashMap_Node {
 @public
  IOSObjectArray *nextTable_;
}

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab;

- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ForwardingNode)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_ForwardingNode, nextTable_, IOSObjectArray *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ForwardingNode_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_(JavaUtilConcurrentConcurrentHashMap_ForwardingNode *self, IOSObjectArray *tab);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ForwardingNode *new_JavaUtilConcurrentConcurrentHashMap_ForwardingNode_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_(IOSObjectArray *tab) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ForwardingNode)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ReservationNode_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_ReservationNode_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_ReservationNode_

@class JavaUtilConcurrentConcurrentHashMap_Node;

/*!
 @brief A place-holder node used in computeIfAbsent and compute
 */
@interface JavaUtilConcurrentConcurrentHashMap_ReservationNode : JavaUtilConcurrentConcurrentHashMap_Node

#pragma mark Package-Private

- (instancetype)init;

- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ReservationNode)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ReservationNode_init(JavaUtilConcurrentConcurrentHashMap_ReservationNode *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ReservationNode *new_JavaUtilConcurrentConcurrentHashMap_ReservationNode_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ReservationNode)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_TreeNode_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_TreeNode_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_TreeNode_

@class IOSClass;
@class JavaUtilConcurrentConcurrentHashMap_Node;

/*!
 @brief Nodes for use in TreeBins
 */
@interface JavaUtilConcurrentConcurrentHashMap_TreeNode : JavaUtilConcurrentConcurrentHashMap_Node {
 @public
  JavaUtilConcurrentConcurrentHashMap_TreeNode *parent_;
  JavaUtilConcurrentConcurrentHashMap_TreeNode *left_;
  JavaUtilConcurrentConcurrentHashMap_TreeNode *right_;
  JavaUtilConcurrentConcurrentHashMap_TreeNode *prev_;
  jboolean red_;
}

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)hash_
                     withId:(id)key
                     withId:(id)val
withJavaUtilConcurrentConcurrentHashMap_Node:(JavaUtilConcurrentConcurrentHashMap_Node *)next
withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)parent;

- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

/*!
 @brief Returns the TreeNode (or null if not found) for the given key
 starting at given root.
 */
- (JavaUtilConcurrentConcurrentHashMap_TreeNode *)findTreeNodeWithInt:(jint)h
                                                               withId:(id)k
                                                         withIOSClass:(IOSClass *)kc;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_TreeNode)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeNode, parent_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeNode, left_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeNode, right_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeNode, prev_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_TreeNode_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *self, jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next, JavaUtilConcurrentConcurrentHashMap_TreeNode *parent);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *new_JavaUtilConcurrentConcurrentHashMap_TreeNode_initWithInt_withId_withId_withJavaUtilConcurrentConcurrentHashMap_Node_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(jint hash_, id key, id val, JavaUtilConcurrentConcurrentHashMap_Node *next, JavaUtilConcurrentConcurrentHashMap_TreeNode *parent) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_TreeNode)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_TreeBin_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_TreeBin_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_TreeBin_

@class JavaLangThread;
@class JavaUtilConcurrentConcurrentHashMap_Node;
@class JavaUtilConcurrentConcurrentHashMap_TreeNode;

/*!
 @brief TreeNodes used at the heads of bins.
 TreeBins do not hold user
 keys or values, but instead point to list of TreeNodes and
 their root. They also maintain a parasitic read-write lock
 forcing writers (who hold bin lock) to wait for readers (who do
 not) to complete before tree restructuring operations.
 */
@interface JavaUtilConcurrentConcurrentHashMap_TreeBin : JavaUtilConcurrentConcurrentHashMap_Node {
 @public
  JavaUtilConcurrentConcurrentHashMap_TreeNode *root_;
  volatile_id first_;
  volatile_id waiter_;
  volatile_jint lockState_;
}

+ (jint)WRITER;

+ (jint)WAITER;

+ (jint)READER;

#pragma mark Package-Private

/*!
 @brief Creates bin with initial set of nodes headed by b.
 */
- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)b;

+ (JavaUtilConcurrentConcurrentHashMap_TreeNode *)balanceDeletionWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)root
                                                                 withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)x;

+ (JavaUtilConcurrentConcurrentHashMap_TreeNode *)balanceInsertionWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)root
                                                                  withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)x;

/*!
 @brief Recursive invariant check
 */
+ (jboolean)checkInvariantsWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)t;

/*!
 @brief Returns matching node or null if none.
 Tries to search
 using tree comparisons from root, but continues linear
 search when lock not available.
 */
- (JavaUtilConcurrentConcurrentHashMap_Node *)findWithInt:(jint)h
                                                   withId:(id)k;

/*!
 @brief Finds or adds a node.
 @return null if added
 */
- (JavaUtilConcurrentConcurrentHashMap_TreeNode *)putTreeValWithInt:(jint)h
                                                             withId:(id)k
                                                             withId:(id)v;

/*!
 @brief Removes the given node, that must be present before this
 call.
 This is messier than typical red-black deletion code
 because we cannot swap the contents of an interior node
 with a leaf successor that is pinned by "next" pointers
 that are accessible independently of lock. So instead we
 swap the tree linkages.
 @return true if now too small, so should be untreeified
 */
- (jboolean)removeTreeNodeWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)p;

+ (JavaUtilConcurrentConcurrentHashMap_TreeNode *)rotateLeftWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)root
                                                            withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)p;

+ (JavaUtilConcurrentConcurrentHashMap_TreeNode *)rotateRightWithJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)root
                                                             withJavaUtilConcurrentConcurrentHashMap_TreeNode:(JavaUtilConcurrentConcurrentHashMap_TreeNode *)p;

/*!
 @brief Tie-breaking utility for ordering insertions when equal
 hashCodes and non-comparable.
 We don't require a total
 order, just a consistent insertion rule to maintain
 equivalence across rebalancings. Tie-breaking further than
 necessary simplifies testing a bit.
 */
+ (jint)tieBreakOrderWithId:(id)a
                     withId:(id)b;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_TreeBin)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeBin, root_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeBin, first_, JavaUtilConcurrentConcurrentHashMap_TreeNode *)
J2OBJC_VOLATILE_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TreeBin, waiter_, JavaLangThread *)

inline jint JavaUtilConcurrentConcurrentHashMap_TreeBin_get_WRITER();
#define JavaUtilConcurrentConcurrentHashMap_TreeBin_WRITER 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap_TreeBin, WRITER, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_TreeBin_get_WAITER();
#define JavaUtilConcurrentConcurrentHashMap_TreeBin_WAITER 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap_TreeBin, WAITER, jint)

inline jint JavaUtilConcurrentConcurrentHashMap_TreeBin_get_READER();
#define JavaUtilConcurrentConcurrentHashMap_TreeBin_READER 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilConcurrentConcurrentHashMap_TreeBin, READER, jint)

FOUNDATION_EXPORT jint JavaUtilConcurrentConcurrentHashMap_TreeBin_tieBreakOrderWithId_withId_(id a, id b);

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_TreeBin_initWithJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeBin *self, JavaUtilConcurrentConcurrentHashMap_TreeNode *b);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeBin *new_JavaUtilConcurrentConcurrentHashMap_TreeBin_initWithJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *b) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *JavaUtilConcurrentConcurrentHashMap_TreeBin_rotateLeftWithJavaUtilConcurrentConcurrentHashMap_TreeNode_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *root, JavaUtilConcurrentConcurrentHashMap_TreeNode *p);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *JavaUtilConcurrentConcurrentHashMap_TreeBin_rotateRightWithJavaUtilConcurrentConcurrentHashMap_TreeNode_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *root, JavaUtilConcurrentConcurrentHashMap_TreeNode *p);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *JavaUtilConcurrentConcurrentHashMap_TreeBin_balanceInsertionWithJavaUtilConcurrentConcurrentHashMap_TreeNode_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *root, JavaUtilConcurrentConcurrentHashMap_TreeNode *x);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TreeNode *JavaUtilConcurrentConcurrentHashMap_TreeBin_balanceDeletionWithJavaUtilConcurrentConcurrentHashMap_TreeNode_withJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *root, JavaUtilConcurrentConcurrentHashMap_TreeNode *x);

FOUNDATION_EXPORT jboolean JavaUtilConcurrentConcurrentHashMap_TreeBin_checkInvariantsWithJavaUtilConcurrentConcurrentHashMap_TreeNode_(JavaUtilConcurrentConcurrentHashMap_TreeNode *t);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_TreeBin)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_TableStack_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_TableStack_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_TableStack_

@class IOSObjectArray;

/*!
 @brief Records the table, its length, and current traversal index for a
 traverser that must process a region of a forwarded table before
 proceeding with current table.
 */
@interface JavaUtilConcurrentConcurrentHashMap_TableStack : NSObject {
 @public
  jint length_;
  jint index_;
  IOSObjectArray *tab_;
  JavaUtilConcurrentConcurrentHashMap_TableStack *next_;
}

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_TableStack)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TableStack, tab_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_TableStack, next_, JavaUtilConcurrentConcurrentHashMap_TableStack *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_TableStack_init(JavaUtilConcurrentConcurrentHashMap_TableStack *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_TableStack *new_JavaUtilConcurrentConcurrentHashMap_TableStack_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_TableStack)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_Traverser_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_Traverser_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_Traverser_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap_Node;
@class JavaUtilConcurrentConcurrentHashMap_TableStack;

/*!
 @brief Encapsulates traversal for methods such as containsValue; also
 serves as a base class for other iterators and spliterators.
 Method advance visits once each still-valid node that was
 reachable upon iterator construction. It might miss some that
 were added to a bin after the bin was visited, which is OK wrt
 consistency guarantees. Maintaining this property in the face
 of possible ongoing resizes requires a fair amount of
 bookkeeping state that is difficult to optimize away amidst
 volatile accesses.  Even so, traversal maintains reasonable
 throughput.
 Normally, iteration proceeds bin-by-bin traversing lists.
 However, if the table has been resized, then all future steps
 must traverse both the bin at the current index as well as at
 (index + baseSize); and so on for further resizings. To
 paranoically cope with potential sharing by users of iterators
 across threads, iteration terminates if a bounds checks fails
 for a table read.
 */
@interface JavaUtilConcurrentConcurrentHashMap_Traverser : NSObject {
 @public
  IOSObjectArray *tab_;
  JavaUtilConcurrentConcurrentHashMap_Node *next_;
  JavaUtilConcurrentConcurrentHashMap_TableStack *stack_, *spare_;
  jint index_;
  jint baseIndex_;
  jint baseLimit_;
  jint baseSize_;
}

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                              withInt:(jint)size
                                                              withInt:(jint)index
                                                              withInt:(jint)limit;

/*!
 @brief Advances if possible, returning next valid node, or null if none.
 */
- (JavaUtilConcurrentConcurrentHashMap_Node *)advance;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_Traverser)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Traverser, tab_, IOSObjectArray *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Traverser, next_, JavaUtilConcurrentConcurrentHashMap_Node *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Traverser, stack_, JavaUtilConcurrentConcurrentHashMap_TableStack *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_Traverser, spare_, JavaUtilConcurrentConcurrentHashMap_TableStack *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_Traverser_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_(JavaUtilConcurrentConcurrentHashMap_Traverser *self, IOSObjectArray *tab, jint size, jint index, jint limit);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_Traverser *new_JavaUtilConcurrentConcurrentHashMap_Traverser_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_(IOSObjectArray *tab, jint size, jint index, jint limit) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_Traverser)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_BaseIterator_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_BaseIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_BaseIterator_

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;
@class JavaUtilConcurrentConcurrentHashMap_Node;

/*!
 @brief Base of key, value, and entry Iterators.
 Adds fields to
 Traverser to support iterator.remove.
 */
@interface JavaUtilConcurrentConcurrentHashMap_BaseIterator : JavaUtilConcurrentConcurrentHashMap_Traverser {
 @public
  JavaUtilConcurrentConcurrentHashMap *map_;
  JavaUtilConcurrentConcurrentHashMap_Node *lastReturned_;
}

#pragma mark Public

- (jboolean)hasMoreElements;

- (jboolean)hasNext;

- (void)remove;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                              withInt:(jint)size
                                                              withInt:(jint)index
                                                              withInt:(jint)limit
                              withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_BaseIterator)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_BaseIterator, map_, JavaUtilConcurrentConcurrentHashMap *)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_BaseIterator, lastReturned_, JavaUtilConcurrentConcurrentHashMap_Node *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_BaseIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_BaseIterator *self, IOSObjectArray *tab, jint size, jint index, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_BaseIterator *new_JavaUtilConcurrentConcurrentHashMap_BaseIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint size, jint index, jint limit, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_BaseIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_KeyIterator_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_KeyIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_KeyIterator_

#define JavaUtilIterator_RESTRICT 1
#define JavaUtilIterator_INCLUDE 1
#include "../../../java/util/Iterator.h"

#define JavaUtilEnumeration_RESTRICT 1
#define JavaUtilEnumeration_INCLUDE 1
#include "../../../java/util/Enumeration.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;

@interface JavaUtilConcurrentConcurrentHashMap_KeyIterator : JavaUtilConcurrentConcurrentHashMap_BaseIterator < JavaUtilIterator, JavaUtilEnumeration >

#pragma mark Public

- (id)next;

- (id)nextElement;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                              withInt:(jint)index
                                                              withInt:(jint)size
                                                              withInt:(jint)limit
                              withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_KeyIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_KeyIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_KeyIterator *self, IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeyIterator *new_JavaUtilConcurrentConcurrentHashMap_KeyIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_KeyIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ValueIterator_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_ValueIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_ValueIterator_

#define JavaUtilIterator_RESTRICT 1
#define JavaUtilIterator_INCLUDE 1
#include "../../../java/util/Iterator.h"

#define JavaUtilEnumeration_RESTRICT 1
#define JavaUtilEnumeration_INCLUDE 1
#include "../../../java/util/Enumeration.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;

@interface JavaUtilConcurrentConcurrentHashMap_ValueIterator : JavaUtilConcurrentConcurrentHashMap_BaseIterator < JavaUtilIterator, JavaUtilEnumeration >

#pragma mark Public

- (id)next;

- (id)nextElement;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                              withInt:(jint)index
                                                              withInt:(jint)size
                                                              withInt:(jint)limit
                              withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ValueIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ValueIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_ValueIterator *self, IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ValueIterator *new_JavaUtilConcurrentConcurrentHashMap_ValueIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ValueIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_EntryIterator_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_EntryIterator_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_EntryIterator_

#define JavaUtilIterator_RESTRICT 1
#define JavaUtilIterator_INCLUDE 1
#include "../../../java/util/Iterator.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilMap_Entry;

@interface JavaUtilConcurrentConcurrentHashMap_EntryIterator : JavaUtilConcurrentConcurrentHashMap_BaseIterator < JavaUtilIterator >

#pragma mark Public

- (id<JavaUtilMap_Entry>)next;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap_NodeArray:(IOSObjectArray *)tab
                                                              withInt:(jint)index
                                                              withInt:(jint)size
                                                              withInt:(jint)limit
                              withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_EntryIterator)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_EntryIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_EntryIterator *self, IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntryIterator *new_JavaUtilConcurrentConcurrentHashMap_EntryIterator_initWithJavaUtilConcurrentConcurrentHashMap_NodeArray_withInt_withInt_withInt_withJavaUtilConcurrentConcurrentHashMap_(IOSObjectArray *tab, jint index, jint size, jint limit, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_EntryIterator)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_MapEntry_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_MapEntry_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_MapEntry_

#define JavaUtilMap_RESTRICT 1
#define JavaUtilMap_Entry_INCLUDE 1
#include "../../../java/util/Map.h"

@class JavaUtilConcurrentConcurrentHashMap;

/*!
 @brief Exported Entry for EntryIterator
 */
@interface JavaUtilConcurrentConcurrentHashMap_MapEntry : NSObject < JavaUtilMap_Entry > {
 @public
  id key_;
  id val_;
  JavaUtilConcurrentConcurrentHashMap *map_;
}

#pragma mark Public

- (jboolean)isEqual:(id)o;

- (id)getKey;

- (id)getValue;

- (NSUInteger)hash;

/*!
 @brief Sets our entry's value and writes through to the map.
 The
 value to return is somewhat arbitrary here. Since we do not
 necessarily track asynchronous changes, the most recent
 "previous" value could be different from what we return (or
 could even have been removed, in which case the put will
 re-establish). We do not and cannot guarantee more.
 */
- (id)setValueWithId:(id)value;

- (NSString *)description;

#pragma mark Package-Private

- (instancetype)initWithId:(id)key
                    withId:(id)val
withJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_MapEntry)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapEntry, key_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapEntry, val_, id)
J2OBJC_FIELD_SETTER(JavaUtilConcurrentConcurrentHashMap_MapEntry, map_, JavaUtilConcurrentConcurrentHashMap *)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_MapEntry_initWithId_withId_withJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_MapEntry *self, id key, id val, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_MapEntry *new_JavaUtilConcurrentConcurrentHashMap_MapEntry_initWithId_withId_withJavaUtilConcurrentConcurrentHashMap_(id key, id val, JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_MapEntry)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_CollectionView_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_CollectionView_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_CollectionView_

#define JavaUtilCollection_RESTRICT 1
#define JavaUtilCollection_INCLUDE 1
#include "../../../java/util/Collection.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../java/io/Serializable.h"

@class IOSObjectArray;
@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilIterator;

/*!
 @brief Base class for views.
 */
@interface JavaUtilConcurrentConcurrentHashMap_CollectionView : NSObject < JavaUtilCollection, JavaIoSerializable > {
 @public
  __weak JavaUtilConcurrentConcurrentHashMap *map_;
}

#pragma mark Public

/*!
 @brief Removes all of the elements from this view, by removing all
 the mappings from the map backing this view.
 */
- (void)clear;

- (jboolean)containsWithId:(id)o;

- (jboolean)containsAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @brief Returns the map backing this view.
 @return the map backing this view
 */
- (JavaUtilConcurrentConcurrentHashMap *)getMap;

- (jboolean)isEmpty;

/*!
 @brief Returns a "weakly consistent" iterator that will never
 throw <code>ConcurrentModificationException</code>, and
 guarantees to traverse elements as they existed upon
 construction of the iterator, and may (but is not
 guaranteed to) reflect any modifications subsequent to
 construction.
 */
- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

- (jboolean)removeAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)retainAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jint)size;

- (IOSObjectArray *)toArray;

- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

/*!
 @brief Returns a string representation of this collection.
 The string representation consists of the string representations
 of the collection's elements in the order they are returned by
 its iterator, enclosed in square brackets (<code>"[]"</code>).
 Adjacent elements are separated by the characters <code>", "</code>
 (comma and space).  Elements are converted to strings as by
 <code>String.valueOf(Object)</code>.
 @return a string representation of this collection
 */
- (NSString *)description;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_CollectionView)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_CollectionView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_CollectionView *self, JavaUtilConcurrentConcurrentHashMap *map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_CollectionView)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_KeySetView_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_KeySetView_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_KeySetView_

#define JavaUtilSet_RESTRICT 1
#define JavaUtilSet_INCLUDE 1
#include "../../../java/util/Set.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../java/io/Serializable.h"

@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilCollection;
@protocol JavaUtilIterator;

/*!
 @brief A view of a ConcurrentHashMap as a <code>Set</code> of keys, in
 which additions may optionally be enabled by mapping to a
 common value.
 This class cannot be directly instantiated.
 See <code>keySet()</code>,
 <code>keySet(V)</code>,
 @since 1.8
 */
@interface JavaUtilConcurrentConcurrentHashMap_KeySetView : JavaUtilConcurrentConcurrentHashMap_CollectionView < JavaUtilSet, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Adds the specified key to this set view by mapping the key to
 the default mapped value in the backing map, if defined.
 @param e key to be added
 @return <code>true</code> if this set changed as a result of the call
 @throws NullPointerException if the specified key is null
 @throws UnsupportedOperationException if no default mapped value
 for additions was provided
 */
- (jboolean)addWithId:(id)e;

/*!
 @brief Adds all of the elements in the specified collection to this set,
 as if by calling <code>add</code> on each one.
 @param c the elements to be inserted into this set
 @return <code>true</code> if this set changed as a result of the call
 @throws NullPointerException if the collection or any of its
 elements are <code>null</code>
 @throws UnsupportedOperationException if no default mapped value
 for additions was provided
 */
- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 
 @throws NullPointerException if the specified key is null
 */
- (jboolean)containsWithId:(id)o;

- (jboolean)isEqual:(id)o;

/*!
 @brief Returns the default mapped value for additions,
 or <code>null</code> if additions are not supported.
 @return the default mapped value for additions, or <code>null</code>
 if not supported
 */
- (id)getMappedValue;

- (NSUInteger)hash;

/*!
 @return an iterator over the keys of the backing map
 */
- (id<JavaUtilIterator>)iterator;

/*!
 @brief Removes the key from this map view, by removing the key (and its
 corresponding value) from the backing map.
 This method does
 nothing if the key is not in the map.
 @param o the key to be removed from the backing map
 @return <code>true</code> if the backing map contained the specified key
 @throws NullPointerException if the specified key is null
 */
- (jboolean)removeWithId:(id)o;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map
                                                     withId:(id)value;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_KeySetView)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_KeySetView_initWithJavaUtilConcurrentConcurrentHashMap_withId_(JavaUtilConcurrentConcurrentHashMap_KeySetView *self, JavaUtilConcurrentConcurrentHashMap *map, id value);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_KeySetView *new_JavaUtilConcurrentConcurrentHashMap_KeySetView_initWithJavaUtilConcurrentConcurrentHashMap_withId_(JavaUtilConcurrentConcurrentHashMap *map, id value) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_KeySetView)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_ValuesView_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_ValuesView_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_ValuesView_

#define JavaUtilCollection_RESTRICT 1
#define JavaUtilCollection_INCLUDE 1
#include "../../../java/util/Collection.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../java/io/Serializable.h"

@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilIterator;

/*!
 @brief A view of a ConcurrentHashMap as a <code>Collection</code> of
 values, in which additions are disabled.
 This class cannot be
 directly instantiated. See <code>values()</code>.
 */
@interface JavaUtilConcurrentConcurrentHashMap_ValuesView : JavaUtilConcurrentConcurrentHashMap_CollectionView < JavaUtilCollection, JavaIoSerializable >

#pragma mark Public

- (jboolean)addWithId:(id)e;

- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)containsWithId:(id)o;

- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_ValuesView)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_ValuesView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_ValuesView *self, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_ValuesView *new_JavaUtilConcurrentConcurrentHashMap_ValuesView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_ValuesView)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_EntrySetView_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_EntrySetView_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_EntrySetView_

#define JavaUtilSet_RESTRICT 1
#define JavaUtilSet_INCLUDE 1
#include "../../../java/util/Set.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../java/io/Serializable.h"

@class JavaUtilConcurrentConcurrentHashMap;
@protocol JavaUtilCollection;
@protocol JavaUtilIterator;
@protocol JavaUtilMap_Entry;

/*!
 @brief A view of a ConcurrentHashMap as a <code>Set</code> of (key, value)
 entries.
 This class cannot be directly instantiated. See
 <code>entrySet()</code>.
 */
@interface JavaUtilConcurrentConcurrentHashMap_EntrySetView : JavaUtilConcurrentConcurrentHashMap_CollectionView < JavaUtilSet, JavaIoSerializable >

#pragma mark Public

- (jboolean)addWithId:(id<JavaUtilMap_Entry>)e;

- (jboolean)addAllWithJavaUtilCollection:(id<JavaUtilCollection>)c;

- (jboolean)containsWithId:(id)o;

- (jboolean)isEqual:(id)o;

- (NSUInteger)hash;

/*!
 @return an iterator over the entries of the backing map
 */
- (id<JavaUtilIterator>)iterator;

- (jboolean)removeWithId:(id)o;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentConcurrentHashMap:(JavaUtilConcurrentConcurrentHashMap *)map;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_EntrySetView)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_EntrySetView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap_EntrySetView *self, JavaUtilConcurrentConcurrentHashMap *map);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_EntrySetView *new_JavaUtilConcurrentConcurrentHashMap_EntrySetView_initWithJavaUtilConcurrentConcurrentHashMap_(JavaUtilConcurrentConcurrentHashMap *map) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_EntrySetView)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_CounterCell_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_CounterCell_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_CounterCell_

@interface JavaUtilConcurrentConcurrentHashMap_CounterCell : NSObject {
 @public
  volatile_jlong p0_, p1_, p2_, p3_, p4_, p5_, p6_;
  volatile_jlong value_;
  volatile_jlong q0_, q1_, q2_, q3_, q4_, q5_, q6_;
}

#pragma mark Package-Private

- (instancetype)initWithLong:(jlong)x;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_CounterCell)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_CounterCell_initWithLong_(JavaUtilConcurrentConcurrentHashMap_CounterCell *self, jlong x);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_CounterCell *new_JavaUtilConcurrentConcurrentHashMap_CounterCell_initWithLong_(jlong x) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_CounterCell)

#endif

#if !defined (JavaUtilConcurrentConcurrentHashMap_CounterHashCode_) && (JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL || defined(JavaUtilConcurrentConcurrentHashMap_CounterHashCode_INCLUDE))
#define JavaUtilConcurrentConcurrentHashMap_CounterHashCode_

/*!
 @brief Holder for the thread-local hash code determining which
 CounterCell to use.
 The code is initialized via the
 counterHashCodeGenerator, but may be moved upon collisions.
 */
@interface JavaUtilConcurrentConcurrentHashMap_CounterHashCode : NSObject {
 @public
  jint code_;
}

#pragma mark Package-Private

- (instancetype)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentConcurrentHashMap_CounterHashCode)

FOUNDATION_EXPORT void JavaUtilConcurrentConcurrentHashMap_CounterHashCode_init(JavaUtilConcurrentConcurrentHashMap_CounterHashCode *self);

FOUNDATION_EXPORT JavaUtilConcurrentConcurrentHashMap_CounterHashCode *new_JavaUtilConcurrentConcurrentHashMap_CounterHashCode_init() NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentConcurrentHashMap_CounterHashCode)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaUtilConcurrentConcurrentHashMap_INCLUDE_ALL")

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/concurrent/PriorityBlockingQueue.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaUtilConcurrentPriorityBlockingQueue_INCLUDE_ALL")
#ifdef JavaUtilConcurrentPriorityBlockingQueue_RESTRICT
#define JavaUtilConcurrentPriorityBlockingQueue_INCLUDE_ALL 0
#else
#define JavaUtilConcurrentPriorityBlockingQueue_INCLUDE_ALL 1
#endif
#undef JavaUtilConcurrentPriorityBlockingQueue_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilConcurrentPriorityBlockingQueue_) && (JavaUtilConcurrentPriorityBlockingQueue_INCLUDE_ALL || defined(JavaUtilConcurrentPriorityBlockingQueue_INCLUDE))
#define JavaUtilConcurrentPriorityBlockingQueue_

#define JavaUtilAbstractQueue_RESTRICT 1
#define JavaUtilAbstractQueue_INCLUDE 1
#include "../../../java/util/AbstractQueue.h"

#define JavaUtilConcurrentBlockingQueue_RESTRICT 1
#define JavaUtilConcurrentBlockingQueue_INCLUDE 1
#include "../../../java/util/concurrent/BlockingQueue.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../../java/io/Serializable.h"

@class IOSObjectArray;
@class JavaUtilConcurrentTimeUnit;
@protocol JavaUtilCollection;
@protocol JavaUtilComparator;
@protocol JavaUtilIterator;

/*!
 @brief An unbounded blocking queue that uses
 the same ordering rules as class <code>PriorityQueue</code> and supplies
 blocking retrieval operations.
 While this queue is logically
 unbounded, attempted additions may fail due to resource exhaustion
 (causing <code>OutOfMemoryError</code>). This class does not permit
 <code>null</code> elements.  A priority queue relying on natural ordering
  also does not permit insertion of
 non-comparable objects (doing so results in
 <code>ClassCastException</code>).
 <p>This class and its iterator implement all of the
 <em>optional</em> methods of the <code>Collection</code> and <code>Iterator</code>
  interfaces.  The Iterator provided in method <code>iterator()</code>
  is <em>not</em> guaranteed to traverse the elements of
 the PriorityBlockingQueue in any particular order. If you need
 ordered traversal, consider using
 <code>Arrays.sort(pq.toArray())</code>.  Also, method <code>drainTo</code>
 can be used to <em>remove</em> some or all elements in priority
 order and place them in another collection.
 <p>Operations on this class make no guarantees about the ordering
 of elements with equal priority. If you need to enforce an
 ordering, you can define custom classes or comparators that use a
 secondary key to break ties in primary priority values.  For
 example, here is a class that applies first-in-first-out
 tie-breaking to comparable elements. To use it, you would insert a
 <code>new FIFOEntry(anEntry)</code> instead of a plain entry object.
 @code
  class FIFOEntry<E extends Comparable<? super E>>
     implements Comparable<FIFOEntry<E>> 
   static final AtomicLong seq = new AtomicLong(0);
   final long seqNum;
   final E entry;
   public FIFOEntry(E entry) {
     seqNum = seq.getAndIncrement();
     this.entry = entry;
   }
   public E getEntry() { return entry; }
   public int compareTo(FIFOEntry<E> other) {
     int res = entry.compareTo(other.entry);
     if (res == 0 && other.entry != this.entry)
       res = (seqNum < other.seqNum ? -1 : 1);
     return res;
   }
  
@endcode
 @since 1.5
 @author Doug Lea
 */
@interface JavaUtilConcurrentPriorityBlockingQueue : JavaUtilAbstractQueue < JavaUtilConcurrentBlockingQueue, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Creates a <code>PriorityBlockingQueue</code> with the default
 initial capacity (11) that orders its elements according to
 their natural ordering.
 */
- (instancetype)init;

/*!
 @brief Creates a <code>PriorityBlockingQueue</code> containing the elements
 in the specified collection.
 If the specified collection is a
 <code>SortedSet</code> or a <code>PriorityQueue</code>, this
 priority queue will be ordered according to the same ordering.
 Otherwise, this priority queue will be ordered according to the
 natural ordering of its elements.
 @param c the collection whose elements are to be placed
 into this priority queue
 @throws ClassCastException if elements of the specified collection
 cannot be compared to one another according to the priority
 queue's ordering
 @throws NullPointerException if the specified collection or any
 of its elements are null
 */
- (instancetype)initWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @brief Creates a <code>PriorityBlockingQueue</code> with the specified
 initial capacity that orders its elements according to their
 natural ordering.
 @param initialCapacity the initial capacity for this priority queue
 @throws IllegalArgumentException if <code>initialCapacity</code> is less
 than 1
 */
- (instancetype)initWithInt:(jint)initialCapacity;

/*!
 @brief Creates a <code>PriorityBlockingQueue</code> with the specified initial
 capacity that orders its elements according to the specified
 comparator.
 @param initialCapacity the initial capacity for this priority queue
 @param comparator the comparator that will be used to order this
 priority queue.  If <code>null</code>, the natural ordering
  of the elements will be used.
 @throws IllegalArgumentException if <code>initialCapacity</code> is less
 than 1
 */
- (instancetype)initWithInt:(jint)initialCapacity
     withJavaUtilComparator:(id<JavaUtilComparator>)comparator;

/*!
 @brief Inserts the specified element into this priority queue.
 @param e the element to add
 @return <code>true</code> (as specified by <code>Collection.add</code>)
 @throws ClassCastException if the specified element cannot be compared
 with elements currently in the priority queue according to the
 priority queue's ordering
 @throws NullPointerException if the specified element is null
 */
- (jboolean)addWithId:(id)e;

/*!
 @brief Atomically removes all of the elements from this queue.
 The queue will be empty after this call returns.
 */
- (void)clear;

/*!
 @brief Returns the comparator used to order the elements in this queue,
 or <code>null</code> if this queue uses the natural ordering
  of its elements.
 @return the comparator used to order the elements in this queue,
 or <code>null</code> if this queue uses the natural
 ordering of its elements
 */
- (id<JavaUtilComparator>)comparator;

/*!
 @brief Returns <code>true</code> if this queue contains the specified element.
 More formally, returns <code>true</code> if and only if this queue contains
 at least one element <code>e</code> such that <code>o.equals(e)</code>.
 @param o object to be checked for containment in this queue
 @return <code>true</code> if this queue contains the specified element
 */
- (jboolean)containsWithId:(id)o;

/*!
 @throws UnsupportedOperationException
 @throws ClassCastException
 @throws NullPointerException
 @throws IllegalArgumentException
 */
- (jint)drainToWithJavaUtilCollection:(id<JavaUtilCollection>)c;

/*!
 @throws UnsupportedOperationException
 @throws ClassCastException
 @throws NullPointerException
 @throws IllegalArgumentException
 */
- (jint)drainToWithJavaUtilCollection:(id<JavaUtilCollection>)c
                              withInt:(jint)maxElements;

/*!
 @brief Returns an iterator over the elements in this queue.
 The
 iterator does not return the elements in any particular order.
 <p>The returned iterator is a "weakly consistent" iterator that
 will never throw <code>ConcurrentModificationException</code>
 , and guarantees to traverse
 elements as they existed upon construction of the iterator, and
 may (but is not guaranteed to) reflect any modifications
 subsequent to construction.
 @return an iterator over the elements in this queue
 */
- (id<JavaUtilIterator>)iterator;

/*!
 @brief Inserts the specified element into this priority queue.
 As the queue is unbounded, this method will never return <code>false</code>.
 @param e the element to add
 @return <code>true</code> (as specified by <code>Queue.offer</code>)
 @throws ClassCastException if the specified element cannot be compared
 with elements currently in the priority queue according to the
 priority queue's ordering
 @throws NullPointerException if the specified element is null
 */
- (jboolean)offerWithId:(id)e;

/*!
 @brief Inserts the specified element into this priority queue.
 As the queue is unbounded, this method will never block or
 return <code>false</code>.
 @param e the element to add
 @param timeout This parameter is ignored as the method never blocks
 @param unit This parameter is ignored as the method never blocks
 @return <code>true</code> (as specified by
 <code>BlockingQueue.offer</code>)
 @throws ClassCastException if the specified element cannot be compared
 with elements currently in the priority queue according to the
 priority queue's ordering
 @throws NullPointerException if the specified element is null
 */
- (jboolean)offerWithId:(id)e
               withLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

- (id)peek;

- (id)poll;

- (id)pollWithLong:(jlong)timeout
withJavaUtilConcurrentTimeUnit:(JavaUtilConcurrentTimeUnit *)unit;

/*!
 @brief Inserts the specified element into this priority queue.
 As the queue is unbounded, this method will never block.
 @param e the element to add
 @throws ClassCastException if the specified element cannot be compared
 with elements currently in the priority queue according to the
 priority queue's ordering
 @throws NullPointerException if the specified element is null
 */
- (void)putWithId:(id)e;

/*!
 @brief Always returns <code>Integer.MAX_VALUE</code> because
 a <code>PriorityBlockingQueue</code> is not capacity constrained.
 @return <code>Integer.MAX_VALUE</code> always
 */
- (jint)remainingCapacity;

/*!
 @brief Removes a single instance of the specified element from this queue,
 if it is present.
 More formally, removes an element <code>e</code> such
 that <code>o.equals(e)</code>, if this queue contains one or more such
 elements.  Returns <code>true</code> if and only if this queue contained
 the specified element (or equivalently, if this queue changed as a
 result of the call).
 @param o element to be removed from this queue, if present
 @return <code>true</code> if this queue changed as a result of the call
 */
- (jboolean)removeWithId:(id)o;

- (jint)size;

- (id)take;

/*!
 @brief Returns an array containing all of the elements in this queue.
 The returned array elements are in no particular order.
 <p>The returned array will be "safe" in that no references to it are
 maintained by this queue.  (In other words, this method must allocate
 a new array).  The caller is thus free to modify the returned array.
 <p>This method acts as bridge between array-based and collection-based
 APIs.
 @return an array containing all of the elements in this queue
 */
- (IOSObjectArray *)toArray;

/*!
 @brief Returns an array containing all of the elements in this queue; the
 runtime type of the returned array is that of the specified array.
 The returned array elements are in no particular order.
 If the queue fits in the specified array, it is returned therein.
 Otherwise, a new array is allocated with the runtime type of the
 specified array and the size of this queue.
 <p>If this queue fits in the specified array with room to spare
 (i.e., the array has more elements than this queue), the element in
 the array immediately following the end of the queue is set to
 <code>null</code>.
 <p>Like the <code>toArray()</code> method, this method acts as bridge between
 array-based and collection-based APIs.  Further, this method allows
 precise control over the runtime type of the output array, and may,
 under certain circumstances, be used to save allocation costs.
 <p>Suppose <code>x</code> is a queue known to contain only strings.
 The following code can be used to dump the queue into a newly
 allocated array of <code>String</code>:
 @code
  String[] y = x.toArray(new String[0]);
@endcode
 Note that <code>toArray(new Object[0])</code> is identical in function to
 <code>toArray()</code>.
 @param a the array into which the elements of the queue are to
 be stored, if it is big enough; otherwise, a new array of the
 same runtime type is allocated for this purpose
 @return an array containing all of the elements in this queue
 @throws ArrayStoreException if the runtime type of the specified array
 is not a supertype of the runtime type of every element in
 this queue
 @throws NullPointerException if the specified array is null
 */
- (IOSObjectArray *)toArrayWithNSObjectArray:(IOSObjectArray *)a;

- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Identity-based version for use in Itr.remove
 */
- (void)removeEQWithId:(id)o;

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentPriorityBlockingQueue)

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_init(JavaUtilConcurrentPriorityBlockingQueue *self);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *new_JavaUtilConcurrentPriorityBlockingQueue_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_initWithInt_(JavaUtilConcurrentPriorityBlockingQueue *self, jint initialCapacity);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *new_JavaUtilConcurrentPriorityBlockingQueue_initWithInt_(jint initialCapacity) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_initWithInt_withJavaUtilComparator_(JavaUtilConcurrentPriorityBlockingQueue *self, jint initialCapacity, id<JavaUtilComparator> comparator);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *new_JavaUtilConcurrentPriorityBlockingQueue_initWithInt_withJavaUtilComparator_(jint initialCapacity, id<JavaUtilComparator> comparator) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_initWithJavaUtilCollection_(JavaUtilConcurrentPriorityBlockingQueue *self, id<JavaUtilCollection> c);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue *new_JavaUtilConcurrentPriorityBlockingQueue_initWithJavaUtilCollection_(id<JavaUtilCollection> c) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentPriorityBlockingQueue)

#endif

#if !defined (JavaUtilConcurrentPriorityBlockingQueue_Itr_) && (JavaUtilConcurrentPriorityBlockingQueue_INCLUDE_ALL || defined(JavaUtilConcurrentPriorityBlockingQueue_Itr_INCLUDE))
#define JavaUtilConcurrentPriorityBlockingQueue_Itr_

#define JavaUtilIterator_RESTRICT 1
#define JavaUtilIterator_INCLUDE 1
#include "../../../java/util/Iterator.h"

@class IOSObjectArray;
@class JavaUtilConcurrentPriorityBlockingQueue;

/*!
 @brief Snapshot iterator that works off copy of underlying q array.
 */
@interface JavaUtilConcurrentPriorityBlockingQueue_Itr : NSObject < JavaUtilIterator > {
 @public
  IOSObjectArray *array_;
  jint cursor_;
  jint lastRet_;
}

#pragma mark Public

- (jboolean)hasNext;

- (id)next;

- (void)remove;

#pragma mark Package-Private

- (instancetype)initWithJavaUtilConcurrentPriorityBlockingQueue:(JavaUtilConcurrentPriorityBlockingQueue *)outer$
                                              withNSObjectArray:(IOSObjectArray *)array;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilConcurrentPriorityBlockingQueue_Itr)

J2OBJC_FIELD_SETTER(JavaUtilConcurrentPriorityBlockingQueue_Itr, array_, IOSObjectArray *)

FOUNDATION_EXPORT void JavaUtilConcurrentPriorityBlockingQueue_Itr_initWithJavaUtilConcurrentPriorityBlockingQueue_withNSObjectArray_(JavaUtilConcurrentPriorityBlockingQueue_Itr *self, JavaUtilConcurrentPriorityBlockingQueue *outer$, IOSObjectArray *array);

FOUNDATION_EXPORT JavaUtilConcurrentPriorityBlockingQueue_Itr *new_JavaUtilConcurrentPriorityBlockingQueue_Itr_initWithJavaUtilConcurrentPriorityBlockingQueue_withNSObjectArray_(JavaUtilConcurrentPriorityBlockingQueue *outer$, IOSObjectArray *array) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentPriorityBlockingQueue_Itr)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaUtilConcurrentPriorityBlockingQueue_INCLUDE_ALL")

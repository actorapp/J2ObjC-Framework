//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/GregorianCalendar.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaUtilGregorianCalendar_INCLUDE_ALL")
#ifdef JavaUtilGregorianCalendar_RESTRICT
#define JavaUtilGregorianCalendar_INCLUDE_ALL 0
#else
#define JavaUtilGregorianCalendar_INCLUDE_ALL 1
#endif
#undef JavaUtilGregorianCalendar_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilGregorianCalendar_) && (JavaUtilGregorianCalendar_INCLUDE_ALL || defined(JavaUtilGregorianCalendar_INCLUDE))
#define JavaUtilGregorianCalendar_

#define JavaUtilCalendar_RESTRICT 1
#define JavaUtilCalendar_INCLUDE 1
#include "../../java/util/Calendar.h"

@class IOSByteArray;
@class JavaUtilDate;
@class JavaUtilLocale;
@class JavaUtilTimeZone;

/*!
 @brief <code>GregorianCalendar</code> is a concrete subclass of <code>Calendar</code>
 and provides the standard calendar used by most of the world.
 <p>
 The standard (Gregorian) calendar has 2 eras, BC and AD.
 <p>
 This implementation handles a single discontinuity, which corresponds by
 default to the date the Gregorian calendar was instituted (October 15, 1582
 in some countries, later in others). The cutover date may be changed by the
 caller by calling <code>setGregorianChange()</code>.
 <p>
 Historically, in those countries which adopted the Gregorian calendar first,
 October 4, 1582 was thus followed by October 15, 1582. This calendar models
 this correctly. Before the Gregorian cutover, <code>GregorianCalendar</code>
 implements the Julian calendar. The only difference between the Gregorian and
 the Julian calendar is the leap year rule. The Julian calendar specifies leap
 years every four years, whereas the Gregorian calendar omits century years
 which are not divisible by 400.
 <p>
 <code>GregorianCalendar</code> implements <em>proleptic</em> Gregorian
 and Julian calendars. That is, dates are computed by extrapolating the
 current rules indefinitely far backward and forward in time. As a result,
 <code>GregorianCalendar</code> may be used for all years to generate
 meaningful and consistent results. However, dates obtained using
 <code>GregorianCalendar</code> are historically accurate only from March 1,
 4 AD onward, when modern Julian calendar rules were adopted. Before this
 date, leap year rules were applied irregularly, and before 45 BC the Julian
 calendar did not even exist.
 <p>
 Prior to the institution of the Gregorian calendar, New Year's Day was March
 25. To avoid confusion, this calendar always uses January 1. A manual
 adjustment may be made if desired for dates that are prior to the Gregorian
 changeover and which fall between January 1 and March 24.
 <p>
 Values calculated for the <code>WEEK_OF_YEAR</code> field range from 1 to
 53. Week 1 for a year is the earliest seven day period starting on
 <code>getFirstDayOfWeek()</code> that contains at least
 <code>getMinimalDaysInFirstWeek()</code> days from that year. It thus
 depends on the values of <code>getMinimalDaysInFirstWeek()</code>,
 <code>getFirstDayOfWeek()</code>, and the day of the week of January 1.
 Weeks between week 1 of one year and week 1 of the following year are
 numbered sequentially from 2 to 52 or 53 (as needed).
 <p>
 For example, January 1, 1998 was a Thursday. If
 <code>getFirstDayOfWeek()</code> is <code>MONDAY</code> and
 <code>getMinimalDaysInFirstWeek()</code> is 4 (these are the values
 reflecting ISO 8601 and many national standards), then week 1 of 1998 starts
 on December 29, 1997, and ends on January 4, 1998. If, however,
 <code>getFirstDayOfWeek()</code> is <code>SUNDAY</code>, then week 1 of
 1998 starts on January 4, 1998, and ends on January 10, 1998; the first three
 days of 1998 then are part of week 53 of 1997.
 <p>
 Values calculated for the <code>WEEK_OF_MONTH</code> field range from 0 or
 1 to 4 or 5. Week 1 of a month (the days with <code>WEEK_OF_MONTH =
 1</code>)
 is the earliest set of at least <code>getMinimalDaysInFirstWeek()</code>
 contiguous days in that month, ending on the day before
 <code>getFirstDayOfWeek()</code>. Unlike week 1 of a year, week 1 of a
 month may be shorter than 7 days, need not start on
 <code>getFirstDayOfWeek()</code>, and will not include days of the
 previous month. Days of a month before week 1 have a
 <code>WEEK_OF_MONTH</code> of 0.
 <p>
 For example, if <code>getFirstDayOfWeek()</code> is <code>SUNDAY</code>
 and <code>getMinimalDaysInFirstWeek()</code> is 4, then the first week of
 January 1998 is Sunday, January 4 through Saturday, January 10. These days
 have a <code>WEEK_OF_MONTH</code> of 1. Thursday, January 1 through
 Saturday, January 3 have a <code>WEEK_OF_MONTH</code> of 0. If
 <code>getMinimalDaysInFirstWeek()</code> is changed to 3, then January 1
 through January 3 have a <code>WEEK_OF_MONTH</code> of 1.
 <p>
 <strong>Example:</strong> <blockquote>
 @code

  // get the supported ids for GMT-08:00 (Pacific Standard Time)
  String[] ids = TimeZone.getAvailableIDs(-8 * 60 * 60 * 1000);
  // if no ids were returned, something is wrong. get out.
  if (ids.length == 0)
     System.exit(0);
  // begin output
  System.out.println("Current Time");
  // create a Pacific Standard Time time zone
  SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]);
  // set up rules for daylight savings time
  pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
  pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2 * 60 * 60 * 1000);
  // create a GregorianCalendar with the Pacific Daylight time zone
  // and the current date and time
  Calendar calendar = new GregorianCalendar(pdt);
  Date trialTime = new Date();
  calendar.setTime(trialTime);
  // print out a bunch of interesting things
  System.out.println("ERA: " + calendar.get(Calendar.ERA));
  System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
  System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
  System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
  System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
  System.out.println("DATE: " + calendar.get(Calendar.DATE));
  System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
  System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
  System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
  System.out.println("DAY_OF_WEEK_IN_MONTH: "
                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
  System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
  System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
  System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
  System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
  System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
  System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
  System.out.println("ZONE_OFFSET: "
                    + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000)));
  System.out.println("DST_OFFSET: "
                    + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000)));
  System.out.println("Current Time, with hour reset to 3");
  calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override
  calendar.set(Calendar.HOUR, 3);
  System.out.println("ERA: " + calendar.get(Calendar.ERA));
  System.out.println("YEAR: " + calendar.get(Calendar.YEAR));
  System.out.println("MONTH: " + calendar.get(Calendar.MONTH));
  System.out.println("WEEK_OF_YEAR: " + calendar.get(Calendar.WEEK_OF_YEAR));
  System.out.println("WEEK_OF_MONTH: " + calendar.get(Calendar.WEEK_OF_MONTH));
  System.out.println("DATE: " + calendar.get(Calendar.DATE));
  System.out.println("DAY_OF_MONTH: " + calendar.get(Calendar.DAY_OF_MONTH));
  System.out.println("DAY_OF_YEAR: " + calendar.get(Calendar.DAY_OF_YEAR));
  System.out.println("DAY_OF_WEEK: " + calendar.get(Calendar.DAY_OF_WEEK));
  System.out.println("DAY_OF_WEEK_IN_MONTH: "
                    + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
  System.out.println("AM_PM: " + calendar.get(Calendar.AM_PM));
  System.out.println("HOUR: " + calendar.get(Calendar.HOUR));
  System.out.println("HOUR_OF_DAY: " + calendar.get(Calendar.HOUR_OF_DAY));
  System.out.println("MINUTE: " + calendar.get(Calendar.MINUTE));
  System.out.println("SECOND: " + calendar.get(Calendar.SECOND));
  System.out.println("MILLISECOND: " + calendar.get(Calendar.MILLISECOND));
  System.out.println("ZONE_OFFSET: "
        + (calendar.get(Calendar.ZONE_OFFSET)/(60*60*1000))); // in hours
  System.out.println("DST_OFFSET: "
        + (calendar.get(Calendar.DST_OFFSET)/(60*60*1000))); // in hours
  
@endcode
 </blockquote>
 - seealso: Calendar
 - seealso: TimeZone
 */
@interface JavaUtilGregorianCalendar : JavaUtilCalendar

+ (jint)BC;

+ (jint)AD;

+ (IOSByteArray *)DaysInMonth;

+ (void)setDaysInMonth:(IOSByteArray *)value;

#pragma mark Public

/*!
 @brief Constructs a new <code>GregorianCalendar</code> initialized to the current date and
 time with the default <code>Locale</code> and <code>TimeZone</code>.
 */
- (instancetype)init;

/*!
 @brief Constructs a new <code>GregorianCalendar</code> initialized to midnight in the default
 <code>TimeZone</code> and <code>Locale</code> on the specified date.
 @param year
 the year.
 @param month
 the month.
 @param day
 the day of the month.
 */
- (instancetype)initWithInt:(jint)year
                    withInt:(jint)month
                    withInt:(jint)day;

/*!
 @brief Constructs a new <code>GregorianCalendar</code> initialized to the specified date and
 time in the default <code>TimeZone</code> and <code>Locale</code>.
 @param year
 the year.
 @param month
 the month.
 @param day
 the day of the month.
 @param hour
 the hour.
 @param minute
 the minute.
 */
- (instancetype)initWithInt:(jint)year
                    withInt:(jint)month
                    withInt:(jint)day
                    withInt:(jint)hour
                    withInt:(jint)minute;

/*!
 @brief Constructs a new <code>GregorianCalendar</code> initialized to the specified date and
 time in the default <code>TimeZone</code> and <code>Locale</code>.
 @param year
 the year.
 @param month
 the month.
 @param day
 the day of the month.
 @param hour
 the hour.
 @param minute
 the minute.
 @param second
 the second.
 */
- (instancetype)initWithInt:(jint)year
                    withInt:(jint)month
                    withInt:(jint)day
                    withInt:(jint)hour
                    withInt:(jint)minute
                    withInt:(jint)second;

/*!
 @brief Constructs a new <code>GregorianCalendar</code> initialized to the current date and
 time and using the specified <code>Locale</code> and the default <code>TimeZone</code>.
 @param locale
 the <code>Locale</code>.
 */
- (instancetype)initWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Constructs a new <code>GregorianCalendar</code> initialized to the current date and
 time and using the specified <code>TimeZone</code> and the default <code>Locale</code>.
 @param timezone
 the <code>TimeZone</code>.
 */
- (instancetype)initWithJavaUtilTimeZone:(JavaUtilTimeZone *)timezone;

/*!
 @brief Constructs a new <code>GregorianCalendar</code> initialized to the current date and
 time and using the specified <code>TimeZone</code> and <code>Locale</code>.
 @param timezone
 the <code>TimeZone</code>.
 @param locale
 the <code>Locale</code>.
 */
- (instancetype)initWithJavaUtilTimeZone:(JavaUtilTimeZone *)timezone
                      withJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Adds the specified amount to a <code>Calendar</code> field.
 @param field
 the <code>Calendar</code> field to modify.
 @param value
 the amount to add to the field.
 @throws IllegalArgumentException
 if the specified field is DST_OFFSET or ZONE_OFFSET.
 */
- (void)addWithInt:(jint)field
           withInt:(jint)value;

/*!
 @brief Returns true if <code>object</code> is a GregorianCalendar with the same
 properties.
 */
- (jboolean)isEqual:(id)object;

- (jint)getActualMaximumWithInt:(jint)field;

/*!
 @brief Gets the minimum value of the specified field for the current date.
 For
 the gregorian calendar, this value is the same as
 <code>getMinimum()</code>.
 @param field
 the field.
 @return the minimum value of the specified field.
 */
- (jint)getActualMinimumWithInt:(jint)field;

/*!
 @brief Gets the greatest minimum value of the specified field.
 For the gregorian
 calendar, this value is the same as <code>getMinimum()</code>.
 @param field
 the field.
 @return the greatest minimum value of the specified field.
 */
- (jint)getGreatestMinimumWithInt:(jint)field;

/*!
 @brief Returns the gregorian change date of this calendar.
 This is the date on
 which the gregorian calendar came into effect.
 @return a <code>Date</code> which represents the gregorian change date.
 */
- (JavaUtilDate *)getGregorianChange;

/*!
 @brief Gets the smallest maximum value of the specified field.
 For example, 28
 for the day of month field.
 @param field
 the field.
 @return the smallest maximum value of the specified field.
 */
- (jint)getLeastMaximumWithInt:(jint)field;

/*!
 @brief Gets the greatest maximum value of the specified field.
 For example, 31
 for the day of month field.
 @param field
 the field.
 @return the greatest maximum value of the specified field.
 */
- (jint)getMaximumWithInt:(jint)field;

/*!
 @brief Gets the smallest minimum value of the specified field.
 @param field
 the field.
 @return the smallest minimum value of the specified field.
 */
- (jint)getMinimumWithInt:(jint)field;

- (NSUInteger)hash;

/*!
 @brief Returns true if <code>year</code> is a leap year.
 */
- (jboolean)isLeapYearWithInt:(jint)year;

/*!
 @brief Increments or decrements the specified field and wraps the value of the
 field when it goes beyond the maximum or minimum value for the current
 date.
 Other fields will be adjusted as required to maintain a consistent
 date. For example, March 31 will roll to April 30 when rolling the month
 field.
 @param field
 the field to roll.
 @param increment
 <code>true</code> to increment the field, <code>false</code> to
 decrement.
 @throws IllegalArgumentException
 if an invalid field is specified.
 */
- (void)rollWithInt:(jint)field
        withBoolean:(jboolean)increment;

/*!
 @brief Adds the specified amount the specified field and wraps the value of the
 field when it goes beyond the maximum or minimum value for the current
 date.
 Other fields will be adjusted as required to maintain a consistent
 date.
 @param field
 the field to roll.
 @param value
 the amount to add.
 @throws IllegalArgumentException
 if an invalid field is specified.
 */
- (void)rollWithInt:(jint)field
            withInt:(jint)value;

/*!
 @brief Sets the gregorian change date of this calendar.
 */
- (void)setGregorianChangeWithJavaUtilDate:(JavaUtilDate *)date;

#pragma mark Protected

- (void)computeFields;

- (void)computeTime;

#pragma mark Package-Private

- (instancetype)initWithBoolean:(jboolean)ignored;

- (instancetype)initWithLong:(jlong)milliseconds;

@end

J2OBJC_STATIC_INIT(JavaUtilGregorianCalendar)

/*!
 @brief Value for the BC era.
 */
inline jint JavaUtilGregorianCalendar_get_BC();
#define JavaUtilGregorianCalendar_BC 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilGregorianCalendar, BC, jint)

/*!
 @brief Value for the AD era.
 */
inline jint JavaUtilGregorianCalendar_get_AD();
#define JavaUtilGregorianCalendar_AD 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilGregorianCalendar, AD, jint)

inline IOSByteArray *JavaUtilGregorianCalendar_get_DaysInMonth();
inline IOSByteArray *JavaUtilGregorianCalendar_set_DaysInMonth(IOSByteArray *value);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT IOSByteArray *JavaUtilGregorianCalendar_DaysInMonth;
J2OBJC_STATIC_FIELD_OBJ(JavaUtilGregorianCalendar, DaysInMonth, IOSByteArray *)

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_init(JavaUtilGregorianCalendar *self);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithInt_withInt_withInt_(JavaUtilGregorianCalendar *self, jint year, jint month, jint day);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_(jint year, jint month, jint day) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_(JavaUtilGregorianCalendar *self, jint year, jint month, jint day, jint hour, jint minute);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_(jint year, jint month, jint day, jint hour, jint minute) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_withInt_(JavaUtilGregorianCalendar *self, jint year, jint month, jint day, jint hour, jint minute, jint second);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithInt_withInt_withInt_withInt_withInt_withInt_(jint year, jint month, jint day, jint hour, jint minute, jint second) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithLong_(JavaUtilGregorianCalendar *self, jlong milliseconds);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithLong_(jlong milliseconds) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithJavaUtilLocale_(JavaUtilGregorianCalendar *self, JavaUtilLocale *locale);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithJavaUtilLocale_(JavaUtilLocale *locale) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_(JavaUtilGregorianCalendar *self, JavaUtilTimeZone *timezone);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_(JavaUtilTimeZone *timezone) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_withJavaUtilLocale_(JavaUtilGregorianCalendar *self, JavaUtilTimeZone *timezone, JavaUtilLocale *locale);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithJavaUtilTimeZone_withJavaUtilLocale_(JavaUtilTimeZone *timezone, JavaUtilLocale *locale) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaUtilGregorianCalendar_initWithBoolean_(JavaUtilGregorianCalendar *self, jboolean ignored);

FOUNDATION_EXPORT JavaUtilGregorianCalendar *new_JavaUtilGregorianCalendar_initWithBoolean_(jboolean ignored) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilGregorianCalendar)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaUtilGregorianCalendar_INCLUDE_ALL")

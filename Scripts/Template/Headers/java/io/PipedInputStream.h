//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/io/PipedInputStream.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaIoPipedInputStream_INCLUDE_ALL")
#ifdef JavaIoPipedInputStream_RESTRICT
#define JavaIoPipedInputStream_INCLUDE_ALL 0
#else
#define JavaIoPipedInputStream_INCLUDE_ALL 1
#endif
#undef JavaIoPipedInputStream_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaIoPipedInputStream_) && (JavaIoPipedInputStream_INCLUDE_ALL || defined(JavaIoPipedInputStream_INCLUDE))
#define JavaIoPipedInputStream_

#define JavaIoInputStream_RESTRICT 1
#define JavaIoInputStream_INCLUDE 1
#include "../../java/io/InputStream.h"

@class IOSByteArray;
@class JavaIoPipedOutputStream;

/*!
 @brief Receives information from a communications pipe.
 When two threads want to
 pass data back and forth, one creates a piped output stream and the other one
 creates a piped input stream.
 - seealso: PipedOutputStream
 */
@interface JavaIoPipedInputStream : JavaIoInputStream {
 @public
  /*!
   @brief The circular buffer through which data is passed.
   Data is read from the
 range <code>[out, in)</code> and written to the range <code>[in, out)</code>.
 Data in the buffer is either sequential: 
@code

     { - - - X X X X X X X - - - - - }
             ^             ^
             |             |
            
@endcode
 ...or wrapped around the buffer's end: 
@code

     { X X X X - - - - - - - - X X X }
               ^               ^
               |               |
              
@endcode
 When the buffer is empty, <code>in == -1</code>. Reading when the buffer is
 empty will block until data is available. When the buffer is full,
 <code>in == out</code>. Writing when the buffer is full will block until free
 space is available.
   */
  IOSByteArray *buffer_;
  /*!
   @brief The index in <code>buffer</code> where the next byte will be written.
   */
  jint in_;
  /*!
   @brief The index in <code>buffer</code> where the next byte will be read.
   */
  jint out_;
  /*!
   @brief Indicates if this pipe is connected.
   */
  jboolean isConnected_;
}

+ (jint)PIPE_SIZE;

#pragma mark Public

/*!
 @brief Constructs a new unconnected <code>PipedInputStream</code>.
 The resulting
 stream must be connected to a <code>PipedOutputStream</code> before data may
 be read from it.
 */
- (instancetype)init;

/*!
 @brief Constructs a new unconnected <code>PipedInputStream</code> with the given
 buffer size.
 The resulting stream must be connected to a
 <code>PipedOutputStream</code> before data may be read from it.
 @param pipeSize the size of the buffer in bytes.
 @throws IllegalArgumentException if pipeSize is less than or equal to zero.
 @since 1.6
 */
- (instancetype)initWithInt:(jint)pipeSize;

/*!
 @brief Constructs a new <code>PipedInputStream</code> connected to the
 <code>PipedOutputStream</code> <code>out</code>.
 Any data written to the output
 stream can be read from the this input stream.
 @param outArg
 the piped output stream to connect to.
 @throws IOException
 if this stream or <code>out</code> are already connected.
 */
- (instancetype)initWithJavaIoPipedOutputStream:(JavaIoPipedOutputStream *)outArg;

/*!
 @brief Constructs a new <code>PipedInputStream</code> connected to the given <code>PipedOutputStream</code>,
 with the given buffer size.
 Any data written to the output stream can be read from this
 input stream.
 @param outArg the <code>PipedOutputStream</code> to connect to.
 @param pipeSize the size of the buffer in bytes.
 @throws IOException if an I/O error occurs.
 @throws IllegalArgumentException if pipeSize is less than or equal to zero.
 @since 1.6
 */
- (instancetype)initWithJavaIoPipedOutputStream:(JavaIoPipedOutputStream *)outArg
                                        withInt:(jint)pipeSize;

/*!
 @brief 
 <p>Unlike most streams, <code>PipedInputStream</code> returns 0 rather than throwing
 <code>IOException</code> if the stream has been closed.
 Unconnected and broken pipes also
 return 0.
 @throws IOException if an I/O error occurs
 */
- (jint)available;

/*!
 @brief Closes this stream.
 This implementation releases the buffer used for the
 pipe and notifies all threads waiting to read or write.
 @throws IOException
 if an error occurs while closing this stream.
 */
- (void)close;

/*!
 @brief Connects this <code>PipedInputStream</code> to a <code>PipedOutputStream</code>.
 Any data written to the output stream becomes readable in this input
 stream.
 @param src
 the source output stream.
 @throws IOException
 if either stream is already connected.
 */
- (void)connectWithJavaIoPipedOutputStream:(JavaIoPipedOutputStream *)src;

/*!
 @brief Reads a single byte from this stream and returns it as an integer in the
 range from 0 to 255.
 Returns -1 if the end of this stream has been
 reached. If there is no data in the pipe, this method blocks until data
 is available, the end of the stream is detected or an exception is
 thrown.
 <p>
 Separate threads should be used to read from a <code>PipedInputStream</code>
 and to write to the connected <code>PipedOutputStream</code>. If the same
 thread is used, a deadlock may occur.
 @return the byte read or -1 if the end of the source stream has been
 reached.
 @throws IOException
 if this stream is closed or not connected to an output
 stream, or if the thread writing to the connected output
 stream is no longer alive.
 */
- (jint)read;

/*!
 @brief Reads at most <code>byteCount</code> bytes from this stream and stores them in the
 byte array <code>bytes</code> starting at <code>offset</code>.
 Blocks until at
 least one byte has been read, the end of the stream is detected or an
 exception is thrown.
 <p>
 Separate threads should be used to read from a <code>PipedInputStream</code>
 and to write to the connected <code>PipedOutputStream</code>. If the same
 thread is used, a deadlock may occur.
 @return the number of bytes actually read or -1 if the end of the stream
 has been reached.
 @throws IndexOutOfBoundsException
 if <code>offset < 0</code> or <code>byteCount < 0</code>, or if <code>offset + byteCount</code>
  is greater than the size of <code>bytes</code>.
 @throws InterruptedIOException
 if the thread reading from this stream is interrupted.
 @throws IOException
 if this stream is closed or not connected to an output
 stream, or if the thread writing to the connected output
 stream is no longer alive.
 @throws NullPointerException
 if <code>bytes</code> is <code>null</code>.
 */
- (jint)readWithByteArray:(IOSByteArray *)bytes
                  withInt:(jint)offset
                  withInt:(jint)byteCount;

#pragma mark Protected

/*!
 @brief Receives a byte and stores it in this stream's <code>buffer</code>.
 This
 method is called by <code>PipedOutputStream.write(int)</code>. The least
 significant byte of the integer <code>oneByte</code> is stored at index
 <code>in</code> in the <code>buffer</code>.
 <p>
 This method blocks as long as <code>buffer</code> is full.
 @param oneByte
 the byte to store in this pipe.
 @throws InterruptedIOException
 if the <code>buffer</code> is full and the thread that has called
 this method is interrupted.
 @throws IOException
 if this stream is closed or the thread that has last read
 from this stream is no longer alive.
 */
- (void)receiveWithInt:(jint)oneByte;

#pragma mark Package-Private

- (void)done;

/*!
 @brief Establishes the connection to the PipedOutputStream.
 @throws IOException
 If this Reader is already connected.
 */
- (void)establishConnection;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoPipedInputStream)

J2OBJC_FIELD_SETTER(JavaIoPipedInputStream, buffer_, IOSByteArray *)

/*!
 @brief The size of the default pipe in bytes.
 */
inline jint JavaIoPipedInputStream_get_PIPE_SIZE();
#define JavaIoPipedInputStream_PIPE_SIZE 1024
J2OBJC_STATIC_FIELD_CONSTANT(JavaIoPipedInputStream, PIPE_SIZE, jint)

FOUNDATION_EXPORT void JavaIoPipedInputStream_init(JavaIoPipedInputStream *self);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_(JavaIoPipedInputStream *self, JavaIoPipedOutputStream *outArg);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_(JavaIoPipedOutputStream *outArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaIoPipedInputStream_initWithInt_(JavaIoPipedInputStream *self, jint pipeSize);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_initWithInt_(jint pipeSize) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_withInt_(JavaIoPipedInputStream *self, JavaIoPipedOutputStream *outArg, jint pipeSize);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_withInt_(JavaIoPipedOutputStream *outArg, jint pipeSize) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaIoPipedInputStream)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaIoPipedInputStream_INCLUDE_ALL")

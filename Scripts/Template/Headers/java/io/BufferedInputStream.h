//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/io/BufferedInputStream.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaIoBufferedInputStream_INCLUDE_ALL")
#ifdef JavaIoBufferedInputStream_RESTRICT
#define JavaIoBufferedInputStream_INCLUDE_ALL 0
#else
#define JavaIoBufferedInputStream_INCLUDE_ALL 1
#endif
#undef JavaIoBufferedInputStream_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaIoBufferedInputStream_) && (JavaIoBufferedInputStream_INCLUDE_ALL || defined(JavaIoBufferedInputStream_INCLUDE))
#define JavaIoBufferedInputStream_

#define JavaIoFilterInputStream_RESTRICT 1
#define JavaIoFilterInputStream_INCLUDE 1
#include "../../java/io/FilterInputStream.h"

@class IOSByteArray;
@class JavaIoInputStream;

/*!
 @brief Wraps an existing <code>InputStream</code> and <em>buffers</em> the input.
 Expensive interaction with the underlying input stream is minimized, since
 most (smaller) requests can be satisfied by accessing the buffer alone. The
 drawback is that some extra space is required to hold the buffer and that
 copying takes place when filling that buffer, but this is usually outweighed
 by the performance benefits.
 <p/>A typical application pattern for the class looks like this:<p/>
 @code

  BufferedInputStream buf = new BufferedInputStream(new FileInputStream(&quot;file.java&quot;));
  
@endcode
 - seealso: BufferedOutputStream
 */
@interface JavaIoBufferedInputStream : JavaIoFilterInputStream {
 @public
  /*!
   @brief The buffer containing the current bytes read from the target InputStream.
   */
  volatile_id buf_;
  /*!
   @brief The total number of bytes inside the byte array <code>buf</code>.
   */
  jint count_;
  /*!
   @brief The current limit, which when passed, invalidates the current mark.
   */
  jint marklimit_;
  /*!
   @brief The currently marked position. -1 indicates no mark has been set or the
 mark has been invalidated.
   */
  jint markpos_;
  /*!
   @brief The current position within the byte array <code>buf</code>.
   */
  jint pos_;
}

+ (jint)DEFAULT_BUFFER_SIZE;

#pragma mark Public

/*!
 @brief Constructs a new <code>BufferedInputStream</code>, providing <code>in</code> with a buffer
 of 8192 bytes.
 <p><strong>Warning:</strong> passing a null source creates a closed
 <code>BufferedInputStream</code>. All read operations on such a stream will
 fail with an IOException.
 @param inArg the <code>InputStream</code> the buffer reads from.
 */
- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)inArg;

/*!
 @brief Constructs a new <code>BufferedInputStream</code>, providing <code>in</code> with <code>size</code> bytes
 of buffer.
 <p><strong>Warning:</strong> passing a null source creates a closed
 <code>BufferedInputStream</code>. All read operations on such a stream will
 fail with an IOException.
 @param inArg the <code>InputStream</code> the buffer reads from.
 @param size the size of buffer in bytes.
 @throws IllegalArgumentException if <code>size <= 0</code>.
 */
- (instancetype)initWithJavaIoInputStream:(JavaIoInputStream *)inArg
                                  withInt:(jint)size;

/*!
 @brief Returns an estimated number of bytes that can be read or skipped without blocking for more
 input.
 This method returns the number of bytes available in the buffer
 plus those available in the source stream, but see <code>InputStream.available</code> for
 important caveats.
 @return the estimated number of bytes available
 @throws IOException if this stream is closed or an error occurs
 */
- (jint)available;

/*!
 @brief Closes this stream.
 The source stream is closed and any resources
 associated with it are released.
 @throws IOException
 if an error occurs while closing this stream.
 */
- (void)close;

/*!
 @brief Sets a mark position in this stream.
 The parameter <code>readlimit</code>
 indicates how many bytes can be read before a mark is invalidated.
 Calling <code>reset()</code> will reposition the stream back to the marked
 position if <code>readlimit</code> has not been surpassed. The underlying
 buffer may be increased in size to allow <code>readlimit</code> number of
 bytes to be supported.
 @param readlimit
 the number of bytes that can be read before the mark is
 invalidated.
 - seealso: #reset()
 */
- (void)markWithInt:(jint)readlimit;

/*!
 @brief Indicates whether <code>BufferedInputStream</code> supports the <code>mark()</code>
 and <code>reset()</code> methods.
 @return <code>true</code> for BufferedInputStreams.
 - seealso: #mark(int)
 - seealso: #reset()
 */
- (jboolean)markSupported;

/*!
 @brief Reads a single byte from this stream and returns it as an integer in the
 range from 0 to 255.
 Returns -1 if the end of the source string has been
 reached. If the internal buffer does not contain any available bytes then
 it is filled from the source stream and the first byte is returned.
 @return the byte read or -1 if the end of the source stream has been
 reached.
 @throws IOException
 if this stream is closed or another IOException occurs.
 */
- (jint)read;

- (jint)readWithByteArray:(IOSByteArray *)buffer
                  withInt:(jint)byteOffset
                  withInt:(jint)byteCount;

/*!
 @brief Resets this stream to the last marked location.
 @throws IOException
 if this stream is closed, no mark has been set or the mark is
 no longer valid because more than <code>readlimit</code> bytes
 have been read since setting the mark.
 - seealso: #mark(int)
 */
- (void)reset;

/*!
 @brief Skips <code>byteCount</code> bytes in this stream.
 Subsequent calls to
 <code>read</code> will not return these bytes unless <code>reset</code> is
 used.
 @param byteCount
 the number of bytes to skip. <code>skip</code> does nothing and
 returns 0 if <code>byteCount</code> is less than zero.
 @return the number of bytes actually skipped.
 @throws IOException
 if this stream is closed or another IOException occurs.
 */
- (jlong)skipWithLong:(jlong)byteCount;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoBufferedInputStream)

J2OBJC_VOLATILE_FIELD_SETTER(JavaIoBufferedInputStream, buf_, IOSByteArray *)

/*!
 @brief The default buffer size if it is not specified.
 */
inline jint JavaIoBufferedInputStream_get_DEFAULT_BUFFER_SIZE();
#define JavaIoBufferedInputStream_DEFAULT_BUFFER_SIZE 8192
J2OBJC_STATIC_FIELD_CONSTANT(JavaIoBufferedInputStream, DEFAULT_BUFFER_SIZE, jint)

FOUNDATION_EXPORT void JavaIoBufferedInputStream_initWithJavaIoInputStream_(JavaIoBufferedInputStream *self, JavaIoInputStream *inArg);

FOUNDATION_EXPORT JavaIoBufferedInputStream *new_JavaIoBufferedInputStream_initWithJavaIoInputStream_(JavaIoInputStream *inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaIoBufferedInputStream_initWithJavaIoInputStream_withInt_(JavaIoBufferedInputStream *self, JavaIoInputStream *inArg, jint size);

FOUNDATION_EXPORT JavaIoBufferedInputStream *new_JavaIoBufferedInputStream_initWithJavaIoInputStream_withInt_(JavaIoInputStream *inArg, jint size) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaIoBufferedInputStream)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaIoBufferedInputStream_INCLUDE_ALL")

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: apache_harmony/classlib/modules/math/src/main/java/java/math/BigDecimal.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaMathBigDecimal_INCLUDE_ALL")
#ifdef JavaMathBigDecimal_RESTRICT
#define JavaMathBigDecimal_INCLUDE_ALL 0
#else
#define JavaMathBigDecimal_INCLUDE_ALL 1
#endif
#undef JavaMathBigDecimal_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaMathBigDecimal_) && (JavaMathBigDecimal_INCLUDE_ALL || defined(JavaMathBigDecimal_INCLUDE))
#define JavaMathBigDecimal_

#define JavaLangComparable_RESTRICT 1
#define JavaLangComparable_INCLUDE 1
#include "../../java/lang/Comparable.h"

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../java/io/Serializable.h"

@class IOSCharArray;
@class IOSObjectArray;
@class JavaMathBigInteger;
@class JavaMathMathContext;
@class JavaMathRoundingMode;

/*!
 @brief This class represents immutable arbitrary precision decimal numbers.
 Each
 <code>BigDecimal</code> instance is represented with a unscaled arbitrary
 precision mantissa (the unscaled value) and a scale. The value of the <code>BigDecimal</code>
  is <code>unscaledValue</code> 10^(-<code>scale</code>).
 */
@interface JavaMathBigDecimal : NSNumber < JavaLangComparable, JavaIoSerializable >

+ (JavaMathBigDecimal *)ZERO;

+ (JavaMathBigDecimal *)ONE;

+ (JavaMathBigDecimal *)TEN;

+ (jint)ROUND_UP;

+ (jint)ROUND_DOWN;

+ (jint)ROUND_CEILING;

+ (jint)ROUND_FLOOR;

+ (jint)ROUND_HALF_UP;

+ (jint)ROUND_HALF_DOWN;

+ (jint)ROUND_HALF_EVEN;

+ (jint)ROUND_UNNECESSARY;

#pragma mark Public

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from the given big integer
 <code>val</code>.
 The scale of the result is <code>0</code>.
 @param val
 <code>BigInteger</code> value to be converted to a <code>BigDecimal</code>
  instance.
 */
- (instancetype)initWithJavaMathBigInteger:(JavaMathBigInteger *)val;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from a given unscaled value
 <code>unscaledVal</code> and a given scale.
 The value of this instance is
 <code>unscaledVal</code> 10^(-<code>scale</code>).
 @param unscaledVal
 <code>BigInteger</code> representing the unscaled value of this
 <code>BigDecimal</code> instance.
 @param scale_
 scale of this <code>BigDecimal</code> instance.
 @throws NullPointerException
 if <code>unscaledVal == null</code>.
 */
- (instancetype)initWithJavaMathBigInteger:(JavaMathBigInteger *)unscaledVal
                                   withInt:(jint)scale_;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from a given unscaled value
 <code>unscaledVal</code> and a given scale.
 The value of this instance is
 <code>unscaledVal</code> 10^(-<code>scale</code>). The result is rounded according
 to the specified math context.
 @param unscaledVal
 <code>BigInteger</code> representing the unscaled value of this
 <code>BigDecimal</code> instance.
 @param scale_
 scale of this <code>BigDecimal</code> instance.
 @param mc
 rounding mode and precision for the result of this operation.
 @throws ArithmeticException
 if <code>mc.precision > 0</code> and <code>mc.roundingMode ==
 UNNECESSARY</code>
  and the new big decimal cannot be represented
 within the given precision without rounding.
 @throws NullPointerException
 if <code>unscaledVal == null</code>.
 */
- (instancetype)initWithJavaMathBigInteger:(JavaMathBigInteger *)unscaledVal
                                   withInt:(jint)scale_
                   withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from the given big integer
 <code>val</code>.
 The scale of the result is <code>0</code>.
 @param val
 <code>BigInteger</code> value to be converted to a <code>BigDecimal</code>
  instance.
 @param mc
 rounding mode and precision for the result of this operation.
 @throws ArithmeticException
 if <code>mc.precision > 0</code> and <code>mc.roundingMode ==
 UNNECESSARY</code>
  and the new big decimal cannot be represented
 within the given precision without rounding.
 */
- (instancetype)initWithJavaMathBigInteger:(JavaMathBigInteger *)val
                   withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from a string representation
 given as a character array.
 @param inArg
 array of characters containing the string representation of
 this <code>BigDecimal</code>.
 @throws NullPointerException
 if <code>in == null</code>.
 @throws NumberFormatException
 if <code>in</code> does not contain a valid string representation
 of a big decimal.
 */
- (instancetype)initWithCharArray:(IOSCharArray *)inArg;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from a string representation
 given as a character array.
 @param inArg
 array of characters containing the string representation of
 this <code>BigDecimal</code>.
 @param offset
 first index to be copied.
 @param len
 number of characters to be used.
 @throws NullPointerException
 if <code>in == null</code>.
 @throws NumberFormatException
 if <code>offset < 0</code> or <code>len <= 0</code> or <code>offset+len-1 < 0</code>
  or <code>offset+len-1 >= in.length</code>.
 @throws NumberFormatException
 if in does not contain a valid string representation of a big
 decimal.
 */
- (instancetype)initWithCharArray:(IOSCharArray *)inArg
                          withInt:(jint)offset
                          withInt:(jint)len;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from a string representation
 given as a character array.
 @param inArg
 array of characters containing the string representation of
 this <code>BigDecimal</code>.
 @param offset
 first index to be copied.
 @param len
 number of characters to be used.
 @param mc
 rounding mode and precision for the result of this operation.
 @throws NullPointerException
 if <code>in == null</code>.
 @throws NumberFormatException
 if <code>offset < 0</code> or <code>len <= 0</code> or <code>offset+len-1 < 0</code>
  or <code>offset+len-1 >= in.length</code>.
 @throws NumberFormatException
 if <code>in</code> does not contain a valid string representation
 of a big decimal.
 @throws ArithmeticException
 if <code>mc.precision > 0</code> and <code>mc.roundingMode ==
 UNNECESSARY</code>
  and the new big decimal cannot be represented
 within the given precision without rounding.
 */
- (instancetype)initWithCharArray:(IOSCharArray *)inArg
                          withInt:(jint)offset
                          withInt:(jint)len
          withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from a string representation
 given as a character array.
 The result is rounded according to the
 specified math context.
 @param inArg
 array of characters containing the string representation of
 this <code>BigDecimal</code>.
 @param mc
 rounding mode and precision for the result of this operation.
 @throws NullPointerException
 if <code>in == null</code>.
 @throws NumberFormatException
 if <code>in</code> does not contain a valid string representation
 of a big decimal.
 @throws ArithmeticException
 if <code>mc.precision > 0</code> and <code>mc.roundingMode ==
 UNNECESSARY</code>
  and the new big decimal cannot be represented
 within the given precision without rounding.
 */
- (instancetype)initWithCharArray:(IOSCharArray *)inArg
          withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from the 64bit double
 <code>val</code>.
 The constructed big decimal is equivalent to the given
 double. For example, <code>new BigDecimal(0.1)</code> is equal to <code>0.1000000000000000055511151231257827021181583404541015625</code>
 . This happens
 as <code>0.1</code> cannot be represented exactly in binary.
 <p>
 To generate a big decimal instance which is equivalent to <code>0.1</code> use
 the <code>BigDecimal(String)</code> constructor.
 @param val
 double value to be converted to a <code>BigDecimal</code> instance.
 @throws NumberFormatException
 if <code>val</code> is infinity or not a number.
 */
- (instancetype)initWithDouble:(jdouble)val;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from the 64bit double
 <code>val</code>.
 The constructed big decimal is equivalent to the given
 double. For example, <code>new BigDecimal(0.1)</code> is equal to <code>0.1000000000000000055511151231257827021181583404541015625</code>
 . This happens
 as <code>0.1</code> cannot be represented exactly in binary.
 <p>
 To generate a big decimal instance which is equivalent to <code>0.1</code> use
 the <code>BigDecimal(String)</code> constructor.
 @param val
 double value to be converted to a <code>BigDecimal</code> instance.
 @param mc
 rounding mode and precision for the result of this operation.
 @throws NumberFormatException
 if <code>val</code> is infinity or not a number.
 @throws ArithmeticException
 if <code>mc.precision > 0</code> and <code>mc.roundingMode ==
 UNNECESSARY</code>
  and the new big decimal cannot be represented
 within the given precision without rounding.
 */
- (instancetype)initWithDouble:(jdouble)val
       withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from the given int
 <code>val</code>.
 The scale of the result is 0.
 @param val
 int value to be converted to a <code>BigDecimal</code> instance.
 */
- (instancetype)initWithInt:(jint)val;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from the given int <code>val</code>
 .
 The scale of the result is <code>0</code>. The result is rounded
 according to the specified math context.
 @param val
 int value to be converted to a <code>BigDecimal</code> instance.
 @param mc
 rounding mode and precision for the result of this operation.
 @throws ArithmeticException
 if <code>mc.precision > 0</code> and <code>c.roundingMode ==
 UNNECESSARY</code>
  and the new big decimal cannot be represented
 within the given precision without rounding.
 */
- (instancetype)initWithInt:(jint)val
    withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from the given long <code>val</code>
 .
 The scale of the result is <code>0</code>.
 @param val
 long value to be converted to a <code>BigDecimal</code> instance.
 */
- (instancetype)initWithLong:(jlong)val;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from the given long <code>val</code>
 .
 The scale of the result is <code>0</code>. The result is rounded
 according to the specified math context.
 @param val
 long value to be converted to a <code>BigDecimal</code> instance.
 @param mc
 rounding mode and precision for the result of this operation.
 @throws ArithmeticException
 if <code>mc.precision > 0</code> and <code>mc.roundingMode ==
 UNNECESSARY</code>
  and the new big decimal cannot be represented
 within the given precision without rounding.
 */
- (instancetype)initWithLong:(jlong)val
     withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from a string
 representation.
 @param val
 string containing the string representation of this <code>BigDecimal</code>
 .
 @throws NumberFormatException
 if <code>val</code> does not contain a valid string representation
 of a big decimal.
 */
- (instancetype)initWithNSString:(NSString *)val;

/*!
 @brief Constructs a new <code>BigDecimal</code> instance from a string
 representation.
 The result is rounded according to the specified math
 context.
 @param val
 string containing the string representation of this <code>BigDecimal</code>
 .
 @param mc
 rounding mode and precision for the result of this operation.
 @throws NumberFormatException
 if <code>val</code> does not contain a valid string representation
 of a big decimal.
 @throws ArithmeticException
 if <code>mc.precision > 0</code> and <code>mc.roundingMode ==
 UNNECESSARY</code>
  and the new big decimal cannot be represented
 within the given precision without rounding.
 */
- (instancetype)initWithNSString:(NSString *)val
         withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is the absolute value of
 <code>this</code>.
 The scale of the result is the same as the scale of this.
 @return <code>abs(this)</code>
 */
- (JavaMathBigDecimal *)abs;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is the absolute value of
 <code>this</code>.
 The result is rounded according to the passed context
 <code>mc</code>.
 @param mc
 rounding mode and precision for the result of this operation.
 @return <code>abs(this)</code>
 */
- (JavaMathBigDecimal *)absWithJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this + augend</code>.
 The scale of the result is the maximum of the scales of the two
 arguments.
 @param augend
 value to be added to <code>this</code>.
 @return <code>this + augend</code>.
 @throws NullPointerException
 if <code>augend == null</code>.
 */
- (JavaMathBigDecimal *)addWithJavaMathBigDecimal:(JavaMathBigDecimal *)augend;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this + augend</code>.
 The result is rounded according to the passed context <code>mc</code>.
 @param augend
 value to be added to <code>this</code>.
 @param mc
 rounding mode and precision for the result of this operation.
 @return <code>this + augend</code>.
 @throws NullPointerException
 if <code>augend == null</code> or <code>mc == null</code>.
 */
- (JavaMathBigDecimal *)addWithJavaMathBigDecimal:(JavaMathBigDecimal *)augend
                          withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns this <code>BigDecimal</code> as a byte value if it has no fractional
 part and if its value fits to the byte range ([-128..127]).
 If these
 conditions are not met, an <code>ArithmeticException</code> is thrown.
 @return this <code>BigDecimal</code> as a byte value.
 @throws ArithmeticException
 if rounding is necessary or the number doesn't fit in a byte.
 */
- (jbyte)byteValueExact;

/*!
 @brief Compares this <code>BigDecimal</code> with <code>val</code>.
 Returns one of the
 three values <code>1</code>, <code>0</code>, or <code>-1</code>. The method behaves as
 if <code>this.subtract(val)</code> is computed. If this difference is > 0 then
 1 is returned, if the difference is < 0 then -1 is returned, and if the
 difference is 0 then 0 is returned. This means, that if two decimal
 instances are compared which are equal in value but differ in scale, then
 these two instances are considered as equal.
 @param val
 value to be compared with <code>this</code>.
 @return <code>1</code> if <code>this > val</code>, <code>-1</code> if <code>this < val</code>,
 <code>0</code> if <code>this == val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (jint)compareToWithId:(JavaMathBigDecimal *)val;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this / divisor</code>.
 The scale of the result is the difference of the scales of <code>this</code>
 and <code>divisor</code>. If the exact result requires more digits, then the
 scale is adjusted accordingly. For example, <code>1/128 = 0.0078125</code>
 which has a scale of <code>7</code> and precision <code>5</code>.
 @param divisor
 value by which <code>this</code> is divided.
 @return <code>this / divisor</code>.
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 @throws ArithmeticException
 if the result cannot be represented exactly.
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this / divisor</code>.
 The scale of the result is the scale of <code>this</code>. If rounding is
 required to meet the specified scale, then the specified rounding mode
 <code>roundingMode</code> is applied.
 @param divisor
 value by which <code>this</code> is divided.
 @param roundingMode
 rounding mode to be used to round the result.
 @return <code>this / divisor</code> rounded according to the given rounding
 mode.
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws IllegalArgumentException
 if <code>roundingMode</code> is not a valid rounding mode.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 @throws ArithmeticException
 if <code>roundingMode == ROUND_UNNECESSARY</code> and rounding is
 necessary according to the scale of this.
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                             withInt:(jint)roundingMode;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this / divisor</code>.
 As scale of the result the parameter <code>scale</code> is used. If rounding
 is required to meet the specified scale, then the specified rounding mode
 <code>roundingMode</code> is applied.
 @param divisor
 value by which <code>this</code> is divided.
 @param scale_
 the scale of the result returned.
 @param roundingMode
 rounding mode to be used to round the result.
 @return <code>this / divisor</code> rounded according to the given rounding
 mode.
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws IllegalArgumentException
 if <code>roundingMode</code> is not a valid rounding mode.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 @throws ArithmeticException
 if <code>roundingMode == ROUND_UNNECESSARY</code> and rounding is
 necessary according to the given scale.
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                             withInt:(jint)scale_
                                             withInt:(jint)roundingMode;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this / divisor</code>.
 As scale of the result the parameter <code>scale</code> is used. If rounding
 is required to meet the specified scale, then the specified rounding mode
 <code>roundingMode</code> is applied.
 @param divisor
 value by which <code>this</code> is divided.
 @param scale_
 the scale of the result returned.
 @param roundingMode
 rounding mode to be used to round the result.
 @return <code>this / divisor</code> rounded according to the given rounding
 mode.
 @throws NullPointerException
 if <code>divisor == null</code> or <code>roundingMode == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 @throws ArithmeticException
 if <code>roundingMode == RoundingMode.UNNECESSAR</code>Y and
 rounding is necessary according to the given scale and given
 precision.
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                             withInt:(jint)scale_
                            withJavaMathRoundingMode:(JavaMathRoundingMode *)roundingMode;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this / divisor</code>.
 The result is rounded according to the passed context <code>mc</code>. If the
 passed math context specifies precision <code>0</code>, then this call is
 equivalent to <code>this.divide(divisor)</code>.
 @param divisor
 value by which <code>this</code> is divided.
 @param mc
 rounding mode and precision for the result of this operation.
 @return <code>this / divisor</code>.
 @throws NullPointerException
 if <code>divisor == null</code> or <code>mc == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 @throws ArithmeticException
 if <code>mc.getRoundingMode() == UNNECESSARY</code> and rounding
 is necessary according <code>mc.getPrecision()</code>.
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                             withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this / divisor</code>.
 The scale of the result is the scale of <code>this</code>. If rounding is
 required to meet the specified scale, then the specified rounding mode
 <code>roundingMode</code> is applied.
 @param divisor
 value by which <code>this</code> is divided.
 @param roundingMode
 rounding mode to be used to round the result.
 @return <code>this / divisor</code> rounded according to the given rounding
 mode.
 @throws NullPointerException
 if <code>divisor == null</code> or <code>roundingMode == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 @throws ArithmeticException
 if <code>roundingMode == RoundingMode.UNNECESSARY</code> and
 rounding is necessary according to the scale of this.
 */
- (JavaMathBigDecimal *)divideWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                            withJavaMathRoundingMode:(JavaMathRoundingMode *)roundingMode;

/*!
 @brief Returns a <code>BigDecimal</code> array which contains the integral part of
 <code>this / divisor</code> at index 0 and the remainder <code>this %
 divisor</code>
  at index 1.
 The quotient is rounded down towards zero to the
 next integer.
 @param divisor
 value by which <code>this</code> is divided.
 @return <code>[this.divideToIntegralValue(divisor),
 this.remainder(divisor)]</code>
 .
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 - seealso: #divideToIntegralValue
 - seealso: #remainder
 */
- (IOSObjectArray *)divideAndRemainderWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor;

/*!
 @brief Returns a <code>BigDecimal</code> array which contains the integral part of
 <code>this / divisor</code> at index 0 and the remainder <code>this %
 divisor</code>
  at index 1.
 The quotient is rounded down towards zero to the
 next integer. The rounding mode passed with the parameter <code>mc</code> is
 not considered. But if the precision of <code>mc > 0</code> and the integral
 part requires more digits, then an <code>ArithmeticException</code> is thrown.
 @param divisor
 value by which <code>this</code> is divided.
 @param mc
 math context which determines the maximal precision of the
 result.
 @return <code>[this.divideToIntegralValue(divisor),
 this.remainder(divisor)]</code>
 .
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 - seealso: #divideToIntegralValue
 - seealso: #remainder
 */
- (IOSObjectArray *)divideAndRemainderWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                     withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is the integral part of
 <code>this / divisor</code>.
 The quotient is rounded down towards zero to the
 next integer. For example, <code>0.5/0.2 = 2</code>.
 @param divisor
 value by which <code>this</code> is divided.
 @return integral part of <code>this / divisor</code>.
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 */
- (JavaMathBigDecimal *)divideToIntegralValueWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is the integral part of
 <code>this / divisor</code>.
 The quotient is rounded down towards zero to the
 next integer. The rounding mode passed with the parameter <code>mc</code> is
 not considered. But if the precision of <code>mc > 0</code> and the integral
 part requires more digits, then an <code>ArithmeticException</code> is thrown.
 @param divisor
 value by which <code>this</code> is divided.
 @param mc
 math context which determines the maximal precision of the
 result.
 @return integral part of <code>this / divisor</code>.
 @throws NullPointerException
 if <code>divisor == null</code> or <code>mc == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 @throws ArithmeticException
 if <code>mc.getPrecision() > 0</code> and the result requires more
 digits to be represented.
 */
- (JavaMathBigDecimal *)divideToIntegralValueWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                            withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns this <code>BigDecimal</code> as a double value.
 If <code>this</code> is too
 big to be represented as an float, then <code>Double.POSITIVE_INFINITY</code>
 or <code>Double.NEGATIVE_INFINITY</code> is returned.
 <p>
 Note, that if the unscaled value has more than 53 significant digits,
 then this decimal cannot be represented exactly in a double variable. In
 this case the result is rounded.
 <p>
 For example, if the instance <code>x1 = new BigDecimal("0.1")</code> cannot be
 represented exactly as a double, and thus <code>x1.equals(new
 BigDecimal(x1.doubleValue())</code>
  returns <code>false</code> for this case.
 <p>
 Similarly, if the instance <code>new BigDecimal(9007199254740993L)</code> is
 converted to a double, the result is <code>9.007199254740992E15</code>.
 <p>
 @return this <code>BigDecimal</code> as a double value.
 */
- (jdouble)doubleValue;

/*!
 @brief Returns <code>true</code> if <code>x</code> is a <code>BigDecimal</code> instance and if
 this instance is equal to this big decimal.
 Two big decimals are equal if
 their unscaled value and their scale is equal. For example, 1.0
 (10*10^(-1)) is not equal to 1.00 (100*10^(-2)). Similarly, zero
 instances are not equal if their scale differs.
 @param x
 object to be compared with <code>this</code>.
 @return true if <code>x</code> is a <code>BigDecimal</code> and <code>this == x</code>.
 */
- (jboolean)isEqual:(id)x;

/*!
 @brief Returns this <code>BigDecimal</code> as a float value.
 If <code>this</code> is too
 big to be represented as an float, then <code>Float.POSITIVE_INFINITY</code>
 or <code>Float.NEGATIVE_INFINITY</code> is returned.
 <p>
 Note, that if the unscaled value has more than 24 significant digits,
 then this decimal cannot be represented exactly in a float variable. In
 this case the result is rounded.
 <p>
 For example, if the instance <code>x1 = new BigDecimal("0.1")</code> cannot be
 represented exactly as a float, and thus <code>x1.equals(new
 BigDecimal(x1.folatValue())</code>
  returns <code>false</code> for this case.
 <p>
 Similarly, if the instance <code>new BigDecimal(16777217)</code> is converted
 to a float, the result is <code>1.6777216E</code>7.
 @return this <code>BigDecimal</code> as a float value.
 */
- (jfloat)floatValue;

/*!
 @brief Returns a hash code for this <code>BigDecimal</code>.
 @return hash code for <code>this</code>.
 */
- (NSUInteger)hash;

/*!
 @brief Returns this <code>BigDecimal</code> as an int value.
 Any fractional part is
 discarded. If the integral part of <code>this</code> is too big to be
 represented as an int, then <code>this</code> % 2^32 is returned.
 @return this <code>BigDecimal</code> as a int value.
 */
- (jint)intValue;

/*!
 @brief Returns this <code>BigDecimal</code> as a int value if it has no fractional
 part and if its value fits to the int range ([-2^{31}..2^{31}-1]).
 If
 these conditions are not met, an <code>ArithmeticException</code> is thrown.
 @return this <code>BigDecimal</code> as a int value.
 @throws ArithmeticException
 if rounding is necessary or the number doesn't fit in a int.
 */
- (jint)intValueExact;

/*!
 @brief Returns this <code>BigDecimal</code> as an long value.
 Any fractional part is
 discarded. If the integral part of <code>this</code> is too big to be
 represented as an long, then <code>this</code> % 2^64 is returned.
 @return this <code>BigDecimal</code> as a long value.
 */
- (jlong)longLongValue;

/*!
 @brief Returns this <code>BigDecimal</code> as a long value if it has no fractional
 part and if its value fits to the int range ([-2^{63}..2^{63}-1]).
 If
 these conditions are not met, an <code>ArithmeticException</code> is thrown.
 @return this <code>BigDecimal</code> as a long value.
 @throws ArithmeticException
 if rounding is necessary or the number doesn't fit in a long.
 */
- (jlong)longValueExact;

/*!
 @brief Returns the maximum of this <code>BigDecimal</code> and <code>val</code>.
 @param val
 value to be used to compute the maximum with this.
 @return <code>max(this, val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigDecimal *)maxWithJavaMathBigDecimal:(JavaMathBigDecimal *)val;

/*!
 @brief Returns the minimum of this <code>BigDecimal</code> and <code>val</code>.
 @param val
 value to be used to compute the minimum with this.
 @return <code>min(this, val</code>.
 @throws NullPointerException
 if <code>val == null</code>.
 */
- (JavaMathBigDecimal *)minWithJavaMathBigDecimal:(JavaMathBigDecimal *)val;

/*!
 @brief Returns a new <code>BigDecimal</code> instance where the decimal point has
 been moved <code>n</code> places to the left.
 If <code>n < 0</code> then the
 decimal point is moved <code>-n</code> places to the right.
 <p>
 The result is obtained by changing its scale. If the scale of the result
 becomes negative, then its precision is increased such that the scale is
 zero.
 <p>
 Note, that <code>movePointLeft(0)</code> returns a result which is
 mathematically equivalent, but which has <code>scale >= 0</code>.
 @param n
 number of placed the decimal point has to be moved.
 @return <code>this * 10^(-n</code>).
 */
- (JavaMathBigDecimal *)movePointLeftWithInt:(jint)n;

/*!
 @brief Returns a new <code>BigDecimal</code> instance where the decimal point has
 been moved <code>n</code> places to the right.
 If <code>n < 0</code> then the
 decimal point is moved <code>-n</code> places to the left.
 <p>
 The result is obtained by changing its scale. If the scale of the result
 becomes negative, then its precision is increased such that the scale is
 zero.
 <p>
 Note, that <code>movePointRight(0)</code> returns a result which is
 mathematically equivalent, but which has scale >= 0.
 @param n
 number of placed the decimal point has to be moved.
 @return <code>this * 10^n</code>.
 */
- (JavaMathBigDecimal *)movePointRightWithInt:(jint)n;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this 
 multiplicand</code>
 .
 The scale of the result is the sum of the scales of the
 two arguments.
 @param multiplicand
 value to be multiplied with <code>this</code>.
 @return <code>this * multiplicand</code>.
 @throws NullPointerException
 if <code>multiplicand == null</code>.
 */
- (JavaMathBigDecimal *)multiplyWithJavaMathBigDecimal:(JavaMathBigDecimal *)multiplicand;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this 
 multiplicand</code>
 .
 The result is rounded according to the passed context
 <code>mc</code>.
 @param multiplicand
 value to be multiplied with <code>this</code>.
 @param mc
 rounding mode and precision for the result of this operation.
 @return <code>this * multiplicand</code>.
 @throws NullPointerException
 if <code>multiplicand == null</code> or <code>mc == null</code>.
 */
- (JavaMathBigDecimal *)multiplyWithJavaMathBigDecimal:(JavaMathBigDecimal *)multiplicand
                               withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is the <code>-this</code>.
 The
 scale of the result is the same as the scale of this.
 @return <code>-this</code>
 */
- (JavaMathBigDecimal *)negate;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is the <code>-this</code>.
 The
 result is rounded according to the passed context <code>mc</code>.
 @param mc
 rounding mode and precision for the result of this operation.
 @return <code>-this</code>
 */
- (JavaMathBigDecimal *)negateWithJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>+this</code>.
 The scale
 of the result is the same as the scale of this.
 @return <code>this</code>
 */
- (JavaMathBigDecimal *)plus;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>+this</code>.
 The result
 is rounded according to the passed context <code>mc</code>.
 @param mc
 rounding mode and precision for the result of this operation.
 @return <code>this</code>, rounded
 */
- (JavaMathBigDecimal *)plusWithJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this ^ n</code>.
 The
 scale of the result is <code>n</code> times the scales of <code>this</code>.
 <p>
 <code>x.pow(0)</code> returns <code>1</code>, even if <code>x == 0</code>.
 <p>
 Implementation Note: The implementation is based on the ANSI standard
 X3.274-1996 algorithm.
 @param n
 exponent to which <code>this</code> is raised.
 @return <code>this ^ n</code>.
 @throws ArithmeticException
 if <code>n < 0</code> or <code>n > 999999999</code>.
 */
- (JavaMathBigDecimal *)powWithInt:(jint)n;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this ^ n</code>.
 The
 result is rounded according to the passed context <code>mc</code>.
 <p>
 Implementation Note: The implementation is based on the ANSI standard
 X3.274-1996 algorithm.
 @param n
 exponent to which <code>this</code> is raised.
 @param mc
 rounding mode and precision for the result of this operation.
 @return <code>this ^ n</code>.
 @throws ArithmeticException
 if <code>n < 0</code> or <code>n > 999999999</code>.
 */
- (JavaMathBigDecimal *)powWithInt:(jint)n
           withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns the precision of this <code>BigDecimal</code>.
 The precision is the
 number of decimal digits used to represent this decimal. It is equivalent
 to the number of digits of the unscaled value. The precision of <code>0</code>
 is <code>1</code> (independent of the scale).
 @return the precision of this <code>BigDecimal</code>.
 */
- (jint)precision;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this % divisor</code>.
 <p>
 The remainder is defined as <code>this -
 this.divideToIntegralValue(divisor) * divisor</code>
 .
 @param divisor
 value by which <code>this</code> is divided.
 @return <code>this % divisor</code>.
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 */
- (JavaMathBigDecimal *)remainderWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this % divisor</code>.
 <p>
 The remainder is defined as <code>this -
 this.divideToIntegralValue(divisor) * divisor</code>
 .
 <p>
 The specified rounding mode <code>mc</code> is used for the division only.
 @param divisor
 value by which <code>this</code> is divided.
 @param mc
 rounding mode and precision to be used.
 @return <code>this % divisor</code>.
 @throws NullPointerException
 if <code>divisor == null</code>.
 @throws ArithmeticException
 if <code>divisor == 0</code>.
 @throws ArithmeticException
 if <code>mc.getPrecision() > 0</code> and the result of <code>this.divideToIntegralValue(divisor, mc)</code>
  requires more digits
 to be represented.
 */
- (JavaMathBigDecimal *)remainderWithJavaMathBigDecimal:(JavaMathBigDecimal *)divisor
                                withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this</code>, rounded
 according to the passed context <code>mc</code>.
 <p>
 If <code>mc.precision = 0</code>, then no rounding is performed.
 <p>
 If <code>mc.precision > 0</code> and <code>mc.roundingMode == UNNECESSARY</code>,
 then an <code>ArithmeticException</code> is thrown if the result cannot be
 represented exactly within the given precision.
 @param mc
 rounding mode and precision for the result of this operation.
 @return <code>this</code> rounded according to the passed context.
 @throws ArithmeticException
 if <code>mc.precision > 0</code> and <code>mc.roundingMode ==
 UNNECESSARY</code>
  and this cannot be represented within the given
 precision.
 */
- (JavaMathBigDecimal *)roundWithJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns the scale of this <code>BigDecimal</code>.
 The scale is the number of
 digits behind the decimal point. The value of this <code>BigDecimal</code> is
 the unsignedValue * 10^(-scale). If the scale is negative, then this
 <code>BigDecimal</code> represents a big integer.
 @return the scale of this <code>BigDecimal</code>.
 */
- (jint)scale__;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this</code> 10^<code>n</code>.
 The scale of the result is <code>this.scale()</code> - <code>n</code>.
 The precision of the result is the precision of <code>this</code>.
 <p>
 This method has the same effect as <code>movePointRight</code>, except that
 the precision is not changed.
 @param n
 number of places the decimal point has to be moved.
 @return <code>this * 10^n</code>
 */
- (JavaMathBigDecimal *)scaleByPowerOfTenWithInt:(jint)n;

/*!
 @brief Returns a new <code>BigDecimal</code> instance with the specified scale.
 If
 the new scale is greater than the old scale, then additional zeros are
 added to the unscaled value. If the new scale is smaller than the old
 scale, then trailing zeros are removed. If the trailing digits are not
 zeros then an ArithmeticException is thrown.
 <p>
 If no exception is thrown, then the following equation holds: <code>x.setScale(s).compareTo(x) == 0</code>
 .
 @param newScale
 scale of the result returned.
 @return a new <code>BigDecimal</code> instance with the specified scale.
 @throws ArithmeticException
 if rounding would be necessary.
 */
- (JavaMathBigDecimal *)setScaleWithInt:(jint)newScale;

/*!
 @brief Returns a new <code>BigDecimal</code> instance with the specified scale.
 <p>
 If the new scale is greater than the old scale, then additional zeros are
 added to the unscaled value. In this case no rounding is necessary.
 <p>
 If the new scale is smaller than the old scale, then trailing digits are
 removed. If these trailing digits are not zero, then the remaining
 unscaled value has to be rounded. For this rounding operation the
 specified rounding mode is used.
 @param newScale
 scale of the result returned.
 @param roundingMode
 rounding mode to be used to round the result.
 @return a new <code>BigDecimal</code> instance with the specified scale.
 @throws IllegalArgumentException
 if <code>roundingMode</code> is not a valid rounding mode.
 @throws ArithmeticException
 if <code>roundingMode == ROUND_UNNECESSARY</code> and rounding is
 necessary according to the given scale.
 */
- (JavaMathBigDecimal *)setScaleWithInt:(jint)newScale
                                withInt:(jint)roundingMode;

/*!
 @brief Returns a new <code>BigDecimal</code> instance with the specified scale.
 <p>
 If the new scale is greater than the old scale, then additional zeros are
 added to the unscaled value. In this case no rounding is necessary.
 <p>
 If the new scale is smaller than the old scale, then trailing digits are
 removed. If these trailing digits are not zero, then the remaining
 unscaled value has to be rounded. For this rounding operation the
 specified rounding mode is used.
 @param newScale
 scale of the result returned.
 @param roundingMode
 rounding mode to be used to round the result.
 @return a new <code>BigDecimal</code> instance with the specified scale.
 @throws NullPointerException
 if <code>roundingMode == null</code>.
 @throws ArithmeticException
 if <code>roundingMode == ROUND_UNNECESSARY</code> and rounding is
 necessary according to the given scale.
 */
- (JavaMathBigDecimal *)setScaleWithInt:(jint)newScale
               withJavaMathRoundingMode:(JavaMathRoundingMode *)roundingMode;

/*!
 @brief Returns this <code>BigDecimal</code> as a short value if it has no fractional
 part and if its value fits to the short range ([-2^{15}..2^{15}-1]).
 If
 these conditions are not met, an <code>ArithmeticException</code> is thrown.
 @return this <code>BigDecimal</code> as a short value.
 @throws ArithmeticException
 if rounding is necessary of the number doesn't fit in a
 short.
 */
- (jshort)shortValueExact;

/*!
 @brief Returns the sign of this <code>BigDecimal</code>.
 @return <code>-1</code> if <code>this < 0</code>,
 <code>0</code> if <code>this == 0</code>,
 <code>1</code> if <code>this > 0</code>.
 */
- (jint)signum;

/*!
 @brief Returns a new <code>BigDecimal</code> instance with the same value as <code>this</code>
  but with a unscaled value where the trailing zeros have been
 removed.
 If the unscaled value of <code>this</code> has n trailing zeros, then
 the scale and the precision of the result has been reduced by n.
 @return a new <code>BigDecimal</code> instance equivalent to this where the
 trailing zeros of the unscaled value have been removed.
 */
- (JavaMathBigDecimal *)stripTrailingZeros;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this - subtrahend</code>.
 The scale of the result is the maximum of the scales of the two arguments.
 @param subtrahend
 value to be subtracted from <code>this</code>.
 @return <code>this - subtrahend</code>.
 @throws NullPointerException
 if <code>subtrahend == null</code>.
 */
- (JavaMathBigDecimal *)subtractWithJavaMathBigDecimal:(JavaMathBigDecimal *)subtrahend;

/*!
 @brief Returns a new <code>BigDecimal</code> whose value is <code>this - subtrahend</code>.
 The result is rounded according to the passed context <code>mc</code>.
 @param subtrahend
 value to be subtracted from <code>this</code>.
 @param mc
 rounding mode and precision for the result of this operation.
 @return <code>this - subtrahend</code>.
 @throws NullPointerException
 if <code>subtrahend == null</code> or <code>mc == null</code>.
 */
- (JavaMathBigDecimal *)subtractWithJavaMathBigDecimal:(JavaMathBigDecimal *)subtrahend
                               withJavaMathMathContext:(JavaMathMathContext *)mc;

/*!
 @brief Returns this <code>BigDecimal</code> as a big integer instance.
 A fractional
 part is discarded.
 @return this <code>BigDecimal</code> as a big integer instance.
 */
- (JavaMathBigInteger *)toBigInteger;

/*!
 @brief Returns this <code>BigDecimal</code> as a big integer instance if it has no
 fractional part.
 If this <code>BigDecimal</code> has a fractional part, i.e.
 if rounding would be necessary, an <code>ArithmeticException</code> is thrown.
 @return this <code>BigDecimal</code> as a big integer value.
 @throws ArithmeticException
 if rounding is necessary.
 */
- (JavaMathBigInteger *)toBigIntegerExact;

/*!
 @brief Returns a string representation of this <code>BigDecimal</code>.
 This
 representation always prints all significant digits of this value.
 <p>
 If the scale is negative or if <code>scale - precision >= 6</code> then
 engineering notation is used. Engineering notation is similar to the
 scientific notation except that the exponent is made to be a multiple of
 3 such that the integer part is >= 1 and < 1000.
 @return a string representation of <code>this</code> in engineering notation
 if necessary.
 */
- (NSString *)toEngineeringString;

/*!
 @brief Returns a string representation of this <code>BigDecimal</code>.
 No scientific
 notation is used. This methods adds zeros where necessary.
 <p>
 If this string representation is used to create a new instance, this
 instance is generally not identical to <code>this</code> as the precision
 changes.
 <p>
 <code>x.equals(new BigDecimal(x.toPlainString())</code> usually returns
 <code>false</code>.
 <p>
 <code>x.compareTo(new BigDecimal(x.toPlainString())</code> returns <code>0</code>.
 @return a string representation of <code>this</code> without exponent part.
 */
- (NSString *)toPlainString;

/*!
 @brief Returns a canonical string representation of this <code>BigDecimal</code>.
 If
 necessary, scientific notation is used. This representation always prints
 all significant digits of this value.
 <p>
 If the scale is negative or if <code>scale - precision >= 6</code> then
 scientific notation is used.
 @return a string representation of <code>this</code> in scientific notation if
 necessary.
 */
- (NSString *)description;

/*!
 @brief Returns the unit in the last place (ULP) of this <code>BigDecimal</code>
 instance.
 An ULP is the distance to the nearest big decimal with the same
 precision.
 <p>
 The amount of a rounding error in the evaluation of a floating-point
 operation is often expressed in ULPs. An error of 1 ULP is often seen as
 a tolerable error.
 <p>
 For class <code>BigDecimal</code>, the ULP of a number is simply 10^(-scale).
 <p>
 For example, <code>new BigDecimal(0.1).ulp()</code> returns <code>1E-55</code>.
 @return unit in the last place (ULP) of this <code>BigDecimal</code> instance.
 */
- (JavaMathBigDecimal *)ulp;

/*!
 @brief Returns the unscaled value (mantissa) of this <code>BigDecimal</code> instance
 as a <code>BigInteger</code>.
 The unscaled value can be computed as <code>this</code>
  10^(scale).
 @return unscaled value (this * 10^(scale)).
 */
- (JavaMathBigInteger *)unscaledValue;

/*!
 @brief Returns a new <code>BigDecimal</code> instance whose value is equal to <code>val</code>
 .
 The new decimal is constructed as if the <code>BigDecimal(String)</code>
 constructor is called with an argument which is equal to <code>Double.toString(val)</code>
 . For example, <code>valueOf("0.1")</code> is converted to
 (unscaled=1, scale=1), although the double <code>0.1</code> cannot be
 represented exactly as a double value. In contrast to that, a new <code>BigDecimal(0.1)</code>
  instance has the value <code>0.1000000000000000055511151231257827021181583404541015625</code>
  with an
 unscaled value <code>1000000000000000055511151231257827021181583404541015625</code>
 and the scale <code>55</code>.
 @param val
 double value to be converted to a <code>BigDecimal</code>.
 @return <code>BigDecimal</code> instance with the value <code>val</code>.
 @throws NumberFormatException
 if <code>val</code> is infinite or <code>val</code> is not a number
 */
+ (JavaMathBigDecimal *)valueOfWithDouble:(jdouble)val;

/*!
 @brief Returns a new <code>BigDecimal</code> instance whose value is equal to <code>unscaledVal</code>
 .
 The scale of the result is <code>0</code>, and its unscaled
 value is <code>unscaledVal</code>.
 @param unscaledVal
 value to be converted to a <code>BigDecimal</code>.
 @return <code>BigDecimal</code> instance with the value <code>unscaledVal</code>.
 */
+ (JavaMathBigDecimal *)valueOfWithLong:(jlong)unscaledVal;

/*!
 @brief Returns a new <code>BigDecimal</code> instance whose value is equal to <code>unscaledVal</code>
  10^(-<code>scale</code>).
 The scale of the result is <code>scale</code>
 , and its unscaled value is <code>unscaledVal</code>.
 @param unscaledVal
 unscaled value to be used to construct the new <code>BigDecimal</code>
 .
 @param scale_
 scale to be used to construct the new <code>BigDecimal</code>.
 @return <code>BigDecimal</code> instance with the value <code>unscaledVal</code>
 10^(-<code>unscaledVal</code>).
 */
+ (JavaMathBigDecimal *)valueOfWithLong:(jlong)unscaledVal
                                withInt:(jint)scale_;

#pragma mark Package-Private

@end

J2OBJC_STATIC_INIT(JavaMathBigDecimal)

/*!
 @brief The constant zero as a <code>BigDecimal</code>.
 */
inline JavaMathBigDecimal *JavaMathBigDecimal_get_ZERO();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_ZERO;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigDecimal, ZERO, JavaMathBigDecimal *)

/*!
 @brief The constant one as a <code>BigDecimal</code>.
 */
inline JavaMathBigDecimal *JavaMathBigDecimal_get_ONE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_ONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigDecimal, ONE, JavaMathBigDecimal *)

/*!
 @brief The constant ten as a <code>BigDecimal</code>.
 */
inline JavaMathBigDecimal *JavaMathBigDecimal_get_TEN();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_TEN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaMathBigDecimal, TEN, JavaMathBigDecimal *)

/*!
 @brief Rounding mode where positive values are rounded towards positive infinity
 and negative values towards negative infinity.
 - seealso: RoundingMode#UP
 */
inline jint JavaMathBigDecimal_get_ROUND_UP();
#define JavaMathBigDecimal_ROUND_UP 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_UP, jint)

/*!
 @brief Rounding mode where the values are rounded towards zero.
 - seealso: RoundingMode#DOWN
 */
inline jint JavaMathBigDecimal_get_ROUND_DOWN();
#define JavaMathBigDecimal_ROUND_DOWN 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_DOWN, jint)

/*!
 @brief Rounding mode to round towards positive infinity.
 For positive values
 this rounding mode behaves as <code>ROUND_UP</code>, for negative values as
 <code>ROUND_DOWN</code>.
 - seealso: RoundingMode#CEILING
 */
inline jint JavaMathBigDecimal_get_ROUND_CEILING();
#define JavaMathBigDecimal_ROUND_CEILING 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_CEILING, jint)

/*!
 @brief Rounding mode to round towards negative infinity.
 For positive values
 this rounding mode behaves as <code>ROUND_DOWN</code>, for negative values as
 <code>ROUND_UP</code>.
 - seealso: RoundingMode#FLOOR
 */
inline jint JavaMathBigDecimal_get_ROUND_FLOOR();
#define JavaMathBigDecimal_ROUND_FLOOR 3
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_FLOOR, jint)

/*!
 @brief Rounding mode where values are rounded towards the nearest neighbor.
 Ties are broken by rounding up.
 - seealso: RoundingMode#HALF_UP
 */
inline jint JavaMathBigDecimal_get_ROUND_HALF_UP();
#define JavaMathBigDecimal_ROUND_HALF_UP 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_HALF_UP, jint)

/*!
 @brief Rounding mode where values are rounded towards the nearest neighbor.
 Ties are broken by rounding down.
 - seealso: RoundingMode#HALF_DOWN
 */
inline jint JavaMathBigDecimal_get_ROUND_HALF_DOWN();
#define JavaMathBigDecimal_ROUND_HALF_DOWN 5
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_HALF_DOWN, jint)

/*!
 @brief Rounding mode where values are rounded towards the nearest neighbor.
 Ties are broken by rounding to the even neighbor.
 - seealso: RoundingMode#HALF_EVEN
 */
inline jint JavaMathBigDecimal_get_ROUND_HALF_EVEN();
#define JavaMathBigDecimal_ROUND_HALF_EVEN 6
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_HALF_EVEN, jint)

/*!
 @brief Rounding mode where the rounding operations throws an <code>ArithmeticException</code>
  for the case that rounding is necessary, i.e. for
 the case that the value cannot be represented exactly.
 - seealso: RoundingMode#UNNECESSARY
 */
inline jint JavaMathBigDecimal_get_ROUND_UNNECESSARY();
#define JavaMathBigDecimal_ROUND_UNNECESSARY 7
J2OBJC_STATIC_FIELD_CONSTANT(JavaMathBigDecimal, ROUND_UNNECESSARY, jint)

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithCharArray_withInt_withInt_(JavaMathBigDecimal *self, IOSCharArray *inArg, jint offset, jint len);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithCharArray_withInt_withInt_(IOSCharArray *inArg, jint offset, jint len) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithCharArray_withInt_withInt_withJavaMathMathContext_(JavaMathBigDecimal *self, IOSCharArray *inArg, jint offset, jint len, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithCharArray_withInt_withInt_withJavaMathMathContext_(IOSCharArray *inArg, jint offset, jint len, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithCharArray_(JavaMathBigDecimal *self, IOSCharArray *inArg);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithCharArray_(IOSCharArray *inArg) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithCharArray_withJavaMathMathContext_(JavaMathBigDecimal *self, IOSCharArray *inArg, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithCharArray_withJavaMathMathContext_(IOSCharArray *inArg, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithNSString_(JavaMathBigDecimal *self, NSString *val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithNSString_(NSString *val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithNSString_withJavaMathMathContext_(JavaMathBigDecimal *self, NSString *val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithNSString_withJavaMathMathContext_(NSString *val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithDouble_(JavaMathBigDecimal *self, jdouble val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithDouble_(jdouble val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithDouble_withJavaMathMathContext_(JavaMathBigDecimal *self, jdouble val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithDouble_withJavaMathMathContext_(jdouble val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithJavaMathBigInteger_(JavaMathBigDecimal *self, JavaMathBigInteger *val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithJavaMathBigInteger_(JavaMathBigInteger *val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithJavaMathBigInteger_withJavaMathMathContext_(JavaMathBigDecimal *self, JavaMathBigInteger *val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithJavaMathBigInteger_withJavaMathMathContext_(JavaMathBigInteger *val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_(JavaMathBigDecimal *self, JavaMathBigInteger *unscaledVal, jint scale_);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_(JavaMathBigInteger *unscaledVal, jint scale_) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_withJavaMathMathContext_(JavaMathBigDecimal *self, JavaMathBigInteger *unscaledVal, jint scale_, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithJavaMathBigInteger_withInt_withJavaMathMathContext_(JavaMathBigInteger *unscaledVal, jint scale_, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithInt_(JavaMathBigDecimal *self, jint val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithInt_(jint val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithInt_withJavaMathMathContext_(JavaMathBigDecimal *self, jint val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithInt_withJavaMathMathContext_(jint val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithLong_(JavaMathBigDecimal *self, jlong val);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithLong_(jlong val) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaMathBigDecimal_initWithLong_withJavaMathMathContext_(JavaMathBigDecimal *self, jlong val, JavaMathMathContext *mc);

FOUNDATION_EXPORT JavaMathBigDecimal *new_JavaMathBigDecimal_initWithLong_withJavaMathMathContext_(jlong val, JavaMathMathContext *mc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_valueOfWithLong_withInt_(jlong unscaledVal, jint scale_);

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_valueOfWithLong_(jlong unscaledVal);

FOUNDATION_EXPORT JavaMathBigDecimal *JavaMathBigDecimal_valueOfWithDouble_(jdouble val);

J2OBJC_TYPE_LITERAL_HEADER(JavaMathBigDecimal)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaMathBigDecimal_INCLUDE_ALL")

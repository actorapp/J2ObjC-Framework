//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/net/InetAddress.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaNetInetAddress_INCLUDE_ALL")
#ifdef JavaNetInetAddress_RESTRICT
#define JavaNetInetAddress_INCLUDE_ALL 0
#else
#define JavaNetInetAddress_INCLUDE_ALL 1
#endif
#undef JavaNetInetAddress_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaNetInetAddress_) && (JavaNetInetAddress_INCLUDE_ALL || defined(JavaNetInetAddress_INCLUDE))
#define JavaNetInetAddress_

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../java/io/Serializable.h"

@class IOSByteArray;
@class IOSObjectArray;
@class JavaNetNetworkInterface;

/*!
 @brief An Internet Protocol (IP) address.
 This can be either an IPv4 address or an IPv6 address, and
 in practice you'll have an instance of either <code>Inet4Address</code> or <code>Inet6Address</code> (this
 class cannot be instantiated directly). Most code does not need to distinguish between the two
 families, and should use <code>InetAddress</code>.
 <p>An <code>InetAddress</code> may have a hostname (accessible via <code>getHostName</code>), but may not,
 depending on how the <code>InetAddress</code> was created.
 <h4>IPv4 numeric address formats</h4>
 <p>The <code>getAllByName</code> method accepts IPv4 addresses in the "decimal-dotted-quad" form only:
 <ul>
 <li><code>"1.2.3.4"</code> - 1.2.3.4
 </ul>
 <h4>IPv6 numeric address formats</h4>
 <p>The <code>getAllByName</code> method accepts IPv6 addresses in the following forms (this text
 comes from <a href="http://www.ietf.org/rfc/rfc2373.txt">RFC 2373</a>, which you should consult
 for full details of IPv6 addressing):
 <ul>
 <li><p>The preferred form is <code>x:x:x:x:x:x:x:x</code>, where the 'x's are the
 hexadecimal values of the eight 16-bit pieces of the address.
 Note that it is not necessary to write the leading zeros in an
 individual field, but there must be at least one numeral in every
 field (except for the case described in the next bullet).
 Examples:
 @code

     FEDC:BA98:7654:3210:FEDC:BA98:7654:3210
     
@endcode
 </li>
 <li>Due to some methods of allocating certain styles of IPv6
 addresses, it will be common for addresses to contain long strings
 of zero bits.  In order to make writing addresses containing zero
 bits easier a special syntax is available to compress the zeros.
 The use of "::" indicates multiple groups of 16-bits of zeros.
 The "::" can only appear once in an address.  The "::" can also be
 used to compress the leading and/or trailing zeros in an address.
 For example the following addresses:
 @code

     1080:0:0:0:8:800:200C:417A  a unicast address
     FF01:0:0:0:0:0:0:101        a multicast address
     0:0:0:0:0:0:0:1             the loopback address
     
@endcode
 may be represented as:
 @code

     1080::8:800:200C:417A       a unicast address
     FF01::101                   a multicast address
     ::1                         the loopback address
     
@endcode
 </li>
 <li><p>An alternative form that is sometimes more convenient when dealing
 with a mixed environment of IPv4 and IPv6 nodes is
 <code>x:x:x:x:x:x:d.d.d.d</code>, where the 'x's are the hexadecimal values of
 the six high-order 16-bit pieces of the address, and the 'd's are
 the decimal values of the four low-order 8-bit pieces of the
 address (standard IPv4 representation).  Examples:
 @code

     0:0:0:0:0:0:13.1.68.3
     
@endcode
 or in compressed form:
 @code

     ::13.1.68.3
     
@endcode
 </li>
 </ul>
 <p>Scopes are given using a trailing <code>%</code> followed by the scope id, as in
 <code>1080::8:800:200C:417A%2</code> or <code>1080::8:800:200C:417A%en0</code>.
 See <a href="https://www.ietf.org/rfc/rfc4007.txt">RFC 4007</a> for more on IPv6's scoped
 address architecture.
 <p>Additionally, for backwards compatibility, IPv6 addresses may be surrounded by square
 brackets.
 <h4>DNS caching</h4>
 <p>In Android 4.0 (Ice Cream Sandwich) and earlier, DNS caching was performed both by
 InetAddress and by the C library, which meant that DNS TTLs could not be honored correctly.
 In later releases, caching is done solely by the C library and DNS TTLs are honored.
 - seealso: Inet4Address
 - seealso: Inet6Address
 */
@interface JavaNetInetAddress : NSObject < JavaIoSerializable > {
 @public
  IOSByteArray *ipaddress_;
  NSString *hostName_;
}

+ (JavaNetInetAddress *)UNSPECIFIED;

#pragma mark Public

/*!
 @brief Removes all entries from the VM's DNS cache.
 This does not affect the C library's DNS
 cache, nor any caching DNS servers between you and the canonical server.
 */
+ (void)clearDnsCache;

/*!
 @brief Compares this <code>InetAddress</code> instance against the specified address
 in <code>obj</code>.
 Two addresses are equal if their address byte arrays have
 the same length and if the bytes in the arrays are equal.
 @param obj
 the object to be tested for equality.
 @return <code>true</code> if both objects are equal, <code>false</code> otherwise.
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Returns the IP address represented by this <code>InetAddress</code> instance
 as a byte array.
 The elements are in network order (the highest order
 address byte is in the zeroth element).
 @return the address in form of a byte array.
 */
- (IOSByteArray *)getAddress;

/*!
 @brief Gets all IP addresses associated with the given <code>host</code> identified
 by name or literal IP address.
 The IP address is resolved by the
 configured name service. If the host name is empty or <code>null</code> an
 <code>UnknownHostException</code> is thrown. If the host name is a literal IP
 address string an array with the corresponding single <code>InetAddress</code>
 is returned.
 @param host the hostname or literal IP string to be resolved.
 @return the array of addresses associated with the specified host.
 @throws UnknownHostException if the address lookup fails.
 */
+ (IOSObjectArray *)getAllByNameWithNSString:(NSString *)host;

/*!
 @brief Equivalent to <code>getByAddress(null, ipAddress)</code>.
 Handy for addresses with
 no associated hostname.
 */
+ (JavaNetInetAddress *)getByAddressWithByteArray:(IOSByteArray *)ipAddress;

/*!
 @brief Returns an <code>InetAddress</code> corresponding to the given network-order
 bytes <code>ipAddress</code> and <code>scopeId</code>.
 <p>For an IPv4 address, the byte array must be of length 4.
 For IPv6, the byte array must be of length 16. Any other length will cause an <code>UnknownHostException</code>
 .
 <p>No reverse lookup is performed. The given <code>hostName</code> (which may be null) is
 associated with the new <code>InetAddress</code> with no validation done.
 <p>(Note that numeric addresses such as <code>"127.0.0.1"</code> are names for the
 purposes of this API. Most callers probably want <code>getAllByName</code> instead.)
 @throws UnknownHostException if <code>ipAddress</code> is null or the wrong length.
 */
+ (JavaNetInetAddress *)getByAddressWithNSString:(NSString *)hostName
                                   withByteArray:(IOSByteArray *)ipAddress;

+ (JavaNetInetAddress *)getByAddressWithNSString:(NSString *)hostName
                                   withByteArray:(IOSByteArray *)ipAddress
                                         withInt:(jint)scopeId;

/*!
 @brief Returns the address of a host according to the given host string name
 <code>host</code>.
 The host string may be either a machine name or a dotted
 string IP address. If the latter, the <code>hostName</code> field is
 determined upon demand. <code>host</code> can be <code>null</code> which means that
 an address of the loopback interface is returned.
 @param host
 the hostName to be resolved to an address or <code>null</code>.
 @return the <code>InetAddress</code> instance representing the host.
 @throws UnknownHostException
 if the address lookup fails.
 */
+ (JavaNetInetAddress *)getByNameWithNSString:(NSString *)host;

/*!
 @brief Returns the fully qualified hostname corresponding to this IP address.
 */
- (NSString *)getCanonicalHostName;

- (jint)getFamily;

/*!
 @brief Returns the numeric representation of this IP address (such as "127.0.0.1").
 */
- (NSString *)getHostAddress;

/*!
 @brief Returns the host name corresponding to this IP address.
 This may or may not be a
 fully-qualified name. If the IP address could not be resolved, the numeric representation
 is returned instead (see <code>getHostAddress</code>).
 */
- (NSString *)getHostName;

/*!
 @brief Returns an <code>InetAddress</code> for the local host if possible, or the
 loopback address otherwise.
 This method works by getting the hostname,
 performing a DNS lookup, and then taking the first returned address.
 For devices with multiple network interfaces and/or multiple addresses
 per interface, this does not necessarily return the <code>InetAddress</code>
 you want.
 <p>Multiple interface/address configurations were relatively rare
 when this API was designed, but multiple interfaces are the default for
 modern mobile devices (with separate wifi and radio interfaces), and
 the need to support both IPv4 and IPv6 has made multiple addresses
 commonplace. New code should thus avoid this method except where it's
 basically being used to get a loopback address or equivalent.
 <p>There are two main ways to get a more specific answer:
 <ul>
 <li>If you have a connected socket, you should probably use
 <code>Socket.getLocalAddress</code> instead: that will give you the address
 that's actually in use for that connection. (It's not possible to ask
 the question "what local address would a connection to a given remote
 address use?"; you have to actually make the connection and see.)</li>
 <li>For other use cases, see <code>NetworkInterface</code>, which lets you
 enumerate all available network interfaces and their addresses.</li>
 </ul>
 <p>Note that if the host doesn't have a hostname set&nbsp;&ndash; as
 Android devices typically don't&nbsp;&ndash; this method will
 effectively return the loopback address, albeit by getting the name
 <code>localhost</code> and then doing a lookup to translate that to
 <code>127.0.0.1</code>.
 @return an <code>InetAddress</code> representing the local host, or the
 loopback address.
 @throws UnknownHostException
 if the address lookup fails.
 */
+ (JavaNetInetAddress *)getLocalHost;

/*!
 @brief Returns the IPv6 loopback address <code>::1</code> or the IPv4 loopback address <code>127.0.0.1</code>.
 @since 1.7
 */
+ (JavaNetInetAddress *)getLoopbackAddress;

/*!
 @brief Gets the hashcode of the represented IP address.
 @return the appropriate hashcode value.
 */
- (NSUInteger)hash;

/*!
 @brief Returns whether this is the IPv6 unspecified wildcard address <code>::</code>
 or the IPv4 "any" address, <code>0.0.0.0</code>.
 */
- (jboolean)isAnyLocalAddress;

/*!
 @brief Returns whether this address is a link-local address or not.
 <p>Valid IPv6 link-local addresses have the prefix <code>fe80::/10</code>.
 <p><a href="http://www.ietf.org/rfc/rfc3484.txt">RFC 3484</a>
 "Default Address Selection for Internet Protocol Version 6 (IPv6)" states
 that both IPv4 auto-configuration addresses (prefix <code>169.254/16</code>) and
 IPv4 loopback addresses (prefix <code>127/8</code>) have link-local scope, but
 <code>Inet4Address</code> only considers the auto-configuration addresses
 to have link-local scope. That is: the IPv4 loopback address returns false.
 */
- (jboolean)isLinkLocalAddress;

/*!
 @brief Returns whether this address is a loopback address or not.
 <p>Valid IPv4 loopback addresses have the prefix <code>127/8</code>.
 <p>The only valid IPv6 loopback address is <code>::1</code>.
 */
- (jboolean)isLoopbackAddress;

/*!
 @brief Returns whether this address is a global multicast address or not.
 <p>Valid IPv6 global multicast addresses have the prefix <code>ffxe::/16</code>,
 where <code>x</code> is a set of flags and the additional 112 bits make
 up the global multicast address space.
 <p>Valid IPv4 global multicast addresses are the range of addresses
 from <code>224.0.1.0</code> to <code>238.255.255.255</code>.
 */
- (jboolean)isMCGlobal;

/*!
 @brief Returns whether this address is a link-local multicast address or not.
 <p>Valid IPv6 link-local multicast addresses have the prefix <code>ffx2::/16</code>,
 where x is a set of flags and the additional 112 bits make up the link-local multicast
 address space.
 <p>Valid IPv4 link-local multicast addresses have the prefix <code>224.0.0/24</code>.
 */
- (jboolean)isMCLinkLocal;

/*!
 @brief Returns whether this address is a node-local multicast address or not.
 <p>Valid IPv6 node-local multicast addresses have the prefix <code>ffx1::/16</code>,
 where x is a set of flags and the additional 112 bits make up the link-local multicast
 address space.
 <p>There are no valid IPv4 node-local multicast addresses.
 */
- (jboolean)isMCNodeLocal;

/*!
 @brief Returns whether this address is a organization-local multicast address or not.
 <p>Valid IPv6 organization-local multicast addresses have the prefix <code>ffx8::/16</code>,
 where x is a set of flags and the additional 112 bits make up the link-local multicast
 address space.
 <p>Valid IPv4 organization-local multicast addresses have the prefix <code>239.192/14</code>.
 */
- (jboolean)isMCOrgLocal;

/*!
 @brief Returns whether this address is a site-local multicast address or not.
 <p>Valid IPv6 site-local multicast addresses have the prefix <code>ffx5::/16</code>,
 where x is a set of flags and the additional 112 bits make up the link-local multicast
 address space.
 <p>Valid IPv4 site-local multicast addresses have the prefix <code>239.255/16</code>.
 */
- (jboolean)isMCSiteLocal;

/*!
 @brief Returns whether this address is a multicast address or not.
 <p>Valid IPv6 multicast addresses have the prefix <code>ff::/8</code>.
 <p>Valid IPv4 multicast addresses have the prefix <code>224/4</code>.
 */
- (jboolean)isMulticastAddress;

/*!
 @brief Returns true if the string is a valid numeric IPv4 or IPv6 address (such as "192.168.0.1").
 This copes with all forms of address that Java supports, detailed in the <code>InetAddress</code>
 class documentation.
  used by frameworks/base to ensure that a getAllByName won't cause a DNS lookup.
 */
+ (jboolean)isNumericWithNSString:(NSString *)address;

/*!
 @brief Tries to reach this <code>InetAddress</code>.
 This method first tries to use
 ICMP <i>(ICMP ECHO REQUEST)</i>, falling back to a TCP connection
 on port 7 (Echo) of the remote host.
 @param timeout
 timeout in milliseconds before the test fails if no connection
 could be established.
 @return <code>true</code> if this address is reachable, <code>false</code>
 otherwise.
 @throws IOException
 if an error occurs during an I/O operation.
 @throws IllegalArgumentException
 if timeout is less than zero.
 */
- (jboolean)isReachableWithInt:(jint)timeout;

/*!
 @brief Tries to reach this <code>InetAddress</code>.
 This method first tries to use
 ICMP <i>(ICMP ECHO REQUEST)</i>, falling back to a TCP connection
 on port 7 (Echo) of the remote host.
 @param networkInterface
 the network interface on which to connection should be
 established.
 @param ttl
 the maximum count of hops (time-to-live).
 @param timeout
 timeout in milliseconds before the test fails if no connection
 could be established.
 @return <code>true</code> if this address is reachable, <code>false</code>
 otherwise.
 @throws IOException
 if an error occurs during an I/O operation.
 @throws IllegalArgumentException
 if ttl or timeout is less than zero.
 */
- (jboolean)isReachableWithJavaNetNetworkInterface:(JavaNetNetworkInterface *)networkInterface
                                           withInt:(jint)ttl
                                           withInt:(jint)timeout;

/*!
 @brief Returns whether this address is a site-local address or not.
 <p>For the purposes of this method, valid IPv6 site-local addresses have
 the deprecated prefix <code>fec0::/10</code> from
 <a href="http://www.ietf.org/rfc/rfc1884.txt">RFC 1884</a>,
 <i>not</i> the modern prefix <code>fc00::/7</code> from
 <a href="http://www.ietf.org/rfc/rfc4193.txt">RFC 4193</a>.
 <p><a href="http://www.ietf.org/rfc/rfc3484.txt">RFC 3484</a>
 "Default Address Selection for Internet Protocol Version 6 (IPv6)" states
 that IPv4 private addresses have the prefix <code>10/8</code>, <code>172.16/12</code>,
 or <code>192.168/16</code>.
 @return <code>true</code> if this instance represents a site-local address,
 <code>false</code> otherwise.
 */
- (jboolean)isSiteLocalAddress;

/*!
 @brief Returns an InetAddress corresponding to the given numeric address (such
 as <code>"192.168.0.1"</code> or <code>"2001:4860:800d::68"</code>).
 This method will never do a DNS lookup. Non-numeric addresses are errors.
  used by frameworks/base's NetworkUtils.numericToInetAddress
 @throws IllegalArgumentException if <code>numericAddress</code> is not a numeric address
 */
+ (JavaNetInetAddress *)parseNumericAddressWithNSString:(NSString *)numericAddress;

/*!
 @brief Returns a string containing the host name (if available) and host address.
 For example: <code>"www.google.com/74.125.224.115"</code> or <code>"/127.0.0.1"</code>.
 <p>IPv6 addresses may additionally include an interface name or scope id.
 For example: <code>"www.google.com/2001:4860:4001:803::1013%eth0"</code> or
 <code>"/2001:4860:4001:803::1013%2"</code>.
 */
- (NSString *)description;

#pragma mark Package-Private

/*!
 @brief Constructs an <code>InetAddress</code>.
 Note: this constructor is for subclasses only.
 */
- (instancetype)initWithInt:(jint)family
              withByteArray:(IOSByteArray *)ipaddress
               withNSString:(NSString *)hostName;

@end

J2OBJC_STATIC_INIT(JavaNetInetAddress)

J2OBJC_FIELD_SETTER(JavaNetInetAddress, ipaddress_, IOSByteArray *)
J2OBJC_FIELD_SETTER(JavaNetInetAddress, hostName_, NSString *)

/*!
 @brief Used by the DatagramSocket.disconnect implementation.
  internal use only
 */
inline JavaNetInetAddress *JavaNetInetAddress_get_UNSPECIFIED();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaNetInetAddress *JavaNetInetAddress_UNSPECIFIED;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaNetInetAddress, UNSPECIFIED, JavaNetInetAddress *)

FOUNDATION_EXPORT void JavaNetInetAddress_initWithInt_withByteArray_withNSString_(JavaNetInetAddress *self, jint family, IOSByteArray *ipaddress, NSString *hostName);

FOUNDATION_EXPORT JavaNetInetAddress *new_JavaNetInetAddress_initWithInt_withByteArray_withNSString_(jint family, IOSByteArray *ipaddress, NSString *hostName) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT IOSObjectArray *JavaNetInetAddress_getAllByNameWithNSString_(NSString *host);

FOUNDATION_EXPORT JavaNetInetAddress *JavaNetInetAddress_getByNameWithNSString_(NSString *host);

FOUNDATION_EXPORT JavaNetInetAddress *JavaNetInetAddress_getLocalHost();

FOUNDATION_EXPORT void JavaNetInetAddress_clearDnsCache();

FOUNDATION_EXPORT jboolean JavaNetInetAddress_isNumericWithNSString_(NSString *address);

FOUNDATION_EXPORT JavaNetInetAddress *JavaNetInetAddress_parseNumericAddressWithNSString_(NSString *numericAddress);

FOUNDATION_EXPORT JavaNetInetAddress *JavaNetInetAddress_getLoopbackAddress();

FOUNDATION_EXPORT JavaNetInetAddress *JavaNetInetAddress_getByAddressWithByteArray_(IOSByteArray *ipAddress);

FOUNDATION_EXPORT JavaNetInetAddress *JavaNetInetAddress_getByAddressWithNSString_withByteArray_(NSString *hostName, IOSByteArray *ipAddress);

FOUNDATION_EXPORT JavaNetInetAddress *JavaNetInetAddress_getByAddressWithNSString_withByteArray_withInt_(NSString *hostName, IOSByteArray *ipAddress, jint scopeId);

J2OBJC_TYPE_LITERAL_HEADER(JavaNetInetAddress)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaNetInetAddress_INCLUDE_ALL")

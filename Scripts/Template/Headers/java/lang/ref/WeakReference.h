//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/lang/ref/WeakReference.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaLangRefWeakReference_INCLUDE_ALL")
#ifdef JavaLangRefWeakReference_RESTRICT
#define JavaLangRefWeakReference_INCLUDE_ALL 0
#else
#define JavaLangRefWeakReference_INCLUDE_ALL 1
#endif
#undef JavaLangRefWeakReference_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaLangRefWeakReference_) && (JavaLangRefWeakReference_INCLUDE_ALL || defined(JavaLangRefWeakReference_INCLUDE))
#define JavaLangRefWeakReference_

#define JavaLangRefReference_RESTRICT 1
#define JavaLangRefReference_INCLUDE 1
#include "../../../java/lang/ref/Reference.h"

@class JavaLangRefReferenceQueue;

/*!
 @brief Implements a weak reference, which is the middle of the three types of
 references.
 Once the garbage collector decides that an object <code>obj</code> is
 is weakly-reachable, the following
 happens:
 <ul>
 <li>
 A set <code>ref</code> of references is determined. <code>ref</code> contains the
 following elements:
 <ul>
 <li>
 All weak references pointing to <code>obj</code>.
 </li>
 <li>
 All weak references pointing to objects from which <code>obj</code> is
 either strongly or softly reachable.
 </li>
 </ul>
 </li>
 <li>
 All references in <code>ref</code> are atomically cleared.
 </li>
 <li>
 All objects formerly being referenced by <code>ref</code> become eligible for
 finalization.
 </li>
 <li>
 At some future point, all references in <code>ref</code> will be enqueued
 with their corresponding reference queues, if any.
 </li>
 </ul>
 Weak references are useful for mappings that should have their entries
 removed automatically once they are not referenced any more (from outside).
 The difference between a <code>SoftReference</code> and a <code>WeakReference</code> is
 the point of time at which the decision is made to clear and enqueue the
 reference:
 <ul>
 <li>
 A <code>SoftReference</code> should be cleared and enqueued <em>as late as
 possible</em>, that is, in case the VM is in danger of running out of
 memory.
 </li>
 <li>
 A <code>WeakReference</code> may be cleared and enqueued as soon as is
 known to be weakly-referenced.
 </li>
 </ul>
 */
@interface JavaLangRefWeakReference : JavaLangRefReference

#pragma mark Public

/*!
 @brief Constructs a new weak reference to the given referent.
 The newly created
 reference is not registered with any reference queue.
 @param r the referent to track
 */
- (instancetype)initWithId:(id)r;

/*!
 @brief Constructs a new weak reference to the given referent.
 The newly created
 reference is registered with the given reference queue.
 @param r the referent to track
 @param q the queue to register to the reference object with. A null value
 results in a weak reference that is not associated with any
 queue.
 */
- (instancetype)initWithId:(id)r
withJavaLangRefReferenceQueue:(JavaLangRefReferenceQueue *)q;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaLangRefWeakReference)

FOUNDATION_EXPORT void JavaLangRefWeakReference_initWithId_(JavaLangRefWeakReference *self, id r);

FOUNDATION_EXPORT JavaLangRefWeakReference *new_JavaLangRefWeakReference_initWithId_(id r) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaLangRefWeakReference_initWithId_withJavaLangRefReferenceQueue_(JavaLangRefWeakReference *self, id r, JavaLangRefReferenceQueue *q);

FOUNDATION_EXPORT JavaLangRefWeakReference *new_JavaLangRefWeakReference_initWithId_withJavaLangRefReferenceQueue_(id r, JavaLangRefReferenceQueue *q) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaLangRefWeakReference)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaLangRefWeakReference_INCLUDE_ALL")

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/lang/ref/SoftReference.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaLangRefSoftReference_INCLUDE_ALL")
#ifdef JavaLangRefSoftReference_RESTRICT
#define JavaLangRefSoftReference_INCLUDE_ALL 0
#else
#define JavaLangRefSoftReference_INCLUDE_ALL 1
#endif
#undef JavaLangRefSoftReference_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaLangRefSoftReference_) && (JavaLangRefSoftReference_INCLUDE_ALL || defined(JavaLangRefSoftReference_INCLUDE))
#define JavaLangRefSoftReference_

#define JavaLangRefReference_RESTRICT 1
#define JavaLangRefReference_INCLUDE 1
#include "../../../java/lang/ref/Reference.h"

@class JavaLangRefReferenceQueue;

/*!
 @brief A reference that is cleared when its referent is not strongly reachable and
 there is memory pressure.
 <h3>Avoid Soft References for Caching</h3>
 In practice, soft references are inefficient for caching. The runtime doesn't
 have enough information on which references to clear and which to keep. Most
 fatally, it doesn't know what to do when given the choice between clearing a
 soft reference and growing the heap.
 <p>The lack of information on the value to your application of each reference
 limits the usefulness of soft references. References that are cleared too
 early cause unnecessary work; those that are cleared too late waste memory.
 <p>Most applications should use an <code>android.util.LruCache</code> instead of
 soft references. LruCache has an effective eviction policy and lets the user
 tune how much memory is allotted.
 <h3>Garbage Collection of Soft References</h3>
 When the garbage collector encounters an object <code>obj</code> that is
 softly-reachable, the following happens:
 <ul>
 <li>A set <code>refs</code> of references is determined. <code>refs</code> contains
 the following elements:
 <ul>
 <li>All soft references pointing to <code>obj</code>.</li>
 <li>All soft references pointing to objects from which <code>obj</code> is
 strongly reachable.</li>
 </ul>
 </li>
 <li>All references in <code>refs</code> are atomically cleared.</li>
 <li>At the same time or some time in the future, all references in <code>refs</code>
  will be enqueued with their corresponding reference queues, if
 any.</li>
 </ul>
 The system may delay clearing and enqueueing soft references, yet all <code>SoftReference</code>
 s pointing to softly reachable objects will be cleared before
 the runtime throws an <code>OutOfMemoryError</code>.
 <p>Unlike a <code>WeakReference</code>, a <code>SoftReference</code> will not be
 cleared and enqueued until the runtime must reclaim memory to satisfy an
 allocation.
 */
@interface JavaLangRefSoftReference : JavaLangRefReference

#pragma mark Public

/*!
 @brief Constructs a new soft reference to the given referent.
 The newly created
 reference is not registered with any reference queue.
 @param r the referent to track
 */
- (instancetype)initWithId:(id)r;

/*!
 @brief Constructs a new soft reference to the given referent.
 The newly created
 reference is registered with the given reference queue.
 @param r the referent to track
 @param q the queue to register to the reference object with. A null value
 results in a weak reference that is not associated with any
 queue.
 */
- (instancetype)initWithId:(id)r
withJavaLangRefReferenceQueue:(JavaLangRefReferenceQueue *)q;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaLangRefSoftReference)

FOUNDATION_EXPORT void JavaLangRefSoftReference_initWithId_(JavaLangRefSoftReference *self, id r);

FOUNDATION_EXPORT JavaLangRefSoftReference *new_JavaLangRefSoftReference_initWithId_(id r) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT void JavaLangRefSoftReference_initWithId_withJavaLangRefReferenceQueue_(JavaLangRefSoftReference *self, id r, JavaLangRefReferenceQueue *q);

FOUNDATION_EXPORT JavaLangRefSoftReference *new_JavaLangRefSoftReference_initWithId_withJavaLangRefReferenceQueue_(id r, JavaLangRefReferenceQueue *q) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaLangRefSoftReference)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaLangRefSoftReference_INCLUDE_ALL")

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/text/Format.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaTextFormat_INCLUDE_ALL")
#ifdef JavaTextFormat_RESTRICT
#define JavaTextFormat_INCLUDE_ALL 0
#else
#define JavaTextFormat_INCLUDE_ALL 1
#endif
#undef JavaTextFormat_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaTextFormat_) && (JavaTextFormat_INCLUDE_ALL || defined(JavaTextFormat_INCLUDE))
#define JavaTextFormat_

#define JavaIoSerializable_RESTRICT 1
#define JavaIoSerializable_INCLUDE 1
#include "../../java/io/Serializable.h"

@class JavaLangStringBuffer;
@class JavaTextFieldPosition;
@class JavaTextParsePosition;
@protocol JavaTextAttributedCharacterIterator;

/*!
 @brief The base class for all formats.
 <p>
 This is an abstract base class which specifies the protocol for classes which
 convert other objects or values, such as numeric values and dates, and their
 string representations. In some cases these representations may be localized
 or contain localized characters or strings. For example, a numeric formatter
 such as <code>DecimalFormat</code> may convert a numeric value such as 12345 to
 the string "$12,345". It may also parse the string back into a numeric value.
 A date and time formatter like <code>SimpleDateFormat</code> may represent a
 specific date, encoded numerically, as a string such as "Wednesday, February
 26, 1997 AD".
 <p>
 Many of the concrete subclasses of <code>Format</code> employ the notion of a
 pattern. A pattern is a string representation of the rules which govern the
 conversion between values and strings. For example, a <code>DecimalFormat</code>
 object may be associated with the pattern "$#,##0.00;($#,##0.00)", which is a
 common US English format for currency values, yielding strings such as
 "$1,234.45" for 1234.45, and "($987.65)" for -987.6543. The specific syntax
 of a pattern is defined by each subclass. Even though many subclasses use
 patterns, the notion of a pattern is not inherent to <code>Format</code> classes
 in general, and is not part of the explicit base class protocol.
 <p>
 Two complex formatting classes are worth mentioning: <code>MessageFormat</code>
 and <code>ChoiceFormat</code>. <code>ChoiceFormat</code> is a subclass of
 <code>NumberFormat</code> which allows the user to format different number ranges
 as strings. For instance, 0 may be represented as "no files", 1 as "one
 file", and any number greater than 1 as "many files". <code>MessageFormat</code>
 is a formatter which utilizes other <code>Format</code> objects to format a string
 containing multiple values. For instance, a <code>MessageFormat</code> object
 might produce the string "There are no files on the disk MyDisk on February
 27, 1997." given the arguments 0, "MyDisk", and the date value of 2/27/97.
 See the <code>ChoiceFormat</code> and <code>MessageFormat</code> descriptions for
 further information.
 */
@interface JavaTextFormat : NSObject < JavaIoSerializable, NSCopying >

#pragma mark Public

/*!
 @brief Returns a copy of this <code>Format</code> instance.
 @return a shallow copy of this format.
 - seealso: java.lang.Cloneable
 */
- (id)clone;

/*!
 @brief Formats the specified object using the rules of this format.
 @param object
 the object to format.
 @return the formatted string.
 @throws IllegalArgumentException
 if the object cannot be formatted by this format.
 */
- (NSString *)formatWithId:(id)object;

/*!
 @brief Appends the specified object to the specified string buffer using the
 rules of this format.
 <p>
 <code>field</code> is an input/output parameter. If its <code>field</code>
 member contains an enum value specifying a field on input, then its
 <code>beginIndex</code> and <code>endIndex</code> members will be updated with the
 text offset of the first occurrence of this field in the formatted text.
 @param object
 the object to format.
 @param buffer
 the string buffer where the formatted string is appended to.
 @param field
 on input: an optional alignment field; on output: the offsets
 of the alignment field in the formatted text.
 @return the string buffer.
 @throws IllegalArgumentException
 if the object cannot be formatted by this format.
 */
- (JavaLangStringBuffer *)formatWithId:(id)object
              withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
             withJavaTextFieldPosition:(JavaTextFieldPosition *)field;

/*!
 @brief Formats the specified object using the rules of this format and returns
 an <code>AttributedCharacterIterator</code> with the formatted string and no
 attributes.
 <p>
 Subclasses should return an <code>AttributedCharacterIterator</code> with the
 appropriate attributes.
 @param object
 the object to format.
 @return an <code>AttributedCharacterIterator</code> with the formatted object
 and attributes.
 @throws IllegalArgumentException
 if the object cannot be formatted by this format.
 */
- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)object;

/*!
 @brief Parses the specified string using the rules of this format.
 @param string
 the string to parse.
 @return the object resulting from the parse.
 @throws ParseException
 if an error occurs during parsing.
 */
- (id)parseObjectWithNSString:(NSString *)string;

/*!
 @brief Parses the specified string starting at the index specified by
 <code>position</code>.
 If the string is successfully parsed then the index of
 the <code>ParsePosition</code> is updated to the index following the parsed
 text. On error, the index is unchanged and the error index of
 <code>ParsePosition</code> is set to the index where the error occurred.
 @param string
 the string to parse.
 @param position
 input/output parameter, specifies the start index in
 <code>string</code> from where to start parsing. If parsing is
 successful, it is updated with the index following the parsed
 text; on error, the index is unchanged and the error index is
 set to the index where the error occurred.
 @return the object resulting from the parse or <code>null</code> if there is
 an error.
 */
- (id)parseObjectWithNSString:(NSString *)string
    withJavaTextParsePosition:(JavaTextParsePosition *)position;

#pragma mark Protected

/*!
 @brief Used by subclasses.
 This was public in Java 5.
 */
- (instancetype)init;

#pragma mark Package-Private

+ (jboolean)upToWithNSString:(NSString *)string
   withJavaTextParsePosition:(JavaTextParsePosition *)position
    withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                    withChar:(jchar)stop;

+ (jboolean)upToWithQuotesWithNSString:(NSString *)string
             withJavaTextParsePosition:(JavaTextParsePosition *)position
              withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                              withChar:(jchar)stop
                              withChar:(jchar)start;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTextFormat)

FOUNDATION_EXPORT void JavaTextFormat_init(JavaTextFormat *self);

FOUNDATION_EXPORT jboolean JavaTextFormat_upToWithNSString_withJavaTextParsePosition_withJavaLangStringBuffer_withChar_(NSString *string, JavaTextParsePosition *position, JavaLangStringBuffer *buffer, jchar stop);

FOUNDATION_EXPORT jboolean JavaTextFormat_upToWithQuotesWithNSString_withJavaTextParsePosition_withJavaLangStringBuffer_withChar_withChar_(NSString *string, JavaTextParsePosition *position, JavaLangStringBuffer *buffer, jchar stop, jchar start);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextFormat)

#endif

#if !defined (JavaTextFormat_Field_) && (JavaTextFormat_INCLUDE_ALL || defined(JavaTextFormat_Field_INCLUDE))
#define JavaTextFormat_Field_

#define JavaTextAttributedCharacterIterator_RESTRICT 1
#define JavaTextAttributedCharacterIterator_Attribute_INCLUDE 1
#include "../../java/text/AttributedCharacterIterator.h"

/*!
 @brief Inner class used to represent <code>Format</code> attributes in the
 <code>AttributedCharacterIterator</code> that the
 <code>formatToCharacterIterator()</code> method returns in <code>Format</code>
 subclasses.
 */
@interface JavaTextFormat_Field : JavaTextAttributedCharacterIterator_Attribute

#pragma mark Protected

/*!
 @brief Constructs a new instance of <code>Field</code> with the given field name.
 @param fieldName
 the field name.
 */
- (instancetype)initWithNSString:(NSString *)fieldName;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTextFormat_Field)

FOUNDATION_EXPORT void JavaTextFormat_Field_initWithNSString_(JavaTextFormat_Field *self, NSString *fieldName);

FOUNDATION_EXPORT JavaTextFormat_Field *new_JavaTextFormat_Field_initWithNSString_(NSString *fieldName) NS_RETURNS_RETAINED;

J2OBJC_TYPE_LITERAL_HEADER(JavaTextFormat_Field)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaTextFormat_INCLUDE_ALL")

//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/nio/ShortBuffer.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaNioShortBuffer_INCLUDE_ALL")
#ifdef JavaNioShortBuffer_RESTRICT
#define JavaNioShortBuffer_INCLUDE_ALL 0
#else
#define JavaNioShortBuffer_INCLUDE_ALL 1
#endif
#undef JavaNioShortBuffer_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaNioShortBuffer_) && (JavaNioShortBuffer_INCLUDE_ALL || defined(JavaNioShortBuffer_INCLUDE))
#define JavaNioShortBuffer_

#define JavaNioBuffer_RESTRICT 1
#define JavaNioBuffer_INCLUDE 1
#include "../../java/nio/Buffer.h"

#define JavaLangComparable_RESTRICT 1
#define JavaLangComparable_INCLUDE 1
#include "../../java/lang/Comparable.h"

@class IOSShortArray;
@class JavaNioByteOrder;

/*!
 @brief A buffer of shorts.
 <p>
 A short buffer can be created in either of the following ways:
 <ul>
 <li><code>Allocate</code> a new short array and create a buffer
 based on it;</li>
 <li><code>Wrap</code> an existing short array to create a new
 buffer;</li>
 <li>Use <code>ByteBuffer.asShortBuffer</code>
 to create a short buffer based on a byte buffer.</li>
 </ul>
 */
@interface JavaNioShortBuffer : JavaNioBuffer < JavaLangComparable >

#pragma mark Public

/*!
 @brief Creates a short buffer based on a newly allocated short array.
 @param capacity
 the capacity of the new buffer.
 @return the created short buffer.
 @throws IllegalArgumentException
 if <code>capacity</code> is less than zero.
 */
+ (JavaNioShortBuffer *)allocateWithInt:(jint)capacity OBJC_METHOD_FAMILY_NONE;

- (IOSShortArray *)array;

- (jint)arrayOffset;

/*!
 @brief Returns a read-only buffer that shares its content with this buffer.
 <p>
 The returned buffer is guaranteed to be a new instance, even if this
 buffer is read-only itself. The new buffer's position, limit, capacity
 and mark are the same as this buffer's.
 <p>
 The new buffer shares its content with this buffer, which means this
 buffer's change of content will be visible to the new buffer. The two
 buffer's position, limit and mark are independent.
 @return a read-only version of this buffer.
 */
- (JavaNioShortBuffer *)asReadOnlyBuffer;

/*!
 @brief Compacts this short buffer.
 <p>
 The remaining shorts will be moved to the head of the buffer, starting
 from position zero. Then the position is set to <code>remaining()</code>; the
 limit is set to capacity; the mark is cleared.
 @return this buffer.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioShortBuffer *)compact;

/*!
 @brief Compare the remaining shorts of this buffer to another short buffer's
 remaining shorts.
 @param otherBuffer
 another short buffer.
 @return a negative value if this is less than <code>otherBuffer</code>; 0 if
 this equals to <code>otherBuffer</code>; a positive value if this is
 greater than <code>otherBuffer</code>.
 @throws ClassCastException
 if <code>otherBuffer</code> is not a short buffer.
 */
- (jint)compareToWithId:(JavaNioShortBuffer *)otherBuffer;

/*!
 @brief Returns a duplicated buffer that shares its content with this buffer.
 <p>
 The duplicated buffer's position, limit, capacity and mark are the same
 as this buffer. The duplicated buffer's read-only property and byte order
 are the same as this buffer's.
 <p>
 The new buffer shares its content with this buffer, which means either
 buffer's change of content will be visible to the other. The two buffers'
 position, limit and mark are independent.
 */
- (JavaNioShortBuffer *)duplicate;

/*!
 @brief Checks whether this short buffer is equal to another object.
 <p>
 If <code>other</code> is not a short buffer then <code>false</code> is returned.
 Two short buffers are equal if and only if their remaining shorts are
 exactly the same. Position, limit, capacity and mark are not considered.
 @param other
 the object to compare with this short buffer.
 @return <code>true</code> if this short buffer is equal to <code>other</code>,
 <code>false</code> otherwise.
 */
- (jboolean)isEqual:(id)other;

/*!
 @brief Returns the short at the current position and increases the position by
 1.
 @return the short at the current position.
 @throws BufferUnderflowException
 if the position is equal or greater than limit.
 */
- (jshort)get;

/*!
 @brief Returns the short at the specified index; the position is not changed.
 @param index
 the index, must not be negative and less than limit.
 @return a short at the specified index.
 @throws IndexOutOfBoundsException
 if index is invalid.
 */
- (jshort)getWithInt:(jint)index;

/*!
 @brief Reads shorts from the current position into the specified short array and
 increases the position by the number of shorts read.
 <p>
 Calling this method has the same effect as
 <code>get(dst, 0, dst.length)</code>.
 @param dst
 the destination short array.
 @return this buffer.
 @throws BufferUnderflowException
 if <code>dst.length</code> is greater than <code>remaining()</code>.
 */
- (JavaNioShortBuffer *)getWithShortArray:(IOSShortArray *)dst;

/*!
 @brief Reads shorts from the current position into the specified short array,
 starting from the specified offset, and increases the position by the
 number of shorts read.
 @param dst
 the target short array.
 @param dstOffset
 the offset of the short array, must not be negative and not
 greater than <code>dst.length</code>.
 @param shortCount
 the number of shorts to read, must be no less than zero and
 not greater than <code>dst.length - dstOffset</code>.
 @return this buffer.
 @throws IndexOutOfBoundsException
 if either <code>dstOffset</code> or <code>shortCount</code> is invalid.
 @throws BufferUnderflowException
 if <code>shortCount</code> is greater than <code>remaining()</code>.
 */
- (JavaNioShortBuffer *)getWithShortArray:(IOSShortArray *)dst
                                  withInt:(jint)dstOffset
                                  withInt:(jint)shortCount;

- (jboolean)hasArray;

/*!
 @brief Calculates this buffer's hash code from the remaining chars.
 The
 position, limit, capacity and mark don't affect the hash code.
 @return the hash code calculated from the remaining shorts.
 */
- (NSUInteger)hash;

/*!
 @brief Indicates whether this buffer is direct.
 A direct buffer will try its
 best to take advantage of native memory APIs and it may not stay in the
 Java heap, so it is not affected by garbage collection.
 <p>
 A short buffer is direct if it is based on a byte buffer and the byte
 buffer is direct.
 @return <code>true</code> if this buffer is direct, <code>false</code> otherwise.
 */
- (jboolean)isDirect;

/*!
 @brief Returns the byte order used by this buffer when converting shorts from/to
 bytes.
 <p>
 If this buffer is not based on a byte buffer, then always return the
 platform's native byte order.
 @return the byte order used by this buffer when converting shorts from/to
 bytes.
 */
- (JavaNioByteOrder *)order;

/*!
 @brief Writes a short to the specified index of this buffer; the position is not
 changed.
 @param index
 the index, must not be negative and less than the limit.
 @param s
 the short to write.
 @return this buffer.
 @throws IndexOutOfBoundsException
 if index is invalid.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioShortBuffer *)putWithInt:(jint)index
                         withShort:(jshort)s;

/*!
 @brief Writes the given short to the current position and increases the position
 by 1.
 @param s
 the short to write.
 @return this buffer.
 @throws BufferOverflowException
 if position is equal or greater than limit.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioShortBuffer *)putWithShort:(jshort)s;

/*!
 @brief Writes shorts from the given short array to the current position and
 increases the position by the number of shorts written.
 <p>
 Calling this method has the same effect as
 <code>put(src, 0, src.length)</code>.
 @param src
 the source short array.
 @return this buffer.
 @throws BufferOverflowException
 if <code>remaining()</code> is less than <code>src.length</code>.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioShortBuffer *)putWithShortArray:(IOSShortArray *)src;

/*!
 @brief Writes shorts from the given short array, starting from the specified
 offset, to the current position and increases the position by the number
 of shorts written.
 @param src
 the source short array.
 @param srcOffset
 the offset of short array, must not be negative and not
 greater than <code>src.length</code>.
 @param shortCount
 the number of shorts to write, must be no less than zero and
 not greater than <code>src.length - srcOffset</code>.
 @return this buffer.
 @throws BufferOverflowException
 if <code>remaining()</code> is less than <code>shortCount</code>.
 @throws IndexOutOfBoundsException
 if either <code>srcOffset</code> or <code>shortCount</code> is invalid.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioShortBuffer *)putWithShortArray:(IOSShortArray *)src
                                  withInt:(jint)srcOffset
                                  withInt:(jint)shortCount;

/*!
 @brief Writes all the remaining shorts of the <code>src</code> short buffer to this
 buffer's current position, and increases both buffers' position by the
 number of shorts copied.
 @param src
 the source short buffer.
 @return this buffer.
 @throws BufferOverflowException
 if <code>src.remaining()</code> is greater than this buffer's
 <code>remaining()</code>.
 @throws IllegalArgumentException
 if <code>src</code> is this buffer.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioShortBuffer *)putWithJavaNioShortBuffer:(JavaNioShortBuffer *)src;

/*!
 @brief Returns a sliced buffer that shares its content with this buffer.
 <p>
 The sliced buffer's capacity will be this buffer's <code>remaining()</code>,
 and its zero position will correspond to this buffer's current position.
 The new buffer's position will be 0, limit will be its capacity, and its
 mark is cleared. The new buffer's read-only property and byte order are
 same as this buffer's.
 <p>
 The new buffer shares its content with this buffer, which means either
 buffer's change of content will be visible to the other. The two buffers'
 position, limit and mark are independent.
 */
- (JavaNioShortBuffer *)slice;

/*!
 @brief Creates a new short buffer by wrapping the given short array.
 <p>
 Calling this method has the same effect as
 <code>wrap(array, 0, array.length)</code>.
 @param array
 the short array which the new buffer will be based on.
 @return the created short buffer.
 */
+ (JavaNioShortBuffer *)wrapWithShortArray:(IOSShortArray *)array;

/*!
 @brief Creates a new short buffer by wrapping the given short array.
 <p>
 The new buffer's position will be <code>start</code>, limit will be
 <code>start + shortCount</code>, capacity will be the length of the array.
 @param array
 the short array which the new buffer will be based on.
 @param start
 the start index, must not be negative and not greater than
 <code>array.length</code>.
 @param shortCount
 the length, must not be negative and not greater than
 <code>array.length - start</code>.
 @return the created short buffer.
 @throws IndexOutOfBoundsException
 if either <code>start</code> or <code>shortCount</code> is invalid.
 */
+ (JavaNioShortBuffer *)wrapWithShortArray:(IOSShortArray *)array
                                   withInt:(jint)start
                                   withInt:(jint)shortCount;

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)capacity
                   withLong:(jlong)effectiveDirectAddress;

/*!
 @brief Child class implements this method to realize <code>array()</code>.
 @return see <code>array()</code>
 */
- (IOSShortArray *)protectedArray;

/*!
 @brief Child class implements this method to realize <code>arrayOffset()</code>.
 @return see <code>arrayOffset()</code>
 */
- (jint)protectedArrayOffset;

/*!
 @brief Child class implements this method to realize <code>hasArray()</code>.
 @return see <code>hasArray()</code>
 */
- (jboolean)protectedHasArray;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioShortBuffer)

FOUNDATION_EXPORT JavaNioShortBuffer *JavaNioShortBuffer_allocateWithInt_(jint capacity);

FOUNDATION_EXPORT JavaNioShortBuffer *JavaNioShortBuffer_wrapWithShortArray_(IOSShortArray *array);

FOUNDATION_EXPORT JavaNioShortBuffer *JavaNioShortBuffer_wrapWithShortArray_withInt_withInt_(IOSShortArray *array, jint start, jint shortCount);

FOUNDATION_EXPORT void JavaNioShortBuffer_initWithInt_withLong_(JavaNioShortBuffer *self, jint capacity, jlong effectiveDirectAddress);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioShortBuffer)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaNioShortBuffer_INCLUDE_ALL")

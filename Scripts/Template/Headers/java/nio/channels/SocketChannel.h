//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/nio/channels/SocketChannel.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaNioChannelsSocketChannel_INCLUDE_ALL")
#ifdef JavaNioChannelsSocketChannel_RESTRICT
#define JavaNioChannelsSocketChannel_INCLUDE_ALL 0
#else
#define JavaNioChannelsSocketChannel_INCLUDE_ALL 1
#endif
#undef JavaNioChannelsSocketChannel_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaNioChannelsSocketChannel_) && (JavaNioChannelsSocketChannel_INCLUDE_ALL || defined(JavaNioChannelsSocketChannel_INCLUDE))
#define JavaNioChannelsSocketChannel_

#define JavaNioChannelsSpiAbstractSelectableChannel_RESTRICT 1
#define JavaNioChannelsSpiAbstractSelectableChannel_INCLUDE 1
#include "../../../java/nio/channels/spi/AbstractSelectableChannel.h"

#define JavaNioChannelsByteChannel_RESTRICT 1
#define JavaNioChannelsByteChannel_INCLUDE 1
#include "../../../java/nio/channels/ByteChannel.h"

#define JavaNioChannelsScatteringByteChannel_RESTRICT 1
#define JavaNioChannelsScatteringByteChannel_INCLUDE 1
#include "../../../java/nio/channels/ScatteringByteChannel.h"

#define JavaNioChannelsGatheringByteChannel_RESTRICT 1
#define JavaNioChannelsGatheringByteChannel_INCLUDE 1
#include "../../../java/nio/channels/GatheringByteChannel.h"

#define JavaNioChannelsNetworkChannel_RESTRICT 1
#define JavaNioChannelsNetworkChannel_INCLUDE 1
#include "../../../java/nio/channels/NetworkChannel.h"

@class IOSObjectArray;
@class JavaNetSocket;
@class JavaNetSocketAddress;
@class JavaNioByteBuffer;
@class JavaNioChannelsSpiSelectorProvider;
@protocol JavaNetSocketOption;
@protocol JavaUtilSet;

/*!
 @brief A <code>SocketChannel</code> is a selectable channel that provides a partial
 abstraction of stream connecting socket.
 The <code>socket()</code> method returns a <code>Socket</code> instance which
 allows a wider range of socket operations than <code>SocketChannel</code> itself.
 <p>A socket channel is open but not connected when created by <code>open</code>.
 After connecting it by calling <code>connect(SocketAddress)</code>, it will remain
 connected until closed.
 <p>If the connection is non-blocking then
 <code>connect(SocketAddress)</code> is used to initiate the connection, followed
 by a call of <code>finishConnect</code> to perform the final steps of
 connecting. <code>isConnectionPending</code> to tests whether we're still
 trying to connect; <code>isConnected</code> tests whether the socket connect
 completed successfully. Note that realistic code should use a <code>Selector</code>
 instead of polling. Note also that <code>java.net.Socket</code> can connect with a
 timeout, which is the most common use for a non-blocking connect.
 <p>The input and output sides of a channel can be shut down independently and
 asynchronously without closing the channel. The <code>Socket.shutdownInput</code> method
 on the socket returned by <code>socket</code>
 is used for the input side of a channel and subsequent read operations return
 -1, which means end of stream. If another thread is blocked in a read
 operation when the shutdown occurs, the read will end without effect and
 return end of stream. Likewise the <code>Socket.shutdownOutput</code> method is used for the
 output side of the channel; subsequent write operations throw a
 <code>ClosedChannelException</code>. If the output is shut down and another thread
 is blocked in a write operation, an <code>AsynchronousCloseException</code> will
 be thrown to the pending thread.
 <p>Socket channels are thread-safe, no more than one thread can read or write at
 any given time. The <code>connect(SocketAddress)</code> and <code>finishConnect()</code>
  methods are synchronized against each other; when they are
 processing, calls to <code>read</code> and <code>write</code> will block.
 */
@interface JavaNioChannelsSocketChannel : JavaNioChannelsSpiAbstractSelectableChannel < JavaNioChannelsByteChannel, JavaNioChannelsScatteringByteChannel, JavaNioChannelsGatheringByteChannel, JavaNioChannelsNetworkChannel >

#pragma mark Public

/*!
  Until ready for a public API change 
 */
- (JavaNioChannelsSocketChannel *)bindWithJavaNetSocketAddress:(JavaNetSocketAddress *)local;

/*!
 @brief Connects this channel's socket with a remote address.
 <p>
 If this channel is blocking, this method will suspend until connecting is
 finished or an I/O exception occurs. If the channel is non-blocking,
 this method will return <code>true</code> if the connection is finished at
 once or return <code>false</code> when the connection must be finished later
 by calling <code>finishConnect()</code>.
 <p>
 This method can be called at any moment and can block other read and
 write operations while connecting. It executes the same security checks
 as the connect method of the <code>Socket</code> class.
 @param address
 the address to connect with.
 @return <code>true</code> if the connection is finished, <code>false</code>
 otherwise.
 @throws AlreadyConnectedException
 if the channel is already connected.
 @throws ConnectionPendingException
 a non-blocking connecting operation is already executing on
 this channel.
 @throws ClosedChannelException
 if this channel is closed.
 @throws AsynchronousCloseException
 if this channel is closed by another thread while this method
 is executing.
 @throws ClosedByInterruptException
 if another thread interrupts the calling thread while this
 operation is in progress. The calling thread will have the
 interrupt state set and this channel will be closed.
 @throws UnresolvedAddressException
 if the address is not resolved.
 @throws UnsupportedAddressTypeException
 if the address type is not supported.
 @throws IOException
 if an I/O error occurs.
 */
- (jboolean)connectWithJavaNetSocketAddress:(JavaNetSocketAddress *)address;

/*!
 @brief Completes the connection process initiated by a call of <code>connect(SocketAddress)</code>
 .
 <p>
 This method returns <code>true</code> if the connection is finished already
 and returns <code>false</code> if the channel is non-blocking and the
 connection is not finished yet.
 <p>
 If this channel is in blocking mode, this method will suspend and return
 <code>true</code> when the connection is finished. It closes this channel and
 throws an exception if the connection fails.
 <p>
 This method can be called at any moment and it can block other <code>read</code>
  and <code>write</code> operations while connecting.
 @return <code>true</code> if the connection is successfully finished, <code>false</code>
  otherwise.
 @throws NoConnectionPendingException
 if the channel is not connected and the connection process
 has not been initiated.
 @throws ClosedChannelException
 if this channel is closed.
 @throws AsynchronousCloseException
 if this channel is closed by another thread while this method
 is executing.
 @throws ClosedByInterruptException
 if another thread interrupts the calling thread while this
 operation is in progress. The calling thread has the
 interrupt state set, and this channel is closed.
 @throws IOException
 if an I/O error occurs.
 */
- (jboolean)finishConnect;

/*!
  Until ready for a public API change 
 */
- (JavaNetSocketAddress *)getLocalAddress;

/*!
  Until ready for a public API change 
 */
- (id)getOptionWithJavaNetSocketOption:(id<JavaNetSocketOption>)option;

/*!
 @brief Indicates whether this channel's socket is connected.
 @return <code>true</code> if this channel's socket is connected, <code>false</code>
 otherwise.
 */
- (jboolean)isConnected;

/*!
 @brief Indicates whether this channel's socket is still trying to connect.
 @return <code>true</code> if the connection is initiated but not finished;
 <code>false</code> otherwise.
 */
- (jboolean)isConnectionPending;

/*!
 @brief Creates an open and unconnected socket channel.
 <p>
 This channel is created by calling <code>openSocketChannel()</code> of the
 default <code>SelectorProvider</code> instance.
 @return the new channel which is open but unconnected.
 @throws IOException
 if an I/O error occurs.
 */
+ (JavaNioChannelsSocketChannel *)open;

/*!
 @brief Creates a socket channel and connects it to a socket address.
 <p>
 This method performs a call to <code>open()</code> followed by a call to
 <code>connect(SocketAddress)</code>.
 @param address
 the socket address to be connected to.
 @return the new connected channel.
 @throws AsynchronousCloseException
 if this channel is closed by another thread while this method
 is executing.
 @throws ClosedByInterruptException
 if another thread interrupts the calling thread while this
 operation is executing. The calling thread will have the
 interrupt state set and the channel will be closed.
 @throws UnresolvedAddressException
 if the address is not resolved.
 @throws UnsupportedAddressTypeException
 if the address type is not supported.
 @throws IOException
 if an I/O error occurs.
 */
+ (JavaNioChannelsSocketChannel *)openWithJavaNetSocketAddress:(JavaNetSocketAddress *)address;

/*!
 @brief Reads bytes from this socket channel into the given buffer.
 <p>
 The maximum number of bytes that will be read is the remaining number of
 bytes in the buffer when the method is invoked. The bytes will be copied
 into the buffer starting at the buffer's current position.
 <p>
 The call may block if other threads are also attempting to read from this
 channel.
 <p>
 Upon completion, the buffer's position is set to the end of the bytes
 that have been read. The buffer's limit is not changed.
 @param target
 the byte buffer to receive the bytes.
 @return the number of bytes actually read.
 @throws AsynchronousCloseException
 if another thread closes the channel during the read.
 @throws NotYetConnectedException
 if this channel is not yet connected.
 @throws ClosedByInterruptException
 if another thread interrupts the calling thread while this
 operation is in progress. The interrupt state of the calling
 thread is set and the channel is closed.
 @throws ClosedChannelException
 if this channel is closed.
 @throws IOException
 if another I/O error occurs.
 - seealso: java.nio.channels.ReadableByteChannel#read(java.nio.ByteBuffer)
 */
- (jint)readWithJavaNioByteBuffer:(JavaNioByteBuffer *)target;

/*!
 @brief Reads bytes from this socket channel and stores them in the specified
 array of buffers.
 This method attempts to read as many bytes as can be
 stored in the buffer array from this channel and returns the number of
 bytes actually read.
 <p>
 If a read operation is in progress, subsequent threads will block until
 the read is completed and will then contend for the ability to read.
 <p>
 Calling this method is equivalent to calling <code>read(targets, 0,
 targets.length);</code>
 @param targets
 the array of byte buffers into which the bytes will be copied.
 @return the number of bytes actually read.
 @throws AsynchronousCloseException
 if this channel is closed by another thread during this read
 operation.
 @throws ClosedByInterruptException
 if another thread interrupts the calling thread while this
 operation is in progress. The interrupt state of the calling
 thread is set and the channel is closed.
 @throws ClosedChannelException
 if this channel is closed.
 @throws IOException
 if another I/O error occurs.
 @throws NotYetConnectedException
 if this channel is not yet connected.
 */
- (jlong)readWithJavaNioByteBufferArray:(IOSObjectArray *)targets;

/*!
 @brief Reads bytes from this socket channel into a subset of the given buffers.
 This method attempts to read all <code>remaining()</code> bytes from <code>length</code>
  byte buffers, in order, starting at <code>targets[offset]</code>. The
 number of bytes actually read is returned.
 <p>
 If a read operation is in progress, subsequent threads will block until
 the read is completed and will then contend for the ability to read.
 @param targets
 the array of byte buffers into which the bytes will be copied.
 @param offset
 the index of the first buffer to store bytes in.
 @param length
 the maximum number of buffers to store bytes in.
 @return the number of bytes actually read.
 @throws AsynchronousCloseException
 if this channel is closed by another thread during this read
 operation.
 @throws ClosedByInterruptException
 if another thread interrupts the calling thread while this
 operation is in progress. The interrupt state of the calling
 thread is set and the channel is closed.
 @throws ClosedChannelException
 if this channel is closed.
 @throws IndexOutOfBoundsException
 if <code>offset < 0</code> or <code>length < 0</code>, or if <code>offset + length</code>
  is greater than the size of <code>targets</code>.
 @throws IOException
 if another I/O error occurs.
 @throws NotYetConnectedException
 if this channel is not yet connected.
 - seealso: java.nio.channels.ScatteringByteChannel#read(java.nio.ByteBuffer[],int,int)
 */
- (jlong)readWithJavaNioByteBufferArray:(IOSObjectArray *)targets
                                withInt:(jint)offset
                                withInt:(jint)length;

/*!
  Until ready for a public API change 
 */
- (JavaNioChannelsSocketChannel *)setOptionWithJavaNetSocketOption:(id<JavaNetSocketOption>)option
                                                            withId:(id)value;

/*!
 @brief Returns the socket assigned to this channel, which does not declare any public
 methods that are not declared in <code>Socket</code>.
 @return the socket assigned to this channel.
 */
- (JavaNetSocket *)socket;

/*!
  Until ready for a public API change 
 */
- (id<JavaUtilSet>)supportedOptions;

/*!
 @brief Gets the valid operations of this channel.
 Socket channels support
 connect, read and write operation, so this method returns
 <code>SelectionKey.OP_CONNECT | SelectionKey.OP_READ | SelectionKey.OP_WRITE</code>.
 @return the operations supported by this channel.
 - seealso: java.nio.channels.SelectableChannel#validOps()
 */
- (jint)validOps;

/*!
 @brief Writes bytes from the given byte buffer to this socket channel.
 The
 maximum number of bytes that are written is the remaining number of bytes
 in the buffer when this method is invoked. The bytes are taken from the
 buffer starting at the buffer's position.
 <p>
 The call may block if other threads are also attempting to write to the
 same channel.
 <p>
 Upon completion, the buffer's position is updated to the end of the bytes
 that have been written. The buffer's limit is not changed.
 @param source
 the byte buffer containing the bytes to be written.
 @return the number of bytes actually written.
 @throws AsynchronousCloseException
 if another thread closes the channel during the write.
 @throws ClosedByInterruptException
 if another thread interrupts the calling thread while this
 operation is in progress. The interrupt state of the calling
 thread is set and the channel is closed.
 @throws ClosedChannelException
 if the channel was already closed.
 @throws IOException
 if another I/O error occurs.
 @throws NotYetConnectedException
 if this channel is not connected yet.
 - seealso: java.nio.channels.WritableByteChannel#write(java.nio.ByteBuffer)
 */
- (jint)writeWithJavaNioByteBuffer:(JavaNioByteBuffer *)source;

/*!
 @brief Writes bytes from all the given byte buffers to this socket channel.
 <p>
 Calling this method is equivalent to calling <code>write(sources, 0,
 sources.length);</code>
 @param sources
 the buffers containing bytes to write.
 @return the number of bytes actually written.
 @throws AsynchronousCloseException
 if this channel is closed by another thread during this write
 operation.
 @throws ClosedByInterruptException
 if another thread interrupts the calling thread while this
 operation is in progress. The interrupt state of the calling
 thread is set and the channel is closed.
 @throws ClosedChannelException
 if this channel is closed.
 @throws IOException
 if another I/O error occurs.
 @throws NotYetConnectedException
 if this channel is not yet connected.
 - seealso: java.nio.channels.GatheringByteChannel#write(java.nio.ByteBuffer[])
 */
- (jlong)writeWithJavaNioByteBufferArray:(IOSObjectArray *)sources;

/*!
 @brief Attempts to write a subset of the given bytes from the buffers to this
 socket channel.
 This method attempts to write all <code>remaining()</code>
 bytes from <code>length</code> byte buffers, in order, starting at <code>sources[offset]</code>
 . The number of bytes actually written is returned.
 <p>
 If a write operation is in progress, subsequent threads will block until
 the write is completed and then contend for the ability to write.
 @param sources
 the array of byte buffers that is the source for bytes written
 to this channel.
 @param offset
 the index of the first buffer in <code>buffers</code>to get bytes
 from.
 @param length
 the number of buffers to get bytes from.
 @return the number of bytes actually written to this channel.
 @throws AsynchronousCloseException
 if this channel is closed by another thread during this write
 operation.
 @throws ClosedByInterruptException
 if another thread interrupts the calling thread while this
 operation is in progress. The interrupt state of the calling
 thread is set and the channel is closed.
 @throws ClosedChannelException
 if this channel is closed.
 @throws IndexOutOfBoundsException
 if <code>offset < 0</code> or <code>length < 0</code>, or if <code>offset + length</code>
  is greater than the size of <code>sources</code>.
 @throws IOException
 if another I/O error occurs.
 @throws NotYetConnectedException
 if this channel is not yet connected.
 - seealso: java.nio.channels.GatheringByteChannel#write(java.nio.ByteBuffer[],int,int)
 */
- (jlong)writeWithJavaNioByteBufferArray:(IOSObjectArray *)sources
                                 withInt:(jint)offset
                                 withInt:(jint)length;

#pragma mark Protected

/*!
 @brief Constructs a new <code>SocketChannel</code>.
 @param selectorProvider
 an instance of SelectorProvider.
 */
- (instancetype)initWithJavaNioChannelsSpiSelectorProvider:(JavaNioChannelsSpiSelectorProvider *)selectorProvider;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioChannelsSocketChannel)

FOUNDATION_EXPORT void JavaNioChannelsSocketChannel_initWithJavaNioChannelsSpiSelectorProvider_(JavaNioChannelsSocketChannel *self, JavaNioChannelsSpiSelectorProvider *selectorProvider);

FOUNDATION_EXPORT JavaNioChannelsSocketChannel *JavaNioChannelsSocketChannel_open();

FOUNDATION_EXPORT JavaNioChannelsSocketChannel *JavaNioChannelsSocketChannel_openWithJavaNetSocketAddress_(JavaNetSocketAddress *address);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioChannelsSocketChannel)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaNioChannelsSocketChannel_INCLUDE_ALL")

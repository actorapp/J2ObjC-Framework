//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/nio/DoubleBuffer.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaNioDoubleBuffer_INCLUDE_ALL")
#ifdef JavaNioDoubleBuffer_RESTRICT
#define JavaNioDoubleBuffer_INCLUDE_ALL 0
#else
#define JavaNioDoubleBuffer_INCLUDE_ALL 1
#endif
#undef JavaNioDoubleBuffer_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaNioDoubleBuffer_) && (JavaNioDoubleBuffer_INCLUDE_ALL || defined(JavaNioDoubleBuffer_INCLUDE))
#define JavaNioDoubleBuffer_

#define JavaNioBuffer_RESTRICT 1
#define JavaNioBuffer_INCLUDE 1
#include "../../java/nio/Buffer.h"

#define JavaLangComparable_RESTRICT 1
#define JavaLangComparable_INCLUDE 1
#include "../../java/lang/Comparable.h"

@class IOSDoubleArray;
@class JavaNioByteOrder;

/*!
 @brief A buffer of doubles.
 <p>
 A double buffer can be created in either one of the following ways:
 <ul>
 <li><code>Allocate</code> a new double array and create a buffer
 based on it;</li>
 <li><code>Wrap</code> an existing double array to create a new
 buffer;</li>
 <li>Use
 <code>ByteBuffer.asDoubleBuffer</code> to
 create a double buffer based on a byte buffer.</li>
 </ul>
 */
@interface JavaNioDoubleBuffer : JavaNioBuffer < JavaLangComparable >

#pragma mark Public

/*!
 @brief Creates a double buffer based on a newly allocated double array.
 @param capacity
 the capacity of the new buffer.
 @return the created double buffer.
 @throws IllegalArgumentException
 if <code>capacity</code> is less than zero.
 */
+ (JavaNioDoubleBuffer *)allocateWithInt:(jint)capacity OBJC_METHOD_FAMILY_NONE;

- (IOSDoubleArray *)array;

- (jint)arrayOffset;

/*!
 @brief Returns a read-only buffer that shares its content with this buffer.
 <p>
 The returned buffer is guaranteed to be a new instance, even if this
 buffer is read-only itself. The new buffer's position, limit, capacity
 and mark are the same as this buffer's.
 <p>
 The new buffer shares its content with this buffer, which means that this
 buffer's change of content will be visible to the new buffer. The two
 buffer's position, limit and mark are independent.
 @return a read-only version of this buffer.
 */
- (JavaNioDoubleBuffer *)asReadOnlyBuffer;

/*!
 @brief Compacts this double buffer.
 <p>
 The remaining doubles will be moved to the head of the buffer, staring
 from position zero. Then the position is set to <code>remaining()</code>; the
 limit is set to capacity; the mark is cleared.
 @return this buffer.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioDoubleBuffer *)compact;

/*!
 @brief Compare the remaining doubles of this buffer to another double buffer's
 remaining doubles.
 @param otherBuffer
 another double buffer.
 @return a negative value if this is less than <code>other</code>; 0 if this
 equals to <code>other</code>; a positive value if this is greater
 than <code>other</code>.
 @throws ClassCastException
 if <code>other</code> is not a double buffer.
 */
- (jint)compareToWithId:(JavaNioDoubleBuffer *)otherBuffer;

/*!
 @brief Returns a duplicated buffer that shares its content with this buffer.
 <p>
 The duplicated buffer's position, limit, capacity and mark are the same
 as this buffer's. The duplicated buffer's read-only property and byte
 order are the same as this buffer's, too.
 <p>
 The new buffer shares its content with this buffer, which means either
 buffer's change of content will be visible to the other. The two buffers'
 position, limit and mark are independent.
 */
- (JavaNioDoubleBuffer *)duplicate;

/*!
 @brief Checks whether this double buffer is equal to another object.
 If <code>other</code>
  is not a <code>DoubleBuffer</code> then <code>false</code> is returned.
 <p>Two double buffers are equal if their remaining doubles are equal.
 Position, limit, capacity and mark are not considered.
 <p>This method considers two doubles <code>a</code> and <code>b</code> to be equal
 if <code>a == b</code> or if <code>a</code> and <code>b</code> are both <code>NaN</code>.
 Unlike <code>Double.equals</code>, this method considers <code>-0.0</code> and
 <code>+0.0</code> to be equal.
 @param other
 the object to compare with this double buffer.
 @return <code>true</code> if this double buffer is equal to <code>other</code>,
 <code>false</code> otherwise.
 */
- (jboolean)isEqual:(id)other;

/*!
 @brief Returns the double at the current position and increases the position by
 1.
 @return the double at the current position.
 @throws BufferUnderflowException
 if the position is equal or greater than limit.
 */
- (jdouble)get;

/*!
 @brief Reads doubles from the current position into the specified double array
 and increases the position by the number of doubles read.
 <p>
 Calling this method has the same effect as
 <code>get(dst, 0, dst.length)</code>.
 @param dst
 the destination double array.
 @return this buffer.
 @throws BufferUnderflowException
 if <code>dst.length</code> is greater than <code>remaining()</code>.
 */
- (JavaNioDoubleBuffer *)getWithDoubleArray:(IOSDoubleArray *)dst;

/*!
 @brief Reads doubles from the current position into the specified double array,
 starting from the specified offset, and increases the position by the
 number of doubles read.
 @param dst
 the target double array.
 @param dstOffset
 the offset of the double array, must not be negative and not
 greater than <code>dst.length</code>.
 @param doubleCount
 the number of doubles to read, must be no less than zero and
 not greater than <code>dst.length - dstOffset</code>.
 @return this buffer.
 @throws IndexOutOfBoundsException
 if either <code>dstOffset</code> or <code>doubleCount</code> is invalid.
 @throws BufferUnderflowException
 if <code>doubleCount</code> is greater than <code>remaining()</code>.
 */
- (JavaNioDoubleBuffer *)getWithDoubleArray:(IOSDoubleArray *)dst
                                    withInt:(jint)dstOffset
                                    withInt:(jint)doubleCount;

/*!
 @brief Returns a double at the specified index; the position is not changed.
 @param index
 the index, must not be negative and less than limit.
 @return a double at the specified index.
 @throws IndexOutOfBoundsException
 if index is invalid.
 */
- (jdouble)getWithInt:(jint)index;

- (jboolean)hasArray;

/*!
 @brief Calculates this buffer's hash code from the remaining chars.
 The
 position, limit, capacity and mark don't affect the hash code.
 @return the hash code calculated from the remaining chars.
 */
- (NSUInteger)hash;

/*!
 @brief Indicates whether this buffer is direct.
 A direct buffer will try its
 best to take advantage of native memory APIs and it may not stay in the
 Java heap, so it is not affected by garbage collection.
 <p>
 A double buffer is direct if it is based on a byte buffer and the byte
 buffer is direct.
 @return <code>true</code> if this buffer is direct, <code>false</code> otherwise.
 */
- (jboolean)isDirect;

/*!
 @brief Returns the byte order used by this buffer when converting doubles
 from/to bytes.
 <p>
 If this buffer is not based on a byte buffer, then this always returns
 the platform's native byte order.
 @return the byte order used by this buffer when converting doubles
 from/to bytes.
 */
- (JavaNioByteOrder *)order;

/*!
 @brief Writes the given double to the current position and increases the
 position by 1.
 @param d
 the double to write.
 @return this buffer.
 @throws BufferOverflowException
 if position is equal or greater than limit.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioDoubleBuffer *)putWithDouble:(jdouble)d;

/*!
 @brief Writes doubles from the given double array to the current position and
 increases the position by the number of doubles written.
 <p>
 Calling this method has the same effect as
 <code>put(src, 0, src.length)</code>.
 @param src
 the source double array.
 @return this buffer.
 @throws BufferOverflowException
 if <code>remaining()</code> is less than <code>src.length</code>.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioDoubleBuffer *)putWithDoubleArray:(IOSDoubleArray *)src;

/*!
 @brief Writes doubles from the given double array, starting from the specified
 offset, to the current position and increases the position by the number
 of doubles written.
 @param src
 the source double array.
 @param srcOffset
 the offset of double array, must not be negative and not
 greater than <code>src.length</code>.
 @param doubleCount
 the number of doubles to write, must be no less than zero and
 not greater than <code>src.length - srcOffset</code>.
 @return this buffer.
 @throws BufferOverflowException
 if <code>remaining()</code> is less than <code>doubleCount</code>.
 @throws IndexOutOfBoundsException
 if either <code>srcOffset</code> or <code>doubleCount</code> is invalid.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioDoubleBuffer *)putWithDoubleArray:(IOSDoubleArray *)src
                                    withInt:(jint)srcOffset
                                    withInt:(jint)doubleCount;

/*!
 @brief Writes all the remaining doubles of the <code>src</code> double buffer to this
 buffer's current position, and increases both buffers' position by the
 number of doubles copied.
 @param src
 the source double buffer.
 @return this buffer.
 @throws BufferOverflowException
 if <code>src.remaining()</code> is greater than this buffer's
 <code>remaining()</code>.
 @throws IllegalArgumentException
 if <code>src</code> is this buffer.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioDoubleBuffer *)putWithJavaNioDoubleBuffer:(JavaNioDoubleBuffer *)src;

/*!
 @brief Write a double to the specified index of this buffer and the position is
 not changed.
 @param index
 the index, must not be negative and less than the limit.
 @param d
 the double to write.
 @return this buffer.
 @throws IndexOutOfBoundsException
 if index is invalid.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioDoubleBuffer *)putWithInt:(jint)index
                         withDouble:(jdouble)d;

/*!
 @brief Returns a sliced buffer that shares its content with this buffer.
 <p>
 The sliced buffer's capacity will be this buffer's <code>remaining()</code>,
 and its zero position will correspond to this buffer's current position.
 The new buffer's position will be 0, limit will be its capacity, and its
 mark is cleared. The new buffer's read-only property and byte order are
 the same as this buffer's.
 <p>
 The new buffer shares its content with this buffer, which means either
 buffer's change of content will be visible to the other. The two buffers'
 position, limit and mark are independent.
 */
- (JavaNioDoubleBuffer *)slice;

/*!
 @brief Creates a new double buffer by wrapping the given double array.
 <p>
 Calling this method has the same effect as
 <code>wrap(array, 0, array.length)</code>.
 @param array
 the double array which the new buffer will be based on.
 @return the created double buffer.
 */
+ (JavaNioDoubleBuffer *)wrapWithDoubleArray:(IOSDoubleArray *)array;

/*!
 @brief Creates a new double buffer by wrapping the given double array.
 <p>
 The new buffer's position will be <code>start</code>, limit will be
 <code>start + doubleCount</code>, capacity will be the length of the array.
 @param array
 the double array which the new buffer will be based on.
 @param start
 the start index, must not be negative and not greater than
 <code>array.length</code>.
 @param doubleCount
 the length, must not be negative and not greater than
 <code>array.length - start</code>.
 @return the created double buffer.
 @throws IndexOutOfBoundsException
 if either <code>start</code> or <code>doubleCount</code> is invalid.
 */
+ (JavaNioDoubleBuffer *)wrapWithDoubleArray:(IOSDoubleArray *)array
                                     withInt:(jint)start
                                     withInt:(jint)doubleCount;

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)capacity
                   withLong:(jlong)effectiveDirectAddress;

/*!
 @brief Child class implements this method to realize <code>array()</code>.
 - seealso: #array()
 */
- (IOSDoubleArray *)protectedArray;

/*!
 @brief Child class implements this method to realize <code>arrayOffset()</code>.
 - seealso: #arrayOffset()
 */
- (jint)protectedArrayOffset;

/*!
 @brief Child class implements this method to realize <code>hasArray()</code>.
 - seealso: #hasArray()
 */
- (jboolean)protectedHasArray;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioDoubleBuffer)

FOUNDATION_EXPORT JavaNioDoubleBuffer *JavaNioDoubleBuffer_allocateWithInt_(jint capacity);

FOUNDATION_EXPORT JavaNioDoubleBuffer *JavaNioDoubleBuffer_wrapWithDoubleArray_(IOSDoubleArray *array);

FOUNDATION_EXPORT JavaNioDoubleBuffer *JavaNioDoubleBuffer_wrapWithDoubleArray_withInt_withInt_(IOSDoubleArray *array, jint start, jint doubleCount);

FOUNDATION_EXPORT void JavaNioDoubleBuffer_initWithInt_withLong_(JavaNioDoubleBuffer *self, jint capacity, jlong effectiveDirectAddress);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioDoubleBuffer)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaNioDoubleBuffer_INCLUDE_ALL")

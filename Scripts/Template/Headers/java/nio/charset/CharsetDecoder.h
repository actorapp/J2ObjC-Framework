//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/nio/charset/CharsetDecoder.java
//

#include "../../../J2ObjC_header.h"

#pragma push_macro("JavaNioCharsetCharsetDecoder_INCLUDE_ALL")
#ifdef JavaNioCharsetCharsetDecoder_RESTRICT
#define JavaNioCharsetCharsetDecoder_INCLUDE_ALL 0
#else
#define JavaNioCharsetCharsetDecoder_INCLUDE_ALL 1
#endif
#undef JavaNioCharsetCharsetDecoder_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaNioCharsetCharsetDecoder_) && (JavaNioCharsetCharsetDecoder_INCLUDE_ALL || defined(JavaNioCharsetCharsetDecoder_INCLUDE))
#define JavaNioCharsetCharsetDecoder_

@class JavaNioByteBuffer;
@class JavaNioCharBuffer;
@class JavaNioCharsetCharset;
@class JavaNioCharsetCoderResult;
@class JavaNioCharsetCodingErrorAction;

/*!
 @brief A converter that can convert a byte sequence from a charset into a 16-bit
 Unicode character sequence.
 <p>
 The input byte sequence is wrapped by a
 <code>ByteBuffer</code> and the output character sequence is a
 <code>CharBuffer</code>. A decoder instance should be used in
 the following sequence, which is referred to as a decoding operation:
 <ol>
 <li>invoking the <code>reset</code> method to reset the decoder if the
 decoder has been used;</li>
 <li>invoking the <code>decode</code>
 method until the additional input is not needed, the <code>endOfInput</code>
 parameter must be set to false, the input buffer must be filled and the
 output buffer must be flushed between invocations;</li>
 <li>invoking the <code>decode</code>
 method for the last time, and then the <code>endOfInput</code> parameter
 must be set to true;</li>
 <li>invoking the <code>flush</code> method to flush the
 output.</li>
 </ol>
 <p>
 The <code>decode</code> method will
 convert as many bytes as possible, and the process won't stop until the input
 bytes have run out, the output buffer has been filled or some error has
 happened. A <code>CoderResult</code> instance will be returned to
 indicate the stop reason, and the invoker can identify the result and choose
 further action, which includes filling the input buffer, flushing the output
 buffer or recovering from an error and trying again.
 <p>
 There are two common decoding errors. One is named malformed and it is
 returned when the input byte sequence is illegal for the current specific
 charset, the other is named unmappable character and it is returned when a
 problem occurs mapping a legal input byte sequence to its Unicode character
 equivalent.
 <p>
 Both errors can be handled in three ways, the default one is to report the
 error to the invoker by a <code>CoderResult</code> instance, and the
 alternatives are to ignore it or to replace the erroneous input with the
 replacement string. The replacement string is "\uFFFD" by default and can be
 changed by invoking <code>replaceWith</code> method. The
 invoker of this decoder can choose one way by specifying a
 <code>CodingErrorAction</code> instance for each error type via
 <code>onMalformedInput</code> method and
 <code>onUnmappableCharacter</code>
 method.
 <p>
 This is an abstract class and encapsulates many common operations of the
 decoding process for all charsets. Decoders for a specific charset should
 extend this class and need only to implement the
 <code>decodeLoop</code> method for the basic
 decoding.
 <p>
 This class is not thread-safe.
 - seealso: java.nio.charset.Charset
 - seealso: java.nio.charset.CharsetEncoder
 */
@interface JavaNioCharsetCharsetDecoder : NSObject

#pragma mark Public

/*!
 @brief Returns the average number of characters created by this decoder for a
 single input byte.
 */
- (jfloat)averageCharsPerByte;

/*!
 @brief Returns the <code>Charset</code> which this decoder uses.
 */
- (JavaNioCharsetCharset *)charset;

/*!
 @brief This is a facade method for the decoding operation.
 <p>
 This method decodes the remaining byte sequence of the given byte buffer
 into a new character buffer. This method performs a complete decoding
 operation, resets at first, then decodes, and flushes at last.
 <p>
 This method should not be invoked while another <code>decode</code> operation
 is ongoing.
 @param inArg
 the input buffer.
 @return a new <code>CharBuffer</code> containing the the characters
 produced by this decoding operation. The buffer's limit will be
 the position of the last character in the buffer, and the
 position will be zero.
 @throws IllegalStateException
 if another decoding operation is ongoing.
 @throws MalformedInputException
 if an illegal input byte sequence for this charset was
 encountered, and the action for malformed error is
 <code>CodingErrorAction.REPORT</code>
 @throws UnmappableCharacterException
 if a legal but unmappable input byte sequence for this
 charset was encountered, and the action for unmappable
 character error is
 <code>CodingErrorAction.REPORT</code>.
 Unmappable means the byte sequence at the input buffer's
 current position cannot be mapped to a Unicode character
 sequence.
 @throws CharacterCodingException
 if another exception happened during the decode operation.
 */
- (JavaNioCharBuffer *)decodeWithJavaNioByteBuffer:(JavaNioByteBuffer *)inArg;

/*!
 @brief Decodes bytes starting at the current position of the given input buffer,
 and writes the equivalent character sequence into the given output buffer
 from its current position.
 <p>
 The buffers' position will be changed with the reading and writing
 operation, but their limits and marks will be kept intact.
 <p>
 A <code>CoderResult</code> instance will be returned according to
 following rules:
 <ul>
 <li><code>CoderResult.OVERFLOW</code> indicates that
 even though not all of the input has been processed, the buffer the
 output is being written to has reached its capacity. In the event of this
 code being returned this method should be called once more with an
 <code>out</code> argument that has not already been filled.</li>
 <li><code>CoderResult.UNDERFLOW</code> indicates that
 as many bytes as possible in the input buffer have been decoded. If there
 is no further input and no remaining bytes in the input buffer then this
 operation may be regarded as complete. Otherwise, this method should be
 called once more with additional input.</li>
 <li>A <code>malformed input</code> result
 indicates that some malformed input error has been encountered, and the
 erroneous bytes start at the input buffer's position and their number can
 be got by result's <code>length</code>. This kind of
 result can be returned only if the malformed action is
 <code>CodingErrorAction.REPORT</code>. </li>
 <li>A <code>unmappable character</code>
 result indicates that some unmappable character error has been
 encountered, and the erroneous bytes start at the input buffer's position
 and their number can be got by result's
 <code>length</code>. This kind of result can be returned
 only if the unmappable character action is
 <code>CodingErrorAction.REPORT</code>. </li>
 </ul>
 <p>
 The <code>endOfInput</code> parameter indicates that the invoker cannot
 provide further input. This parameter is true if and only if the bytes in
 current input buffer are all inputs for this decoding operation. Note
 that it is common and won't cause an error if the invoker sets false and
 then can't provide more input, while it may cause an error if the invoker
 always sets true in several consecutive invocations. This would make the
 remaining input to be treated as malformed input.
 <p>
 This method invokes the
 <code>decodeLoop</code> method to
 implement the basic decode logic for a specific charset.
 @param inArg
 the input buffer.
 @param outArg
 the output buffer.
 @param endOfInput
 true if all the input characters have been provided.
 @return a <code>CoderResult</code> instance which indicates the reason
 of termination.
 @throws IllegalStateException
 if decoding has started or no more input is needed in this
 decoding progress.
 @throws CoderMalfunctionError
 if the <code>decodeLoop</code>
 method threw an <code>BufferUnderflowException</code> or
 <code>BufferOverflowException</code>.
 */
- (JavaNioCharsetCoderResult *)decodeWithJavaNioByteBuffer:(JavaNioByteBuffer *)inArg
                                     withJavaNioCharBuffer:(JavaNioCharBuffer *)outArg
                                               withBoolean:(jboolean)endOfInput;

/*!
 @brief Gets the charset detected by this decoder; this method is optional.
 <p>
 If implementing an auto-detecting charset, then this decoder returns the
 detected charset from this method when it is available. The returned
 charset will be the same for the rest of the decode operation.
 <p>
 If insufficient bytes have been read to determine the charset, an
 <code>IllegalStateException</code> will be thrown.
 <p>
 The default implementation always throws
 <code>UnsupportedOperationException</code>, so it should be overridden
 by a subclass if needed.
 @return the charset detected by this decoder, or null if it is not yet
 determined.
 @throws UnsupportedOperationException
 if this decoder does not implement an auto-detecting charset.
 @throws IllegalStateException
 if insufficient bytes have been read to determine the
 charset.
 */
- (JavaNioCharsetCharset *)detectedCharset;

/*!
 @brief Flushes this decoder.
 The maximum number of written bytes won't be larger than
 <code>out.remaining()</code>. If some decoder wants to
 write more bytes than an output buffer's remaining space allows, then a
 <code>CoderResult.OVERFLOW</code> will be returned, and this method
 must be called again with a character buffer that has more remaining
 space. Otherwise this method will return
 <code>CoderResult.UNDERFLOW</code>, which means one decoding process
 has been completed successfully.
 <p>
 During the flush, the output buffer's position will be changed
 accordingly, while its mark and limit will be intact.
 @param outArg
 the given output buffer.
 @return <code>CoderResult.UNDERFLOW</code> or
 <code>CoderResult.OVERFLOW</code>.
 @throws IllegalStateException
 if this decoder hasn't read all input bytes during one
 decoding process, which means neither after calling
 <code>decode(ByteBuffer)</code> nor after
 calling <code>decode(ByteBuffer, CharBuffer, boolean)</code>
  with true as value
 for the last boolean parameter.
 */
- (JavaNioCharsetCoderResult *)flushWithJavaNioCharBuffer:(JavaNioCharBuffer *)outArg;

/*!
 @brief Indicates whether this decoder implements an auto-detecting charset.
 @return <code>true</code> if this decoder implements an auto-detecting
 charset.
 */
- (jboolean)isAutoDetecting;

/*!
 @brief Indicates whether this decoder has detected a charset; this method is
 optional.
 <p>
 If this decoder implements an auto-detecting charset, then this method
 may start to return true during decoding operation to indicate that a
 charset has been detected in the input bytes and that the charset can be
 retrieved by invoking the <code>detectedCharset</code>
 method.
 <p>
 Note that a decoder that implements an auto-detecting charset may still
 succeed in decoding a portion of the given input even when it is unable
 to detect the charset. For this reason users should be aware that a
 <code>false</code> return value does not indicate that no decoding took
 place.
 <p>
 The default implementation always throws an
 <code>UnsupportedOperationException</code>; it should be overridden by
 a subclass if needed.
 @return <code>true</code> if this decoder has detected a charset.
 @throws UnsupportedOperationException
 if this decoder doesn't implement an auto-detecting charset.
 */
- (jboolean)isCharsetDetected;

/*!
 @brief Returns the maximum number of characters which can be created by this
 decoder for one input byte, must be positive.
 */
- (jfloat)maxCharsPerByte;

/*!
 @brief Sets this decoder's action on malformed input errors.
 @param newAction
 the new action on malformed input error.
 @return this decoder.
 @throws IllegalArgumentException
 if <code>newAction</code> is <code>null</code>.
 */
- (JavaNioCharsetCharsetDecoder *)onMalformedInputWithJavaNioCharsetCodingErrorAction:(JavaNioCharsetCodingErrorAction *)newAction;

/*!
 @brief Sets this decoder's action on unmappable character errors.
 @param newAction
 the new action on unmappable character error.
 @return this decoder.
 @throws IllegalArgumentException
 if <code>newAction</code> is <code>null</code>.
 */
- (JavaNioCharsetCharsetDecoder *)onUnmappableCharacterWithJavaNioCharsetCodingErrorAction:(JavaNioCharsetCodingErrorAction *)newAction;

/*!
 @brief Returns the replacement string, which is never null or empty.
 */
- (NSString *)replacement;

/*!
 @brief Sets the new replacement string.
 @param replacement
 the replacement string, cannot be null or empty. Its length
 cannot be larger than <code>maxCharsPerByte()</code>.
 @return this decoder.
 @throws IllegalArgumentException
 if the given replacement cannot satisfy the requirement
 mentioned above.
 */
- (JavaNioCharsetCharsetDecoder *)replaceWithWithNSString:(NSString *)replacement;

/*!
 @brief Resets this decoder.
 @return this decoder.
 */
- (JavaNioCharsetCharsetDecoder *)reset;

#pragma mark Protected

/*!
 @brief Constructs a new <code>CharsetDecoder</code> using the given
 <code>Charset</code>, average number and maximum number of characters
 created by this decoder for one input byte, and the default replacement
 string "\uFFFD".
 @param charset
 the <code>Charset</code> to be used by this decoder.
 @param averageCharsPerByte
 the average number of characters created by this decoder for
 one input byte, must be positive.
 @param maxCharsPerByte
 the maximum number of characters created by this decoder for
 one input byte, must be positive.
 @throws IllegalArgumentException
 if <code>averageCharsPerByte</code> or
 <code>maxCharsPerByte</code> is negative.
 */
- (instancetype)initWithJavaNioCharsetCharset:(JavaNioCharsetCharset *)charset
                                    withFloat:(jfloat)averageCharsPerByte
                                    withFloat:(jfloat)maxCharsPerByte;

/*!
 @brief Decodes bytes into characters.
 This method is called by the
 <code>decode</code> method.
 <p>
 This method will implement the essential decoding operation, and it won't
 stop decoding until either all the input bytes are read, the output
 buffer is filled, or some exception is encountered. Then it will return a
 <code>CoderResult</code> object indicating the result of current
 decoding operation. The rules to construct the <code>CoderResult</code>
 are the same as for
 <code>decode</code>. When an
 exception is encountered in the decoding operation, most implementations
 of this method will return a relevant result object to the
 <code>decode</code> method, and some
 performance optimized implementation may handle the exception and
 implement the error action itself.
 <p>
 The buffers are scanned from their current positions, and their positions
 will be modified accordingly, while their marks and limits will be
 intact. At most <code>in.remaining()</code> characters
 will be read, and <code>out.remaining()</code> bytes
 will be written.
 <p>
 Note that some implementations may pre-scan the input buffer and return a
 <code>CoderResult.UNDERFLOW</code> until it receives sufficient input.
 @param inArg
 the input buffer.
 @param outArg
 the output buffer.
 @return a <code>CoderResult</code> instance indicating the result.
 */
- (JavaNioCharsetCoderResult *)decodeLoopWithJavaNioByteBuffer:(JavaNioByteBuffer *)inArg
                                         withJavaNioCharBuffer:(JavaNioCharBuffer *)outArg;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioCharsetCharsetDecoder)

FOUNDATION_EXPORT void JavaNioCharsetCharsetDecoder_initWithJavaNioCharsetCharset_withFloat_withFloat_(JavaNioCharsetCharsetDecoder *self, JavaNioCharsetCharset *charset, jfloat averageCharsPerByte, jfloat maxCharsPerByte);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioCharsetCharsetDecoder)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaNioCharsetCharsetDecoder_INCLUDE_ALL")

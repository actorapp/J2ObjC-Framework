//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/nio/LongBuffer.java
//

#include "../../J2ObjC_header.h"

#pragma push_macro("JavaNioLongBuffer_INCLUDE_ALL")
#ifdef JavaNioLongBuffer_RESTRICT
#define JavaNioLongBuffer_INCLUDE_ALL 0
#else
#define JavaNioLongBuffer_INCLUDE_ALL 1
#endif
#undef JavaNioLongBuffer_RESTRICT

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaNioLongBuffer_) && (JavaNioLongBuffer_INCLUDE_ALL || defined(JavaNioLongBuffer_INCLUDE))
#define JavaNioLongBuffer_

#define JavaNioBuffer_RESTRICT 1
#define JavaNioBuffer_INCLUDE 1
#include "../../java/nio/Buffer.h"

#define JavaLangComparable_RESTRICT 1
#define JavaLangComparable_INCLUDE 1
#include "../../java/lang/Comparable.h"

@class IOSLongArray;
@class JavaNioByteOrder;

/*!
 @brief A buffer of longs.
 <p>
 A long buffer can be created in either of the following ways:
 <ul>
 <li><code>Allocate</code> a new long array and create a buffer
 based on it;</li>
 <li><code>Wrap</code> an existing long array to create a new
 buffer;</li>
 <li>Use <code>ByteBuffer.asLongBuffer</code>
 to create a long buffer based on a byte buffer.</li>
 </ul>
 */
@interface JavaNioLongBuffer : JavaNioBuffer < JavaLangComparable >

#pragma mark Public

/*!
 @brief Creates a long buffer based on a newly allocated long array.
 @param capacity
 the capacity of the new buffer.
 @return the created long buffer.
 @throws IllegalArgumentException
 if <code>capacity</code> is less than zero.
 */
+ (JavaNioLongBuffer *)allocateWithInt:(jint)capacity OBJC_METHOD_FAMILY_NONE;

- (IOSLongArray *)array;

- (jint)arrayOffset;

/*!
 @brief Returns a read-only buffer that shares its content with this buffer.
 <p>
 The returned buffer is guaranteed to be a new instance, even if this
 buffer is read-only itself. The new buffer's position, limit, capacity
 and mark are the same as this buffer's.
 <p>
 The new buffer shares its content with this buffer, which means this
 buffer's change of content will be visible to the new buffer. The two
 buffer's position, limit and mark are independent.
 @return a read-only version of this buffer.
 */
- (JavaNioLongBuffer *)asReadOnlyBuffer;

/*!
 @brief Compacts this long buffer.
 <p>
 The remaining longs will be moved to the head of the buffer, staring from
 position zero. Then the position is set to <code>remaining()</code>; the
 limit is set to capacity; the mark is cleared.
 @return this buffer.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioLongBuffer *)compact;

/*!
 @brief Compare the remaining longs of this buffer to another long buffer's
 remaining longs.
 @param otherBuffer
 another long buffer.
 @return a negative value if this is less than <code>otherBuffer</code>; 0 if
 this equals to <code>otherBuffer</code>; a positive value if this is
 greater than <code>otherBuffer</code>
 @throws ClassCastException
 if <code>otherBuffer</code> is not a long buffer.
 */
- (jint)compareToWithId:(JavaNioLongBuffer *)otherBuffer;

/*!
 @brief Returns a duplicated buffer that shares its content with this buffer.
 <p>
 The duplicated buffer's position, limit, capacity and mark are the same
 as this buffer. The duplicated buffer's read-only property and byte order
 are same as this buffer's, too.
 <p>
 The new buffer shares its content with this buffer, which means either
 buffer's change of content will be visible to the other. The two buffers'
 position, limit and mark are independent.
 */
- (JavaNioLongBuffer *)duplicate;

/*!
 @brief Checks whether this long buffer is equal to another object.
 <p>
 If <code>other</code> is not a long buffer then <code>false</code> is returned. Two
 long buffers are equal if and only if their remaining longs are exactly
 the same. Position, limit, capacity and mark are not considered.
 @param other
 the object to compare with this long buffer.
 @return <code>true</code> if this long buffer is equal to <code>other</code>,
 <code>false</code> otherwise.
 */
- (jboolean)isEqual:(id)other;

/*!
 @brief Returns the long at the current position and increase the position by 1.
 @return the long at the current position.
 @throws BufferUnderflowException
 if the position is equal or greater than limit.
 */
- (jlong)get;

/*!
 @brief Returns the long at the specified index; the position is not changed.
 @param index
 the index, must not be negative and less than limit.
 @return the long at the specified index.
 @throws IndexOutOfBoundsException
 if index is invalid.
 */
- (jlong)getWithInt:(jint)index;

/*!
 @brief Reads longs from the current position into the specified long array and
 increases the position by the number of longs read.
 <p>
 Calling this method has the same effect as
 <code>get(dst, 0, dst.length)</code>.
 @param dst
 the destination long array.
 @return this buffer.
 @throws BufferUnderflowException
 if <code>dst.length</code> is greater than <code>remaining()</code>.
 */
- (JavaNioLongBuffer *)getWithLongArray:(IOSLongArray *)dst;

/*!
 @brief Reads longs from the current position into the specified long array,
 starting from the specified offset, and increase the position by the
 number of longs read.
 @param dst
 the target long array.
 @param dstOffset
 the offset of the long array, must not be negative and not
 greater than <code>dst.length</code>.
 @param longCount
 the number of longs to read, must be no less than zero and not
 greater than <code>dst.length - dstOffset</code>.
 @return this buffer.
 @throws IndexOutOfBoundsException
 if either <code>dstOffset</code> or <code>longCount</code> is invalid.
 @throws BufferUnderflowException
 if <code>longCount</code> is greater than <code>remaining()</code>.
 */
- (JavaNioLongBuffer *)getWithLongArray:(IOSLongArray *)dst
                                withInt:(jint)dstOffset
                                withInt:(jint)longCount;

- (jboolean)hasArray;

/*!
 @brief Calculates this buffer's hash code from the remaining chars.
 The
 position, limit, capacity and mark don't affect the hash code.
 @return the hash code calculated from the remaining longs.
 */
- (NSUInteger)hash;

/*!
 @brief Indicates whether this buffer is direct.
 A direct buffer will try its
 best to take advantage of native memory APIs and it may not stay in the
 Java heap, so it is not affected by garbage collection.
 <p>
 A long buffer is direct if it is based on a byte buffer and the byte
 buffer is direct.
 @return <code>true</code> if this buffer is direct, <code>false</code> otherwise.
 */
- (jboolean)isDirect;

/*!
 @brief Returns the byte order used by this buffer when converting longs from/to
 bytes.
 <p>
 If this buffer is not based on a byte buffer, then always return the
 platform's native byte order.
 @return the byte order used by this buffer when converting longs from/to
 bytes.
 */
- (JavaNioByteOrder *)order;

/*!
 @brief Writes a long to the specified index of this buffer; the position is not
 changed.
 @param index
 the index, must not be negative and less than the limit.
 @param l
 the long to write.
 @return this buffer.
 @throws IndexOutOfBoundsException
 if index is invalid.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioLongBuffer *)putWithInt:(jint)index
                         withLong:(jlong)l;

/*!
 @brief Writes the given long to the current position and increases the position
 by 1.
 @param l
 the long to write.
 @return this buffer.
 @throws BufferOverflowException
 if position is equal or greater than limit.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioLongBuffer *)putWithLong:(jlong)l;

/*!
 @brief Writes longs from the given long array to the current position and
 increases the position by the number of longs written.
 <p>
 Calling this method has the same effect as
 <code>put(src, 0, src.length)</code>.
 @param src
 the source long array.
 @return this buffer.
 @throws BufferOverflowException
 if <code>remaining()</code> is less than <code>src.length</code>.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioLongBuffer *)putWithLongArray:(IOSLongArray *)src;

/*!
 @brief Writes longs from the given long array, starting from the specified
 offset, to the current position and increases the position by the number
 of longs written.
 @param src
 the source long array.
 @param srcOffset
 the offset of long array, must not be negative and not greater
 than <code>src.length</code>.
 @param longCount
 the number of longs to write, must be no less than zero and
 not greater than <code>src.length - srcOffset</code>.
 @return this buffer.
 @throws BufferOverflowException
 if <code>remaining()</code> is less than <code>longCount</code>.
 @throws IndexOutOfBoundsException
 if either <code>srcOffset</code> or <code>longCount</code> is invalid.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioLongBuffer *)putWithLongArray:(IOSLongArray *)src
                                withInt:(jint)srcOffset
                                withInt:(jint)longCount;

/*!
 @brief Writes all the remaining longs of the <code>src</code> long buffer to this
 buffer's current position, and increases both buffers' position by the
 number of longs copied.
 @param src
 the source long buffer.
 @return this buffer.
 @throws BufferOverflowException
 if <code>src.remaining()</code> is greater than this buffer's
 <code>remaining()</code>.
 @throws IllegalArgumentException
 if <code>src</code> is this buffer.
 @throws ReadOnlyBufferException
 if no changes may be made to the contents of this buffer.
 */
- (JavaNioLongBuffer *)putWithJavaNioLongBuffer:(JavaNioLongBuffer *)src;

/*!
 @brief Returns a sliced buffer that shares its content with this buffer.
 <p>
 The sliced buffer's capacity will be this buffer's <code>remaining()</code>,
 and its zero position will correspond to this buffer's current position.
 The new buffer's position will be 0, limit will be its capacity, and its
 mark is cleared. The new buffer's read-only property and byte order are
 same as this buffer's.
 <p>
 The new buffer shares its content with this buffer, which means either
 buffer's change of content will be visible to the other. The two buffers'
 position, limit and mark are independent.
 */
- (JavaNioLongBuffer *)slice;

/*!
 @brief Creates a new long buffer by wrapping the given long array.
 <p>
 Calling this method has the same effect as
 <code>wrap(array, 0, array.length)</code>.
 @param array
 the long array which the new buffer will be based on.
 @return the created long buffer.
 */
+ (JavaNioLongBuffer *)wrapWithLongArray:(IOSLongArray *)array;

/*!
 @brief Creates a new long buffer by wrapping the given long array.
 <p>
 The new buffer's position will be <code>start</code>, limit will be
 <code>start + longCount</code>, capacity will be the length of the array.
 @param array
 the long array which the new buffer will be based on.
 @param start
 the start index, must not be negative and not greater than
 <code>array.length</code>.
 @param longCount
 the length, must not be negative and not greater than
 <code>array.length - start</code>.
 @return the created long buffer.
 @throws IndexOutOfBoundsException
 if either <code>start</code> or <code>longCount</code> is invalid.
 */
+ (JavaNioLongBuffer *)wrapWithLongArray:(IOSLongArray *)array
                                 withInt:(jint)start
                                 withInt:(jint)longCount;

#pragma mark Package-Private

- (instancetype)initWithInt:(jint)capacity
                   withLong:(jlong)effectiveDirectAddress;

/*!
 @brief Child class implements this method to realize <code>array()</code>.
 @return see <code>array()</code>
 */
- (IOSLongArray *)protectedArray;

/*!
 @brief Child class implements this method to realize <code>arrayOffset()</code>.
 @return see <code>arrayOffset()</code>
 */
- (jint)protectedArrayOffset;

/*!
 @brief Child class implements this method to realize <code>hasArray()</code>.
 @return see <code>hasArray()</code>
 */
- (jboolean)protectedHasArray;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioLongBuffer)

FOUNDATION_EXPORT JavaNioLongBuffer *JavaNioLongBuffer_allocateWithInt_(jint capacity);

FOUNDATION_EXPORT JavaNioLongBuffer *JavaNioLongBuffer_wrapWithLongArray_(IOSLongArray *array);

FOUNDATION_EXPORT JavaNioLongBuffer *JavaNioLongBuffer_wrapWithLongArray_withInt_withInt_(IOSLongArray *array, jint start, jint longCount);

FOUNDATION_EXPORT void JavaNioLongBuffer_initWithInt_withLong_(JavaNioLongBuffer *self, jint capacity, jlong effectiveDirectAddress);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioLongBuffer)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("JavaNioLongBuffer_INCLUDE_ALL")

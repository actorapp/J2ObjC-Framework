//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/Locale.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilLocale")
#ifdef RESTRICT_JavaUtilLocale
#define INCLUDE_ALL_JavaUtilLocale 0
#else
#define INCLUDE_ALL_JavaUtilLocale 1
#endif
#undef RESTRICT_JavaUtilLocale

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilLocale_) && (INCLUDE_ALL_JavaUtilLocale || defined(INCLUDE_JavaUtilLocale))
#define JavaUtilLocale_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@protocol JavaUtilMap;
@protocol JavaUtilSet;

/*!
 @brief <code>Locale</code> represents a language/country/variant combination.
 Locales are used to
 alter the presentation of information such as numbers or dates to suit the conventions
 in the region they describe.
 <p>The language codes are two-letter lowercase ISO language codes (such as "en") as defined by
 <a href="http://en.wikipedia.org/wiki/ISO_639-1">ISO 639-1</a>.
 The country codes are two-letter uppercase ISO country codes (such as "US") as defined by
 <a href="http://en.wikipedia.org/wiki/ISO_3166-1_alpha-3">ISO 3166-1</a>.
 The variant codes are unspecified.
 <p>Note that Java uses several deprecated two-letter codes. The Hebrew ("he") language
 code is rewritten as "iw", Indonesian ("id") as "in", and Yiddish ("yi") as "ji". This
 rewriting happens even if you construct your own <code>Locale</code> object, not just for
 instances returned by the various lookup methods.
 <a name="available_locales"></a><h3>Available locales</h3>
 <p>This class' constructors do no error checking. You can create a <code>Locale</code> for languages
 and countries that don't exist, and you can create instances for combinations that don't
 exist (such as "de_US" for "German as spoken in the US").
 <p>Note that locale data is not necessarily available for any of the locales pre-defined as
 constants in this class except for en_US, which is the only locale Java guarantees is always
 available.
 <p>It is also a mistake to assume that all devices have the same locales available.
 A device sold in the US will almost certainly support en_US and es_US, but not necessarily
 any locales with the same language but different countries (such as en_GB or es_ES),
 nor any locales for other languages (such as de_DE). The opposite may well be true for a device
 sold in Europe.
 <p>You can use <code>Locale.getDefault</code> to get an appropriate locale for the <i>user</i> of the
 device you're running on, or <code>Locale.getAvailableLocales</code> to get a list of all the locales
 available on the device you're running on.
 <a name="locale_data"></a><h3>Locale data</h3>
 <p>Note that locale data comes solely from ICU. User-supplied locale service providers (using
 the <code>java.text.spi</code> or <code>java.util.spi</code> mechanisms) are not supported.
 <p>Here are the versions of ICU (and the corresponding CLDR and Unicode versions) used in
 various Android releases:
 <table BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
 <tr><td>Android 1.5 (Cupcake)/Android 1.6 (Donut)/Android 2.0 (Eclair)</td>
 <td>ICU 3.8</td>
 <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-5">CLDR 1.5</a></td>
 <td><a href="http://www.unicode.org/versions/Unicode5.0.0/">Unicode 5.0</a></td></tr>
 <tr><td>Android 2.2 (Froyo)</td>
 <td>ICU 4.2</td>
 <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-7">CLDR 1.7</a></td>
 <td><a href="http://www.unicode.org/versions/Unicode5.1.0/">Unicode 5.1</a></td></tr>
 <tr><td>Android 2.3 (Gingerbread)/Android 3.0 (Honeycomb)</td>
 <td>ICU 4.4</td>
 <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-8">CLDR 1.8</a></td>
 <td><a href="http://www.unicode.org/versions/Unicode5.2.0/">Unicode 5.2</a></td></tr>
 <tr><td>Android 4.0 (Ice Cream Sandwich)</td>
 <td><a href="http://site.icu-project.org/download/46">ICU 4.6</a></td>
 <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-9">CLDR 1.9</a></td>
 <td><a href="http://www.unicode.org/versions/Unicode6.0.0/">Unicode 6.0</a></td></tr>
 <tr><td>Android 4.1 (Jelly Bean)</td>
 <td><a href="http://site.icu-project.org/download/48">ICU 4.8</a></td>
 <td><a href="http://cldr.unicode.org/index/downloads/cldr-2-0">CLDR 2.0</a></td>
 <td><a href="http://www.unicode.org/versions/Unicode6.0.0/">Unicode 6.0</a></td></tr>
 <tr><td>Android 4.3 (Jelly Bean MR2)</td>
 <td><a href="http://site.icu-project.org/download/50">ICU 50</a></td>
 <td><a href="http://cldr.unicode.org/index/downloads/cldr-22-1">CLDR 22.1</a></td>
 <td><a href="http://www.unicode.org/versions/Unicode6.2.0/">Unicode 6.2</a></td></tr>
 <tr><td>Android 4.4 (KitKat)</td>
 <td><a href="http://site.icu-project.org/download/51">ICU 51</a></td>
 <td><a href="http://cldr.unicode.org/index/downloads/cldr-23">CLDR 23</a></td>
 <td><a href="http://www.unicode.org/versions/Unicode6.2.0/">Unicode 6.2</a></td></tr>
 <tr><td>Android 5.0 (Lollipop)</td>
 <td><a href="http://site.icu-project.org/download/53">ICU 53</a></td>
 <td><a href="http://cldr.unicode.org/index/downloads/cldr-25">CLDR 25</a></td>
 <td><a href="http://www.unicode.org/versions/Unicode6.3.0/">Unicode 6.3</a></td></tr>
 </table>
 <a name="default_locale"></a><h3>Be wary of the default locale</h3>
 <p>Note that there are many convenience methods that automatically use the default locale, but
 using them may lead to subtle bugs.
 <p>The default locale is appropriate for tasks that involve presenting data to the user. In
 this case, you want to use the user's date/time formats, number
 formats, rules for conversion to lowercase, and so on. In this case, it's safe to use the
 convenience methods.
 <p>The default locale is <i>not</i> appropriate for machine-readable output. The best choice
 there is usually <code>Locale.US</code>&nbsp;&ndash; this locale is guaranteed to be available on all
 devices, and the fact that it has no surprising special cases and is frequently used (especially
 for computer-computer communication) means that it tends to be the most efficient choice too.
 <p>A common mistake is to implicitly use the default locale when producing output meant to be
 machine-readable. This tends to work on the developer's test devices (especially because so many
 developers use en_US), but fails when run on a device whose user is in a more complex locale.
 <p>For example, if you're formatting integers some locales will use non-ASCII decimal
 digits. As another example, if you're formatting floating-point numbers some locales will use
 <code>','</code> as the decimal point and <code>'.'</code> for digit grouping. That's correct for
 human-readable output, but likely to cause problems if presented to another
 computer (<code>Double.parseDouble</code> can't parse such a number, for example).
 You should also be wary of the <code>String.toLowerCase</code> and
 <code>String.toUpperCase</code> overloads that don't take a <code>Locale</code>: in Turkey, for example,
 the characters <code>'i'</code> and <code>'I'</code> won't be converted to <code>'I'</code> and <code>'i'</code>.
 This is the correct behavior for Turkish text (such as user input), but inappropriate for, say,
 HTTP headers.
 */
@interface JavaUtilLocale : NSObject < NSCopying, JavaIoSerializable >

+ (JavaUtilLocale *)CANADA;

+ (JavaUtilLocale *)CANADA_FRENCH;

+ (JavaUtilLocale *)CHINA;

+ (JavaUtilLocale *)CHINESE;

+ (JavaUtilLocale *)ENGLISH;

+ (JavaUtilLocale *)FRANCE;

+ (JavaUtilLocale *)FRENCH;

+ (JavaUtilLocale *)GERMAN;

+ (JavaUtilLocale *)GERMANY;

+ (JavaUtilLocale *)ITALIAN;

+ (JavaUtilLocale *)ITALY;

+ (JavaUtilLocale *)JAPAN;

+ (JavaUtilLocale *)JAPANESE;

+ (JavaUtilLocale *)KOREA;

+ (JavaUtilLocale *)KOREAN;

+ (JavaUtilLocale *)PRC;

+ (JavaUtilLocale *)ROOT;

+ (JavaUtilLocale *)SIMPLIFIED_CHINESE;

+ (JavaUtilLocale *)TAIWAN;

+ (JavaUtilLocale *)TRADITIONAL_CHINESE;

+ (JavaUtilLocale *)UK;

+ (JavaUtilLocale *)US;

+ (jchar)PRIVATE_USE_EXTENSION;

+ (jchar)UNICODE_LOCALE_EXTENSION;

#pragma mark Public

/*!
 @brief Constructs a new <code>Locale</code> using the specified language.
 */
- (instancetype)initWithNSString:(NSString *)language;

/*!
 @brief Constructs a new <code>Locale</code> using the specified language and country codes.
 */
- (instancetype)initWithNSString:(NSString *)language
                    withNSString:(NSString *)country;

/*!
 @brief Constructs a new <code>Locale</code> using the specified language, country,
 and variant codes.
 */
- (instancetype)initWithNSString:(NSString *)language
                    withNSString:(NSString *)country
                    withNSString:(NSString *)variant;

/*!
 @brief Required by libcore.icu.ICU.
 */
- (instancetype)initWithNSString:(NSString *)language
                    withNSString:(NSString *)country
                    withNSString:(NSString *)variant
                    withNSString:(NSString *)scriptCode
                 withJavaUtilSet:(id<JavaUtilSet>)unicodeAttributes
                 withJavaUtilMap:(id<JavaUtilMap>)unicodeKeywords
                 withJavaUtilMap:(id<JavaUtilMap>)extensions
                     withBoolean:(jboolean)hasValidatedFields;

/*!
  for internal use only.
 */
+ (NSString *)adjustLanguageCodeWithNSString:(NSString *)languageCode;

- (id)clone;

/*!
 @brief Returns true if <code>object</code> is a locale with the same language,
 country and variant.
 */
- (jboolean)isEqual:(id)object;

/*!
 @brief Returns a locale for a given BCP-47 language tag.
 This method is more
 lenient than <code>Builder.setLanguageTag</code>. For a given language tag, parsing
 will proceed up to the first malformed subtag. All subsequent tags are discarded.
 Note that language tags use <code>-</code> rather than <code>_</code>, for example <code>en-US</code>.
 @throws NullPointerException if <code>languageTag</code> is <code>null</code>.
 @since 1.7
 */
+ (JavaUtilLocale *)forLanguageTagWithNSString:(NSString *)languageTag;

/*!
 @brief Returns the system's installed locales.
 This array always includes <code>Locale.US</code>
 , and usually several others. Most locale-sensitive classes
 offer their own <code>getAvailableLocales</code> method, which should be
 preferred over this general purpose method.
 - seealso: java.text.BreakIterator#getAvailableLocales()
 - seealso: java.text.Collator#getAvailableLocales()
 - seealso: java.text.DateFormat#getAvailableLocales()
 - seealso: java.text.DateFormatSymbols#getAvailableLocales()
 - seealso: java.text.DecimalFormatSymbols#getAvailableLocales()
 - seealso: java.text.NumberFormat#getAvailableLocales()
 - seealso: java.util.Calendar#getAvailableLocales()
 */
+ (IOSObjectArray *)getAvailableLocales;

/*!
 @brief Returns the country code for this locale, or <code>""</code> if this locale
 doesn't correspond to a specific country.
 */
- (NSString *)getCountry;

/*!
 @brief Returns the user's preferred locale.
 This may have been overridden for
 this process with <code>setDefault</code>.
 <p>Since the user's locale changes dynamically, avoid caching this value.
 Instead, use this method to look it up for each use.
 */
+ (JavaUtilLocale *)getDefault;

/*!
 @brief Returns the default locale from system properties.
  visible for testing.
 */
+ (JavaUtilLocale *)getDefaultLocaleFromSystemProperties;

/*!
 @brief Equivalent to <code>getDisplayCountry(Locale.getDefault())</code>.
 */
- (NSString *)getDisplayCountry;

/*!
 @brief Returns the name of this locale's country, localized to <code>locale</code>.
 Returns the empty string if this locale does not correspond to a specific
 country.
 */
- (NSString *)getDisplayCountryWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Equivalent to <code>getDisplayLanguage(Locale.getDefault())</code>.
 */
- (NSString *)getDisplayLanguage;

/*!
 @brief Returns the name of this locale's language, localized to <code>locale</code>.
 If the language name is unknown, the language code is returned.
 */
- (NSString *)getDisplayLanguageWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Equivalent to <code>getDisplayName(Locale.getDefault())</code>.
 */
- (NSString *)getDisplayName;

/*!
 @brief Returns this locale's language name, country name, and variant, localized
 to <code>locale</code>.
 The exact output form depends on whether this locale
 corresponds to a specific language, script, country and variant.
 <p>For example:
 <ul>
 <li><code>new Locale("en").getDisplayName(Locale.US)</code> -> <code>English</code>
 <li><code>new Locale("en", "US").getDisplayName(Locale.US)</code> -> <code>English (United States)</code>
 <li><code>new Locale("en", "US", "POSIX").getDisplayName(Locale.US)</code> -> <code>English (United States,Computer)</code>
 <li><code>Locale.fromLanguageTag("zh-Hant-CN").getDisplayName(Locale.US)</code> -> <code>Chinese (Traditional Han,China)</code>
 <li><code>new Locale("en").getDisplayName(Locale.FRANCE)</code> -> <code>anglais</code>
 <li><code>new Locale("en", "US").getDisplayName(Locale.FRANCE)</code> -> <code>anglais (États-Unis)</code>
 <li><code>new Locale("en", "US", "POSIX").getDisplayName(Locale.FRANCE)</code> -> <code>anglais (États-Unis,informatique)</code>.
 </ul>
 */
- (NSString *)getDisplayNameWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Equivalent to <code>getDisplayScript(Locale.getDefault()))</code>
 @since 1.7
 */
- (NSString *)getDisplayScript;

/*!
 @brief Returns the name of this locale's script code, localized to <code>Locale</code>.
 If the
 script code is unknown, the return value of this method is the same as that of
 <code>getScript()</code>.
 @since 1.7
 */
- (NSString *)getDisplayScriptWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns the full variant name in the default <code>Locale</code> for the variant code of
 this <code>Locale</code>.
 If there is no matching variant name, the variant code is
 returned.
 @since 1.7
 */
- (NSString *)getDisplayVariant;

/*!
 @brief Returns the full variant name in the specified <code>Locale</code> for the variant code
 of this <code>Locale</code>.
 If there is no matching variant name, the variant code is
 returned.
 @since 1.7
 */
- (NSString *)getDisplayVariantWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns the BCP-47 extension whose key is <code>extensionKey</code>, or <code>null</code>
 if this locale does not contain the extension.
 Individual Keywords and attributes for the unicode
 locale extension can be fetched using <code>getUnicodeLocaleAttributes()</code>,
 <code>getUnicodeLocaleKeys()</code>  and <code>getUnicodeLocaleType</code>.
 @since 1.7
 */
- (NSString *)getExtensionWithChar:(jchar)extensionKey;

/*!
 @brief Returns the set of BCP-47 extensions this locale contains.
 See <a href="https://tools.ietf.org/html/bcp47#section-2.1">
 the IETF BCP-47 specification</a> (Section 2.2.6) for details.
 @since 1.7
 */
- (id<JavaUtilSet>)getExtensionKeys;

/*!
 @brief Returns the three-letter ISO 3166 country code which corresponds to the country
 code for this <code>Locale</code>.
 @throws MissingResourceException if there's no 3-letter country code for this locale.
 */
- (NSString *)getISO3Country;

/*!
 @brief Returns the three-letter ISO 639-2/T language code which corresponds to the language
 code for this <code>Locale</code>.
 @throws MissingResourceException if there's no 3-letter language code for this locale.
 */
- (NSString *)getISO3Language;

/*!
 @brief Returns an array of strings containing all the two-letter ISO 3166 country codes that can be
 used as the country code when constructing a <code>Locale</code>.
 */
+ (IOSObjectArray *)getISOCountries;

/*!
 @brief Returns an array of strings containing all the two-letter ISO 639-1 language codes that can be
 used as the language code when constructing a <code>Locale</code>.
 */
+ (IOSObjectArray *)getISOLanguages;

/*!
 @brief Returns the language code for this <code>Locale</code> or the empty string if no language
 was set.
 */
- (NSString *)getLanguage;

/*!
 @brief Returns the script code for this <code>Locale</code> or an empty <code>String</code> if no script
 was set.
 If set, the script code will be a title cased string of length 4, as per the ISO 15924
 specification.
 @since 1.7
 */
- (NSString *)getScript;

/*!
 @brief Returns the set of unicode locale extension attributes this locale contains.
 For more information about attributes, see <code>Builder.addUnicodeLocaleAttribute</code>
 and <a href="http://www.unicode.org/reports/tr35/#BCP47">Unicode Technical Standard #35</a>
 @since 1.7
 */
- (id<JavaUtilSet>)getUnicodeLocaleAttributes;

/*!
 @brief Returns the set of unicode locale extension keywords this locale contains.
 For more information about types and keywords, see <code>Builder.setUnicodeLocaleKeyword</code>
 and <a href="http://www.unicode.org/reports/tr35/#BCP47">Unicode Technical Standard #35</a>
 @since 1.7
 */
- (id<JavaUtilSet>)getUnicodeLocaleKeys;

/*!
 @brief Returns the <code>type</code> for the specified unicode locale extension <code>key</code>.
 For more information about types and keywords, see <code>Builder.setUnicodeLocaleKeyword</code>
 and <a href="http://www.unicode.org/reports/tr35/#BCP47">Unicode Technical Standard #35</a>
 @since 1.7
 */
- (NSString *)getUnicodeLocaleTypeWithNSString:(NSString *)keyWord;

/*!
 @brief Returns the variant code for this <code>Locale</code> or an empty <code>String</code> if no variant
 was set.
 */
- (NSString *)getVariant;

- (NSUInteger)hash;

/*!
 @brief Visible for testing.
 */
+ (void)parseSerializedExtensionsWithNSString:(NSString *)extString
                              withJavaUtilMap:(id<JavaUtilMap>)outputMap;

/*!
 @brief This extension is described by http://www.unicode.org/reports/tr35/#RFC5234
 unicode_locale_extensions = sep "u" (1*(sep keyword) / 1*(sep attribute) *(sep keyword)).
 It must contain at least one keyword or attribute and attributes (if any)
 must appear before keywords. Attributes can't appear after keywords because
 they will be indistinguishable from a subtag of the keyword type.
 Visible for testing.
 */
+ (void)parseUnicodeExtensionWithNSStringArray:(IOSObjectArray *)subtags
                               withJavaUtilMap:(id<JavaUtilMap>)keywords
                               withJavaUtilSet:(id<JavaUtilSet>)attributes;

/*!
 @brief The serialized form for extensions is straightforward.
 It's simply
 of the form key1-value1-key2-value2 where each value might in turn contain
 multiple subtags separated by hyphens. Each key is guaranteed to be a single
 character in length.
 This method assumes that <code>extensionsMap</code> is non-empty.
 Visible for testing.
 */
+ (NSString *)serializeExtensionsWithJavaUtilMap:(id<JavaUtilMap>)extensionsMap;

/*!
 @brief Overrides the default locale.
 This does not affect system configuration,
 and attempts to override the system-provided default locale may
 themselves be overridden by actual changes to the system configuration.
 Code that calls this method is usually incorrect, and should be fixed by
 passing the appropriate locale to each locale-sensitive method that's
 called.
 */
+ (void)setDefaultWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns a well formed BCP-47 language tag that identifies this locale.
 Note that this locale itself might consist of ill formed fields, since the
 public <code>Locale</code> constructors do not perform validity checks to maintain
 backwards compatibility. When this is the case, this method will either replace
 ill formed fields with standard BCP-47 subtags (For eg. "und" (undetermined)
 for invalid languages) or omit them altogether.
 Additionally, ill formed variants will result in the remainder of the tag
 (both variants and extensions) being moved to the private use extension,
 where they will appear after a subtag whose value is <code>"lvariant"</code>.
 It's also important to note that the BCP-47 tag is well formed in the sense
 that it is unambiguously parseable into its specified components. We do not
 require that any of the components are registered with the applicable registries.
 For example, we do not require scripts to be a registered ISO 15924 scripts or
 languages to appear in the ISO-639-2 code list.
 @since 1.7
 */
- (NSString *)toLanguageTag;

/*!
 @brief Returns the string representation of this <code>Locale</code>.
 It consists of the
 language code, country code and variant separated by underscores.
 If the language is missing the string begins
 with an underscore. If the country is missing there are 2 underscores
 between the language and the variant. The variant cannot stand alone
 without a language and/or country code: in this case this method would
 return the empty string.
 <p>Examples: "en", "en_US", "_US", "en__POSIX", "en_US_POSIX"
 */
- (NSString *)description;

@end

J2OBJC_STATIC_INIT(JavaUtilLocale)

/*!
 @brief Locale constant for en_CA.
 */
inline JavaUtilLocale *JavaUtilLocale_get_CANADA();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CANADA;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, CANADA, JavaUtilLocale *)

/*!
 @brief Locale constant for fr_CA.
 */
inline JavaUtilLocale *JavaUtilLocale_get_CANADA_FRENCH();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CANADA_FRENCH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, CANADA_FRENCH, JavaUtilLocale *)

/*!
 @brief Locale constant for zh_CN.
 */
inline JavaUtilLocale *JavaUtilLocale_get_CHINA();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CHINA;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, CHINA, JavaUtilLocale *)

/*!
 @brief Locale constant for zh.
 */
inline JavaUtilLocale *JavaUtilLocale_get_CHINESE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CHINESE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, CHINESE, JavaUtilLocale *)

/*!
 @brief Locale constant for en.
 */
inline JavaUtilLocale *JavaUtilLocale_get_ENGLISH();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ENGLISH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, ENGLISH, JavaUtilLocale *)

/*!
 @brief Locale constant for fr_FR.
 */
inline JavaUtilLocale *JavaUtilLocale_get_FRANCE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_FRANCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, FRANCE, JavaUtilLocale *)

/*!
 @brief Locale constant for fr.
 */
inline JavaUtilLocale *JavaUtilLocale_get_FRENCH();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_FRENCH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, FRENCH, JavaUtilLocale *)

/*!
 @brief Locale constant for de.
 */
inline JavaUtilLocale *JavaUtilLocale_get_GERMAN();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_GERMAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, GERMAN, JavaUtilLocale *)

/*!
 @brief Locale constant for de_DE.
 */
inline JavaUtilLocale *JavaUtilLocale_get_GERMANY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_GERMANY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, GERMANY, JavaUtilLocale *)

/*!
 @brief Locale constant for it.
 */
inline JavaUtilLocale *JavaUtilLocale_get_ITALIAN();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ITALIAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, ITALIAN, JavaUtilLocale *)

/*!
 @brief Locale constant for it_IT.
 */
inline JavaUtilLocale *JavaUtilLocale_get_ITALY();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ITALY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, ITALY, JavaUtilLocale *)

/*!
 @brief Locale constant for ja_JP.
 */
inline JavaUtilLocale *JavaUtilLocale_get_JAPAN();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_JAPAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, JAPAN, JavaUtilLocale *)

/*!
 @brief Locale constant for ja.
 */
inline JavaUtilLocale *JavaUtilLocale_get_JAPANESE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_JAPANESE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, JAPANESE, JavaUtilLocale *)

/*!
 @brief Locale constant for ko_KR.
 */
inline JavaUtilLocale *JavaUtilLocale_get_KOREA();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_KOREA;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, KOREA, JavaUtilLocale *)

/*!
 @brief Locale constant for ko.
 */
inline JavaUtilLocale *JavaUtilLocale_get_KOREAN();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_KOREAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, KOREAN, JavaUtilLocale *)

/*!
 @brief Locale constant for zh_CN.
 */
inline JavaUtilLocale *JavaUtilLocale_get_PRC();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_PRC;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, PRC, JavaUtilLocale *)

/*!
 @brief Locale constant for the root locale.
 The root locale has an empty language,
 country, and variant.
 @since 1.6
 */
inline JavaUtilLocale *JavaUtilLocale_get_ROOT();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ROOT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, ROOT, JavaUtilLocale *)

/*!
 @brief Locale constant for zh_CN.
 */
inline JavaUtilLocale *JavaUtilLocale_get_SIMPLIFIED_CHINESE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_SIMPLIFIED_CHINESE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, SIMPLIFIED_CHINESE, JavaUtilLocale *)

/*!
 @brief Locale constant for zh_TW.
 */
inline JavaUtilLocale *JavaUtilLocale_get_TAIWAN();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_TAIWAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, TAIWAN, JavaUtilLocale *)

/*!
 @brief Locale constant for zh_TW.
 */
inline JavaUtilLocale *JavaUtilLocale_get_TRADITIONAL_CHINESE();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_TRADITIONAL_CHINESE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, TRADITIONAL_CHINESE, JavaUtilLocale *)

/*!
 @brief Locale constant for en_GB.
 */
inline JavaUtilLocale *JavaUtilLocale_get_UK();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_UK;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, UK, JavaUtilLocale *)

/*!
 @brief Locale constant for en_US.
 */
inline JavaUtilLocale *JavaUtilLocale_get_US();
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_US;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, US, JavaUtilLocale *)

/*!
 @brief BCP-47 extension identifier (or "singleton") for the private
 use extension.
 See <code>getExtension(char)</code> and <code>Builder.setExtension(char,String)</code>.
 @since 1.7
 */
inline jchar JavaUtilLocale_get_PRIVATE_USE_EXTENSION();
#define JavaUtilLocale_PRIVATE_USE_EXTENSION 'x'
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilLocale, PRIVATE_USE_EXTENSION, jchar)

/*!
 @brief BCP-47 extension identifier (or "singleton") for the unicode locale extension.
 See <code>getExtension(char)</code> and <code>Builder.setExtension(char,String)</code>.
 @since 1.7
 */
inline jchar JavaUtilLocale_get_UNICODE_LOCALE_EXTENSION();
#define JavaUtilLocale_UNICODE_LOCALE_EXTENSION 'u'
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilLocale, UNICODE_LOCALE_EXTENSION, jchar)

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_getDefaultLocaleFromSystemProperties();

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_forLanguageTagWithNSString_(NSString *languageTag);

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_(JavaUtilLocale *self, NSString *language);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_(NSString *language) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale *create_JavaUtilLocale_initWithNSString_(NSString *language);

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_withNSString_(JavaUtilLocale *self, NSString *language, NSString *country);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_withNSString_(NSString *language, NSString *country) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale *create_JavaUtilLocale_initWithNSString_withNSString_(NSString *language, NSString *country);

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_withNSString_withNSString_withNSString_withJavaUtilSet_withJavaUtilMap_withJavaUtilMap_withBoolean_(JavaUtilLocale *self, NSString *language, NSString *country, NSString *variant, NSString *scriptCode, id<JavaUtilSet> unicodeAttributes, id<JavaUtilMap> unicodeKeywords, id<JavaUtilMap> extensions, jboolean hasValidatedFields);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_withNSString_withNSString_withNSString_withJavaUtilSet_withJavaUtilMap_withJavaUtilMap_withBoolean_(NSString *language, NSString *country, NSString *variant, NSString *scriptCode, id<JavaUtilSet> unicodeAttributes, id<JavaUtilMap> unicodeKeywords, id<JavaUtilMap> extensions, jboolean hasValidatedFields) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale *create_JavaUtilLocale_initWithNSString_withNSString_withNSString_withNSString_withJavaUtilSet_withJavaUtilMap_withJavaUtilMap_withBoolean_(NSString *language, NSString *country, NSString *variant, NSString *scriptCode, id<JavaUtilSet> unicodeAttributes, id<JavaUtilMap> unicodeKeywords, id<JavaUtilMap> extensions, jboolean hasValidatedFields);

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_withNSString_withNSString_(JavaUtilLocale *self, NSString *language, NSString *country, NSString *variant);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_withNSString_withNSString_(NSString *language, NSString *country, NSString *variant) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale *create_JavaUtilLocale_initWithNSString_withNSString_withNSString_(NSString *language, NSString *country, NSString *variant);

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_getAvailableLocales();

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_getDefault();

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_getISOCountries();

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_getISOLanguages();

FOUNDATION_EXPORT void JavaUtilLocale_setDefaultWithJavaUtilLocale_(JavaUtilLocale *locale);

FOUNDATION_EXPORT NSString *JavaUtilLocale_serializeExtensionsWithJavaUtilMap_(id<JavaUtilMap> extensionsMap);

FOUNDATION_EXPORT void JavaUtilLocale_parseSerializedExtensionsWithNSString_withJavaUtilMap_(NSString *extString, id<JavaUtilMap> outputMap);

FOUNDATION_EXPORT void JavaUtilLocale_parseUnicodeExtensionWithNSStringArray_withJavaUtilMap_withJavaUtilSet_(IOSObjectArray *subtags, id<JavaUtilMap> keywords, id<JavaUtilSet> attributes);

FOUNDATION_EXPORT NSString *JavaUtilLocale_adjustLanguageCodeWithNSString_(NSString *languageCode);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLocale)

#endif

#if !defined (JavaUtilLocale_Builder_) && (INCLUDE_ALL_JavaUtilLocale || defined(INCLUDE_JavaUtilLocale_Builder))
#define JavaUtilLocale_Builder_

@class JavaUtilLocale;

/*!
 @brief A class that helps construct <code>Locale</code> instances.
 Unlike the public <code>Locale</code> constructors, the methods of this class
 perform much stricter checks on their input.
 Validity checks on the <code>language</code>, <code>country</code>, <code>variant</code>
 and <code>extension</code> values are carried out as per the
 <a href="https://tools.ietf.org/html/bcp47">BCP-47</a> specification.
 In addition, we treat the <a href="http://www.unicode.org/reports/tr35/">
 Unicode locale extension</a> specially and provide methods to manipulate
 the structured state (keywords and attributes) specified therein.
 @since 1.7
 */
@interface JavaUtilLocale_Builder : NSObject

#pragma mark Public

- (instancetype)init;

/*!
 @brief Adds the specified attribute to the list of attributes in the unicode
 locale extension.
 Attributes must be between 3 and 8 characters in length, and each character
 must be in the range <code>[a-zA-Z0-9]</code>.
 Attributes are normalized to lower case values. All added attributes and
 keywords are combined to form a complete unicode locale extension on
 <code>Locale</code> objects built by this builder, and accessible via
 <code>Locale.getExtension(char)</code> with the <code>Locale.UNICODE_LOCALE_EXTENSION</code>
 key.
 @throws IllformedLocaleException if <code>attribute</code> is invalid.
 @throws NullPointerException if <code>attribute</code> is null.
 */
- (JavaUtilLocale_Builder *)addUnicodeLocaleAttributeWithNSString:(NSString *)attribute;

/*!
 @brief Constructs a locale from the existing state of the builder.
 Note that this
 method is guaranteed to succeed since field validity checks are performed
 at the point of setting them.
 */
- (JavaUtilLocale *)build;

/*!
 @brief Clears all existing state from this builder.
 */
- (JavaUtilLocale_Builder *)clear;

/*!
 @brief Clears all extensions from this builder.
 Note that this also implicitly
 clears all state related to the unicode locale extension; all attributes
 and keywords set by <code>addUnicodeLocaleAttribute</code> and
 <code>setUnicodeLocaleKeyword</code> are cleared.
 */
- (JavaUtilLocale_Builder *)clearExtensions;

/*!
 @brief Removes an attribute from the list of attributes in the unicode locale
 extension.
 <code>attribute</code> must be valid as per the rules specified in
 <code>addUnicodeLocaleAttribute</code>.
 This method has no effect if <code>attribute</code> hasn't already been
 added.
 @throws IllformedLocaleException if <code>attribute</code> is invalid.
 @throws NullPointerException if <code>attribute</code> is null.
 */
- (JavaUtilLocale_Builder *)removeUnicodeLocaleAttributeWithNSString:(NSString *)attribute;

/*!
 @brief Sets the extension identified by <code>key</code> to <code>value</code>.
 <code>key</code> must be in the range <code>[a-zA-Z0-9]</code>.
 If <code>value</code> is <code>null</code> or empty, the extension is removed.
 In the general case, <code>value</code> must be a series of subtags separated
 by (<code>"-"</code> or <code>"_"</code>). Each subtag must be between
 2 and 8 characters in length, and each character in the subtag must be in
 the range <code>[a-zA-Z0-9]</code>.
 <p>
 There are two special cases :
 <li>
 <ul>
 The unicode locale extension
 (<code>key == 'u'</code>, <code>Locale.UNICODE_LOCALE_EXTENSION</code>) : Setting
 the unicode locale extension results in all existing keyword and attribute
 state being replaced by the parsed result of <code>value</code>. For example,
 <code>builder.setExtension('u', "baaaz-baaar-fo-baar-ba-baaz")</code>
 is equivalent to:
 @code

             builder.addUnicodeLocaleAttribute("baaaz");
             builder.addUnicodeLocaleAttribute("baaar");
             builder.setUnicodeLocaleKeyword("fo", "baar");
             builder.setUnicodeLocaleKeyword("ba", "baaa");
         
@endcode
 </ul>
 <ul>
 The private use extension
 (<code>key == 'x'</code>, <code>Locale.PRIVATE_USE_EXTENSION</code>) : Each subtag in a
 private use extension can be between 1 and 8 characters in length (in contrast
 to a minimum length of 2 for all other extensions).
 </ul>
 </li>
 @throws IllformedLocaleException if <code>value</code> is invalid.
 */
- (JavaUtilLocale_Builder *)setExtensionWithChar:(jchar)key
                                    withNSString:(NSString *)value;

/*!
 @brief Sets the locale language.
 If <code>language</code> is <code>null</code> or empty, the
 previous value is cleared.
 As per BCP-47, the language must be between 2 and 3 ASCII characters
 in length and must only contain characters in the range <code>[a-zA-Z]</code>.
 This value is usually an <a href="http://www.loc.gov/standards/iso639-2/">
 ISO-639-2</a> alpha-2 or alpha-3 code, though no explicit checks are
 carried out that it's a valid code in that namespace.
 Values are normalized to lower case.
 Note that we don't support BCP-47 "extlang" languages because they were
 only ever used to substitute for a lack of 3 letter language codes.
 @throws IllformedLocaleException if the language was invalid.
 */
- (JavaUtilLocale_Builder *)setLanguageWithNSString:(NSString *)language;

/*!
 @brief Set the state of this builder to the parsed contents of the BCP-47 language
 tag <code>languageTag</code>.
 This method is equivalent to a call to <code>clear</code> if <code>languageTag</code>
 is <code>null</code> or empty.
 <b>NOTE:</b> In contrast to <code>Locale.forLanguageTag(String)</code>, which
 simply ignores malformed input, this method will throw an exception if
 its input is malformed.
 @throws IllformedLocaleException if <code>languageTag</code> is not a well formed
 BCP-47 tag.
 */
- (JavaUtilLocale_Builder *)setLanguageTagWithNSString:(NSString *)languageTag;

/*!
 @brief Sets the state of the builder to the <code>Locale</code> represented by
 <code>locale</code>.
 Note that the locale's language, region and variant are validated as per
 the rules specified in <code>setLanguage</code>, <code>setRegion</code> and
 <code>setVariant</code>.
 All existing builder state is discarded.
 @throws IllformedLocaleException if <code>locale</code> is invalid.
 @throws NullPointerException if <code>locale</code> is null.
 */
- (JavaUtilLocale_Builder *)setLocaleWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Sets the locale region.
 If <code>region</code> is <code>null</code> or empty, the
 previous value is cleared.
 As per BCP-47, the region must either be a 2 character ISO-3166-1 code
 (each character in the range [a-zA-Z]) OR a 3 digit UN M.49 code.
 Values are normalized to upper case.
 @throws IllformedLocaleException if <code></code> region is invalid.
 */
- (JavaUtilLocale_Builder *)setRegionWithNSString:(NSString *)region;

/*!
 @brief Sets the locale script.
 If <code>script</code> is <code>null</code> or empty,
 the previous value is cleared.
 As per BCP-47, the script must be 4 characters in length, and
 each character in the range <code>[a-zA-Z]</code>.
 A script usually represents a valid ISO 15924 script code, though no
 other registry or validity checks are performed.
 Scripts are normalized to title cased values.
 @throws IllformedLocaleException if <code>script</code> is invalid.
 */
- (JavaUtilLocale_Builder *)setScriptWithNSString:(NSString *)script;

/*!
 @brief Adds a key / type pair to the list of unicode locale extension keys.
 <code>key</code> must be 2 characters in length, and each character must be
 in the range <code>[a-zA-Z0-9]</code>.
 {#code type} can either be empty, or a series of one or more subtags
 separated by a separator (<code>"-"</code> or <code>"_"</code>). Each subtag must
 be between 3 and 8 characters in length and each character in the subtag
 must be in the range <code>[a-zA-Z0-9]</code>.
 Note that the type is normalized to lower case, and all separators
 are normalized to <code>"-"</code>. All added attributes and
 keywords are combined to form a complete unicode locale extension on
 <code>Locale</code> objects built by this builder, and accessible via
 <code>Locale.getExtension(char)</code> with the <code>Locale.UNICODE_LOCALE_EXTENSION</code>
 key.
 @throws IllformedLocaleException if <code>key</code> or <code>value</code> are
 invalid.
 */
- (JavaUtilLocale_Builder *)setUnicodeLocaleKeywordWithNSString:(NSString *)key
                                                   withNSString:(NSString *)type;

/*!
 @brief Sets the locale variant.
 If <code>variant</code> is <code>null</code> or empty,
 the previous value is cleared.
 The input string my consist of one or more variants separated by
 valid separators ('-' or '_').
 As per BCP-47, each variant must be between 5 and 8 alphanumeric characters
 in length (each character in the range <code>[a-zA-Z0-9]</code>) but
 can be exactly 4 characters in length if the first character is a digit.
 Note that this is a much stricter interpretation of <code>variant</code>
 than the public <code>Locale</code> constructors. The latter allowed free form
 variants.
 Variants are case sensitive and all separators are normalized to <code>'_'</code>.
 @throws IllformedLocaleException if <code></code> variant is invalid.
 */
- (JavaUtilLocale_Builder *)setVariantWithNSString:(NSString *)variant;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilLocale_Builder)

FOUNDATION_EXPORT void JavaUtilLocale_Builder_init(JavaUtilLocale_Builder *self);

FOUNDATION_EXPORT JavaUtilLocale_Builder *new_JavaUtilLocale_Builder_init() NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale_Builder *create_JavaUtilLocale_Builder_init();

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLocale_Builder)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilLocale")

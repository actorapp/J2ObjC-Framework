//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/libcore/luni/src/main/java/java/util/regex/Pattern.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilRegexPattern")
#ifdef RESTRICT_JavaUtilRegexPattern
#define INCLUDE_ALL_JavaUtilRegexPattern 0
#else
#define INCLUDE_ALL_JavaUtilRegexPattern 1
#endif
#undef RESTRICT_JavaUtilRegexPattern

#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

#if !defined (JavaUtilRegexPattern_) && (INCLUDE_ALL_JavaUtilRegexPattern || defined(INCLUDE_JavaUtilRegexPattern))
#define JavaUtilRegexPattern_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@class JavaUtilRegexMatcher;
@protocol JavaLangCharSequence;

/*!
 @brief Patterns are compiled regular expressions.
 In many cases, convenience methods such as
 <code>String.matches</code>, <code>String.replaceAll</code> and
 <code>String.split</code> will be preferable, but if you need to do a lot of work
 with the same regular expression, it may be more efficient to compile it once and reuse it.
 The <code>Pattern</code> class and its companion, <code>Matcher</code>, also offer more functionality
 than the small amount exposed by <code>String</code>.
 @code

  // String convenience methods:
  boolean sawFailures = s.matches("Failures: \\d+");
  String farewell = s.replaceAll("Hello, (\\S+)", "Goodbye, $1");
  String[] fields = s.split(":");
  // Direct use of Pattern:
  Pattern p = Pattern.compile("Hello, (\\S+)");
  Matcher m = p.matcher(inputString);
  while (m.find()) { // Find each match in turn; String can't do this.
     String name = m.group(1); // Access a submatch group; String can't do this.
  }
  
@endcode
 <h3>Regular expression syntax</h3>
 <span class="datatable">
 
 
 
 <p>Java supports a subset of Perl 5 regular expression syntax. An important gotcha is that Java
 has no regular expression literals, and uses plain old string literals instead. This means that
 you need an extra level of escaping. For example, the regular expression <code>\s+</code> has to
 be represented as the string <code>"\\s+"</code>.
 <h3>Escape sequences</h3>
 <p><table>
 <tr> <td> \ </td> <td>Quote the following metacharacter (so <code>\.</code> matches a literal <code>.</code>).</td> </tr>
 <tr> <td> \Q </td> <td>Quote all following metacharacters until <code>\E</code>.</td> </tr>
 <tr> <td> \E </td> <td>Stop quoting metacharacters (started by <code>\Q</code>).</td> </tr>
 <tr> <td> \\ </td> <td>A literal backslash.</td> </tr>
 <tr> <td> &#x005c;u<i>hhhh</i> </td> <td>The Unicode character U+hhhh (in hex).</td> </tr>
 <tr> <td> &#x005c;x<i>hh</i> </td> <td>The Unicode character U+00hh (in hex).</td> </tr>
 <tr> <td> \c<i>x</i> </td> <td>The ASCII control character ^x (so <code>\cH</code> would be ^H, U+0008).</td> </tr>
 <tr> <td> \a </td> <td>The ASCII bell character (U+0007).</td> </tr>
 <tr> <td> \e </td> <td>The ASCII ESC character (U+001b).</td> </tr>
 <tr> <td> \f </td> <td>The ASCII form feed character (U+000c).</td> </tr>
 <tr> <td> \n </td> <td>The ASCII newline character (U+000a).</td> </tr>
 <tr> <td> \r </td> <td>The ASCII carriage return character (U+000d).</td> </tr>
 <tr> <td> \t </td> <td>The ASCII tab character (U+0009).</td> </tr>
 </table>
 <h3>Character classes</h3>
 <p>It's possible to construct arbitrary character classes using set operations:
 <table>
 <tr> <td> [abc] </td> <td>Any one of <code>a</code>, <code>b</code>, or <code>c</code>. (Enumeration.)</td> </tr>
 <tr> <td> [a-c] </td> <td>Any one of <code>a</code>, <code>b</code>, or <code>c</code>. (Range.)</td> </tr>
 <tr> <td> [^abc] </td> <td>Any character <i>except</i> <code>a</code>, <code>b</code>, or <code>c</code>. (Negation.)</td> </tr>
 <tr> <td> [[a-f][0-9]] </td> <td>Any character in either range. (Union.)</td> </tr>
 <tr> <td> [[a-z]&&[jkl]] </td> <td>Any character in both ranges. (Intersection.)</td> </tr>
 </table>
 <p>Most of the time, the built-in character classes are more useful:
 <table>
 <tr> <td> \d </td> <td>Any digit character (see note below).</td> </tr>
 <tr> <td> \D </td> <td>Any non-digit character (see note below).</td> </tr>
 <tr> <td> \s </td> <td>Any whitespace character (see note below).</td> </tr>
 <tr> <td> \S </td> <td>Any non-whitespace character (see note below).</td> </tr>
 <tr> <td> \w </td> <td>Any word character (see note below).</td> </tr>
 <tr> <td> \W </td> <td>Any non-word character (see note below).</td> </tr>
 <tr> <td> \p{<i>NAME</i>} </td> <td> Any character in the class with the given <i>NAME</i>. </td> </tr>
 <tr> <td> \P{<i>NAME</i>} </td> <td> Any character <i>not</i> in the named class. </td> </tr>
 </table>
 <p>Note that these built-in classes don't just cover the traditional ASCII range. For example,
 <code>\w</code> is equivalent to the character class <code>[\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nd}]</code>.
 For more details see <a href="http://www.unicode.org/reports/tr18/#Compatibility_Properties">Unicode TR-18</a>,
 and bear in mind that the set of characters in each class can vary between Unicode releases.
 If you actually want to match only ASCII characters, specify the explicit characters you want;
 if you mean 0-9 use <code>[0-9]</code> rather than <code>\d</code>, which would also include
 Gurmukhi digits and so forth.
 <p>There are also a variety of named classes:
 <ul>
 <li><a href="../../lang/Character.html#unicode_categories">Unicode category names</a>,
 prefixed by <code>Is</code>. For example <code></code> \pIsLu}} for all uppercase letters.
 <li>POSIX class names. These are 'Alnum', 'Alpha', 'ASCII', 'Blank', 'Cntrl', 'Digit',
 'Graph', 'Lower', 'Print', 'Punct', 'Upper', 'XDigit'.
 <li>Unicode block names, as accepted as input to <code>java.lang.Character.UnicodeBlock.forName</code>,
 prefixed by <code>In</code>. For example <code></code> \pInHebrew}} for all characters in the Hebrew block.
 <li>Character method names. These are all non-deprecated methods from <code>java.lang.Character</code>
 whose name starts with <code>is</code>, but with the <code>is</code> replaced by <code>java</code>.
 For example, <code></code> \pjavaLowerCase}}.
 </ul>
 <h3>Quantifiers</h3>
 <p>Quantifiers match some number of instances of the preceding regular expression.
 <table>
 <tr> <td> * </td> <td>Zero or more.</td> </tr>
 <tr> <td> ? </td> <td>Zero or one.</td> </tr>
 <tr> <td> + </td> <td>One or more.</td> </tr>
 <tr> <td> {<i>n</i>} </td> <td>Exactly <i>n</i>.</td> </tr>
 <tr> <td> {<i>n,</i>} </td> <td>At least <i>n</i>.</td> </tr>
 <tr> <td> {<i>n</i>,<i>m</i>} </td> <td>At least <i>n</i> but not more than <i>m</i>.</td> </tr>
 </table>
 <p>Quantifiers are "greedy" by default, meaning that they will match the longest possible input
 sequence. There are also non-greedy quantifiers that match the shortest possible input sequence.
 They're same as the greedy ones but with a trailing <code>?</code>:
 <table>
 <tr> <td> *? </td> <td>Zero or more (non-greedy).</td> </tr>
 <tr> <td> ?? </td> <td>Zero or one (non-greedy).</td> </tr>
 <tr> <td> +? </td> <td>One or more (non-greedy).</td> </tr>
 <tr> <td> {<i>n</i>}? </td> <td>Exactly <i>n</i> (non-greedy).</td> </tr>
 <tr> <td> {<i>n,</i>}? </td> <td>At least <i>n</i> (non-greedy).</td> </tr>
 <tr> <td> {<i>n</i>,<i>m</i>}? </td> <td>At least <i>n</i> but not more than <i>m</i> (non-greedy).</td> </tr>
 </table>
 <p>Quantifiers allow backtracking by default. There are also possessive quantifiers to prevent
 backtracking. They're same as the greedy ones but with a trailing <code>+</code>:
 <table>
 <tr> <td> *+ </td> <td>Zero or more (possessive).</td> </tr>
 <tr> <td> ?+ </td> <td>Zero or one (possessive).</td> </tr>
 <tr> <td> ++ </td> <td>One or more (possessive).</td> </tr>
 <tr> <td> {<i>n</i>}+ </td> <td>Exactly <i>n</i> (possessive).</td> </tr>
 <tr> <td> {<i>n,</i>}+ </td> <td>At least <i>n</i> (possessive).</td> </tr>
 <tr> <td> {<i>n</i>,<i>m</i>}+ </td> <td>At least <i>n</i> but not more than <i>m</i> (possessive).</td> </tr>
 </table>
 <h3>Zero-width assertions</h3>
 <p><table>
 <tr> <td> ^ </td> <td>At beginning of line.</td> </tr>
 <tr> <td> $ </td> <td>At end of line.</td> </tr>
 <tr> <td> \A </td> <td>At beginning of input.</td> </tr>
 <tr> <td> \b </td> <td>At word boundary.</td> </tr>
 <tr> <td> \B </td> <td>At non-word boundary.</td> </tr>
 <tr> <td> \G </td> <td>At end of previous match.</td> </tr>
 <tr> <td> \z </td> <td>At end of input.</td> </tr>
 <tr> <td> \Z </td> <td>At end of input, or before newline at end.</td> </tr>
 </table>
 <h3>Look-around assertions</h3>
 <p>Look-around assertions assert that the subpattern does (positive) or doesn't (negative) match
 after (look-ahead) or before (look-behind) the current position, without including the matched
 text in the containing match. The maximum length of possible matches for look-behind patterns
 must not be unbounded.
 <p><table>
 <tr> <td> (?=<i>a</i>) </td> <td>Zero-width positive look-ahead.</td> </tr>
 <tr> <td> (?!<i>a</i>) </td> <td>Zero-width negative look-ahead.</td> </tr>
 <tr> <td> (?&lt;=<i>a</i>) </td> <td>Zero-width positive look-behind.</td> </tr>
 <tr> <td> (?&lt;!<i>a</i>) </td> <td>Zero-width negative look-behind.</td> </tr>
 </table>
 <h3>Groups</h3>
 <p><table>
 <tr> <td> (<i>a</i>) </td> <td>A capturing group.</td> </tr>
 <tr> <td> (?:<i>a</i>) </td> <td>A non-capturing group.</td> </tr>
 <tr> <td> (?&gt;<i>a</i>) </td> <td>An independent non-capturing group. (The first match of the subgroup is the only match tried.)</td> </tr>
 <tr> <td> \<i>n</i> </td> <td>The text already matched by capturing group <i>n</i>.</td> </tr>
 </table>
 <p>See <code>Matcher.group</code> for details of how capturing groups are numbered and accessed.
 <h3>Operators</h3>
 <p><table>
 <tr> <td> <i>ab</i> </td> <td>Expression <i>a</i> followed by expression <i>b</i>.</td> </tr>
 <tr> <td> <i>a</i>|<i>b</i> </td> <td>Either expression <i>a</i> or expression <i>b</i>.</td> </tr>
 </table>
 <a name="flags"><h3>Flags</h3></a>
 <p><table>
 <tr> <td> (?dimsux-dimsux:<i>a</i>) </td> <td>Evaluates the expression <i>a</i> with the given flags enabled/disabled.</td> </tr>
 <tr> <td> (?dimsux-dimsux) </td> <td>Evaluates the rest of the pattern with the given flags enabled/disabled.</td> </tr>
 </table>
 <p>The flags are:
 <table>
 <tr><td><code>i</code></td> <td><code>CASE_INSENSITIVE</code></td> <td>case insensitive matching</td></tr>
 <tr><td><code>d</code></td> <td><code>UNIX_LINES</code></td>       <td>only accept <code>'\n'</code> as a line terminator</td></tr>
 <tr><td><code>m</code></td> <td><code>MULTILINE</code></td>        <td>allow <code>^</code> and <code>$</code> to match beginning/end of any line</td></tr>
 <tr><td><code>s</code></td> <td><code>DOTALL</code></td>           <td>allow <code>.</code> to match <code>'\n'</code> ("s" for "single line")</td></tr>
 <tr><td><code>u</code></td> <td><code>UNICODE_CASE</code></td>     <td>enable Unicode case folding</td></tr>
 <tr><td><code>x</code></td> <td><code>COMMENTS</code></td>         <td>allow whitespace and comments</td></tr>
 </table>
 <p>Either set of flags may be empty. For example, <code>(?i-m)</code> would turn on case-insensitivity
 and turn off multiline mode, <code>(?i)</code> would just turn on case-insensitivity,
 and <code>(?-m)</code> would just turn off multiline mode.
 <p>Note that on Android, <code>UNICODE_CASE</code> is always on: case-insensitive matching will
 always be Unicode-aware.
 <p>There are two other flags not settable via this mechanism: <code>CANON_EQ</code> and
 <code>LITERAL</code>. Attempts to use <code>CANON_EQ</code> on Android will throw an exception.
 </span>
 <h3>Implementation notes</h3>
 <p>The regular expression implementation used in Android is provided by
 <a href="http://www.icu-project.org">ICU</a>. The notation for the regular
 expressions is mostly a superset of those used in other Java language
 implementations. This means that existing applications will normally work as
 expected, but in rare cases Android may accept a regular expression that is
 not accepted by other implementations.
 <p>In some cases, Android will recognize that a regular expression is a simple
 special case that can be handled more efficiently. This is true of both the convenience methods
 in <code>String</code> and the methods in <code>Pattern</code>.
 - seealso: Matcher
 */
@interface JavaUtilRegexPattern : NSObject < JavaIoSerializable > {
 @public
  jlong address_;
}

+ (jint)UNIX_LINES;

+ (jint)CASE_INSENSITIVE;

+ (jint)COMMENTS;

+ (jint)MULTILINE;

+ (jint)LITERAL;

+ (jint)DOTALL;

+ (jint)UNICODE_CASE;

+ (jint)CANON_EQ;

#pragma mark Public

/*!
 @brief Equivalent to <code>Pattern.compile(pattern, 0)</code>.
 */
+ (JavaUtilRegexPattern *)compileWithNSString:(NSString *)pattern;

/*!
 @brief Returns a compiled form of the given <code>regularExpression</code>, as modified by the
 given <code>flags</code>.
 See the <a href="#flags">flags overview</a> for more on flags.
 @throws PatternSyntaxException if the regular expression is syntactically incorrect.
 - seealso: #CANON_EQ
 - seealso: #CASE_INSENSITIVE
 - seealso: #COMMENTS
 - seealso: #DOTALL
 - seealso: #LITERAL
 - seealso: #MULTILINE
 - seealso: #UNICODE_CASE
 - seealso: #UNIX_LINES
 */
+ (JavaUtilRegexPattern *)compileWithNSString:(NSString *)regularExpression
                                      withInt:(jint)flags;

/*!
 @brief Returns the flags supplied to <code>compile</code>.
 */
- (jint)flags;

/*!
 @brief Returns a <code>Matcher</code> for this pattern applied to the given <code>input</code>.
 The <code>Matcher</code> can be used to match the <code>Pattern</code> against the
 whole input, find occurrences of the <code>Pattern</code> in the input, or
 replace parts of the input.
 */
- (JavaUtilRegexMatcher *)matcherWithJavaLangCharSequence:(id<JavaLangCharSequence>)input;

/*!
 @brief Tests whether the given <code>regularExpression</code> matches the given <code>input</code>.
 Equivalent to <code>Pattern.compile(regularExpression).matcher(input).matches()</code>.
 If the same regular expression is to be used for multiple operations, it may be more
 efficient to reuse a compiled <code>Pattern</code>.
 - seealso: Pattern#compile(java.lang.String,int)
 - seealso: Matcher#matches()
 */
+ (jboolean)matchesWithNSString:(NSString *)regularExpression
       withJavaLangCharSequence:(id<JavaLangCharSequence>)input;

/*!
 @brief Returns the regular expression supplied to <code>compile</code>.
 */
- (NSString *)pattern;

/*!
 @brief Quotes the given <code>string</code> using "\Q" and "\E", so that all
 meta-characters lose their special meaning.
 This method correctly
 escapes embedded instances of "\Q" or "\E". If the entire result
 is to be passed verbatim to <code>compile</code>, it's usually clearer
 to use the <code>LITERAL</code> flag instead.
 */
+ (NSString *)quoteWithNSString:(NSString *)string;

/*!
 @brief Equivalent to <code>split(input, 0)</code>.
 */
- (IOSObjectArray *)splitWithJavaLangCharSequence:(id<JavaLangCharSequence>)input;

/*!
 @brief Splits the given <code>input</code> at occurrences of this pattern.
 <p>If this pattern does not occur in the input, the result is an
 array containing the input (converted from a <code>CharSequence</code> to
 a <code>String</code>).
 <p>Otherwise, the <code>limit</code> parameter controls the contents of the
 returned array as described below.
 @param limit
 Determines the maximum number of entries in the resulting
 array, and the treatment of trailing empty strings.
 <ul>
 <li>For n &gt; 0, the resulting array contains at most n
 entries. If this is fewer than the number of matches, the
 final entry will contain all remaining input.
 <li>For n &lt; 0, the length of the resulting array is
 exactly the number of occurrences of the <code>Pattern</code>
 plus one for the text after the final separator.
 All entries are included.
 <li>For n == 0, the result is as for n &lt; 0, except
 trailing empty strings will not be returned. (Note that
 the case where the input is itself an empty string is
 special, as described above, and the limit parameter does
 not apply there.)
 </ul>
 */
- (IOSObjectArray *)splitWithJavaLangCharSequence:(id<JavaLangCharSequence>)input
                                          withInt:(jint)limit;

- (NSString *)description;

#pragma mark Protected

- (void)javaFinalize;

#pragma mark Package-Private

+ (jboolean)matchesWithNSString:(NSString *)regularExpression
                   withNSString:(NSString *)input;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilRegexPattern)

/*!
 @brief This constant specifies that a pattern matches Unix line endings ('\n')
 only against the '
 .', '^', and '$' meta characters. Corresponds to <code>(?d)</code>.
 */
inline jint JavaUtilRegexPattern_get_UNIX_LINES();
#define JavaUtilRegexPattern_UNIX_LINES 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilRegexPattern, UNIX_LINES, jint)

/*!
 @brief This constant specifies that a <code>Pattern</code> is matched
 case-insensitively.
 That is, the patterns "a+" and "A+" would both match
 the string "aAaAaA". See <code>UNICODE_CASE</code>. Corresponds to <code>(?i)</code>.
 */
inline jint JavaUtilRegexPattern_get_CASE_INSENSITIVE();
#define JavaUtilRegexPattern_CASE_INSENSITIVE 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilRegexPattern, CASE_INSENSITIVE, jint)

/*!
 @brief This constant specifies that a <code>Pattern</code> may contain whitespace or
 comments.
 Otherwise comments and whitespace are taken as literal
 characters. Corresponds to <code>(?x)</code>.
 */
inline jint JavaUtilRegexPattern_get_COMMENTS();
#define JavaUtilRegexPattern_COMMENTS 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilRegexPattern, COMMENTS, jint)

/*!
 @brief This constant specifies that the meta characters '^' and '$' match only
 the beginning and end of an input line, respectively.
 Normally, they
 match the beginning and the end of the complete input. Corresponds to <code>(?m)</code>.
 */
inline jint JavaUtilRegexPattern_get_MULTILINE();
#define JavaUtilRegexPattern_MULTILINE 8
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilRegexPattern, MULTILINE, jint)

/*!
 @brief This constant specifies that the whole <code>Pattern</code> is to be taken
 literally, that is, all meta characters lose their meanings.
 */
inline jint JavaUtilRegexPattern_get_LITERAL();
#define JavaUtilRegexPattern_LITERAL 16
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilRegexPattern, LITERAL, jint)

/*!
 @brief This constant specifies that the '.' meta character matches arbitrary
 characters, including line endings, which is normally not the case.
 Corresponds to <code>(?s)</code>.
 */
inline jint JavaUtilRegexPattern_get_DOTALL();
#define JavaUtilRegexPattern_DOTALL 32
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilRegexPattern, DOTALL, jint)

/*!
 @brief This constant specifies that a <code>Pattern</code> that uses case-insensitive matching
 will use Unicode case folding.
 On Android, <code>UNICODE_CASE</code> is always on:
 case-insensitive matching will always be Unicode-aware. If your code is intended to
 be portable and uses case-insensitive matching on non-ASCII characters, you should
 use this flag. Corresponds to <code>(?u)</code>.
 */
inline jint JavaUtilRegexPattern_get_UNICODE_CASE();
#define JavaUtilRegexPattern_UNICODE_CASE 64
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilRegexPattern, UNICODE_CASE, jint)

/*!
 @brief This constant specifies that a character in a <code>Pattern</code> and a
 character in the input string only match if they are canonically
 equivalent.
 It is (currently) not supported in Android.
 */
inline jint JavaUtilRegexPattern_get_CANON_EQ();
#define JavaUtilRegexPattern_CANON_EQ 128
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilRegexPattern, CANON_EQ, jint)

FOUNDATION_EXPORT JavaUtilRegexPattern *JavaUtilRegexPattern_compileWithNSString_withInt_(NSString *regularExpression, jint flags);

FOUNDATION_EXPORT JavaUtilRegexPattern *JavaUtilRegexPattern_compileWithNSString_(NSString *pattern);

FOUNDATION_EXPORT jboolean JavaUtilRegexPattern_matchesWithNSString_withJavaLangCharSequence_(NSString *regularExpression, id<JavaLangCharSequence> input);

FOUNDATION_EXPORT jboolean JavaUtilRegexPattern_matchesWithNSString_withNSString_(NSString *regularExpression, NSString *input);

FOUNDATION_EXPORT NSString *JavaUtilRegexPattern_quoteWithNSString_(NSString *string);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilRegexPattern)

#endif


#pragma clang diagnostic pop
#pragma pop_macro("INCLUDE_ALL_JavaUtilRegexPattern")
